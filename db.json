{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/universe.css","path":"css/universe.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/universe.js","path":"js/universe.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/CNAME 2","path":"CNAME 2","modified":1,"renderable":0},{"_id":"source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":1,"renderable":0},{"_id":"source/img/bg.JPG","path":"img/bg.JPG","modified":1,"renderable":0},{"_id":"source/img/build-your-own-react.jpg","path":"img/build-your-own-react.jpg","modified":1,"renderable":0},{"_id":"source/img/fiber-tree.png","path":"img/fiber-tree.png","modified":1,"renderable":0},{"_id":"source/img/js-again.jpeg","path":"img/js-again.jpeg","modified":1,"renderable":0},{"_id":"source/img/rxjs-first-sight.jpeg","path":"img/rxjs-first-sight.jpeg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_data/bangumis.json","hash":"88593bcac7aa2a238d217c4414d0bd4f5f5ce87e","modified":1653834212348},{"_id":"source/CNAME","hash":"7ae7a0ca39848304ea46a80ea0b4c8cb3ef66294","modified":1653830876536},{"_id":"source/CNAME 2","hash":"7ae7a0ca39848304ea46a80ea0b4c8cb3ef66294","modified":1653812831000},{"_id":"source/.DS_Store","hash":"e97d8865cd15326e0b92ef774d18c86c577087db","modified":1653118814753},{"_id":"source/_posts/build-your-own-react-translate.md","hash":"da565e57a59b9755cb7f5cf003b14b5ac4251bb6","modified":1653830876537},{"_id":"source/_posts/js-again-primitive-type-boolean-undefined-null.md","hash":"b46b9b139e2f7fd4750dbbaa8b189c83f7bc9e02","modified":1653830876537},{"_id":"source/_posts/js-again-primitive-type-object.md","hash":"76d3d0b5fffcf3172a296609de290f86c82ff587","modified":1653830876538},{"_id":"source/_posts/js-again-primitive-type-string.md","hash":"59b6ba5c6b47e0fccd290c50c439c1ad97920c14","modified":1653830876538},{"_id":"source/_posts/js-again-primitive-type-bigint-symbol.md","hash":"bfcd45e73ebdf4a4acd01f08fae9086cf09d0fc8","modified":1653830876537},{"_id":"source/_posts/js-again-primitive-type-number.md","hash":"95968541a0e05c4b876af049c8cb3dd935da273b","modified":1653830876537},{"_id":"source/_posts/js-again-type-conversion.md","hash":"81d38864bfefb76de5c2dcf46dbc2ee467c0eb2f","modified":1653830876538},{"_id":"source/categories/index.md","hash":"66041de7a9d18a61cd479e2f7bcd246d8118102e","modified":1653830876539},{"_id":"source/img/.DS_Store","hash":"ffe5f631081c025f50f71d8a5ed931ee5877c0aa","modified":1653118814755},{"_id":"source/_posts/js-again-varible.md","hash":"e1596e73ab955bc6b3767d60cd16698ae937a1e7","modified":1653830876538},{"_id":"source/about/index.md","hash":"0fa1360391eea95cb9684d1bb3bb2d423cfd1973","modified":1653830876539},{"_id":"source/_posts/rxjs-first-sight.md","hash":"e06bb9ec31e15424630b8b57fb6100f72af2c6ac","modified":1653830876539},{"_id":"source/img/avatar.jpeg","hash":"08911bc926e1b42ee57b703a59ceebf7479e8778","modified":1653830876539},{"_id":"source/img/fiber-tree.png","hash":"af9fe559a1bf2d476f77752a6e98ea62baa1dd1f","modified":1653830876544},{"_id":"source/tags/index.md","hash":"550ff3ca93ce55b391b14ab8e828ee3b7ce22709","modified":1653830876544},{"_id":"source/img/rxjs-first-sight.jpeg","hash":"8e2822394b6df213a20d9b033c3f473cb645d9d5","modified":1653830876544},{"_id":"source/img/js-again.jpeg","hash":"db1e97ddb20f0082419210bff6c260b5d486349e","modified":1653830876544},{"_id":"source/img/build-your-own-react.jpg","hash":"3e05724176c81730e202397a8d99bfec87903d87","modified":1653830876544},{"_id":"themes/butterfly/_config.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1652606178986},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1651722516907},{"_id":"themes/butterfly/README_CN.md","hash":"b591ea049da306efd6f11b69b323bf528feace8c","modified":1653809405460},{"_id":"themes/butterfly/package.json","hash":"42f0fab667d1424ead097b7dcc68cb9c8af281f4","modified":1651722516918},{"_id":"themes/butterfly/README.md","hash":"da5918f6f698b5ccdb34ead73e68db7a9ae00e29","modified":1653809405480},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"947f794e862bb2813e36887f777bdb760f70a322","modified":1651722516908},{"_id":"themes/butterfly/.github/stale.yml","hash":"5e8ea535424e8112439135d21afc5262c0bc0b39","modified":1651722516907},{"_id":"themes/butterfly/languages/en.yml","hash":"d1bb560698eb8b0079495b7b18b44facb610f9fd","modified":1651722516908},{"_id":"themes/butterfly/languages/default.yml","hash":"1e37a3695d50e3e61d7c36e58a6dac872a4a56cd","modified":1651722516908},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"28b6f0c39155651d747eb595e0a283bc97be2e09","modified":1651722516908},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1651722516917},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1651722516908},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1651722516908},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1651722516918},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1651722516917},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1651722516918},{"_id":"themes/butterfly/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1651840086336},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"67e4f5a66d4b8cabadbaad0410628364ee75e0ae","modified":1651722516907},{"_id":"themes/butterfly/source/.DS_Store","hash":"5b699246690a85eabfa83aa4321fabeb6979cd45","modified":1651840095742},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1651722516907},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1651722516907},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1651722516907},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1651722516908},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"54511ed299a3bcf4ecbb62e3078f6b0611ccbd2c","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"594a977ebe8d97e60fa3d7cb40fc260ded4d8a58","modified":1651722516908},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"da27c20f0e672103b984e135eb2fe7770ca7fcce","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"fbf5f718fdc7c3d360b1787bf33ec46453aaec38","modified":1651890046161},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1651722516918},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/init.js","hash":"a7f567b3d3110afe2f99c967b8e15351a7f5bd6d","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/404.js","hash":"bd8ea2e2ce77ca7050d487a5d0b1c86ad6877c25","modified":1652520576204},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1651722516918},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1651722516918},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b4cd617c619d1a0df93603721a6fa1317526174b","modified":1651722516919},{"_id":"themes/butterfly/scripts/events/config.js","hash":"0f3a37d25d82a5109103e07bbc1457f34a98bc28","modified":1653809482589},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1651722516911},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"d368a8830e506c8b5eb6512b709ec8db354d5ea1","modified":1651722516919},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1651722516911},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1651722516919},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1651722516920},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1651722516911},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1651722516924},{"_id":"themes/butterfly/source/img/.DS_Store","hash":"757c3d5a11f3a5488bfdedcd5f77b68e191d9692","modified":1651886455467},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1651722516919},{"_id":"themes/butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1651722516924},{"_id":"themes/butterfly/source/css/universe.css","hash":"d1905e8a01f207b5def2471c652f35c8f76b233b","modified":1652606849609},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1651722516924},{"_id":"themes/butterfly/source/js/universe.js","hash":"61044db75fb5e35bc8ea513a318ab92c4b7cb139","modified":1651842176917},{"_id":"themes/butterfly/source/img/favicon.png","hash":"1f74195694c46c269bc0d5ff65226b299d94a8b4","modified":1651840057578},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1651722516909},{"_id":"themes/butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1651722516909},{"_id":"themes/butterfly/source/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1651722516925},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"8f41fa9732ea654a10f6e666d9c782c7e27e5ea6","modified":1651722516909},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1651722516924},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"02f5a0a7c3fe4eba5ab6cf5b681c1e17a88f2eba","modified":1653809405118},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"b9ebb02af8ccf43e3f73be43db19254fa913c57b","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"ef2abe26e11ae9a786771144383e9fcb66719209","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"de2e978ff0cacd02eb635cf7676a39e9a21781dd","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"bae2f32ac96cebef600c1e37eaa8467c9a7e5d92","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"8e61bae7aa7c1fbe79e3716269665f13320cd4cf","modified":1653809405118},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1651722516917},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1651722516920},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1651722516921},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"644d520fe80cc82058467708ab82ccad313b0c27","modified":1651722516920},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"ca58af8903eb1d1d05edae54fc2e23aeac6da6c5","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"15056fba0bd5a45ea8dc97eb557f6929ff16797a","modified":1651722516921},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1651722516920},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1651722516922},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1651722516922},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"f67177310f5594954b25a591d186d28d5d450b18","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"826dae759062d8f84eb2bf5ab8fdb80e0f79d58b","modified":1651722516922},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"f9cd4dbbe5e3c7760b1a37d4d2b8d09be37b8880","modified":1651722516923},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"51e45625929d57c9df3ba9090af99b9b7bb9a15b","modified":1651722516923},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1651722516922},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1651722516923},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"8314e9749eb1ae40c4bae9735b7a6638b2d6876a","modified":1651722516922},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1651722516923},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"08493b66b9f31f2bd3e9a3115017a0ce16142b20","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1651722516923},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1651722516924},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1651722516922},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1651722516924},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1651722516911},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7d98129f2ee08169f877b76d4d0b95c17df354f8","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"5f648086a33a32d169a2f8d8c549c08aa02f67db","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"693d999777dd16e0566d29ac3203d4c167b2f9a7","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"2d8fc3fb8f9aec61400acf3c94070bd8539058f8","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"e4850f2c9ba5f6b2248808f7257662679e0fab0a","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"309b9aee523f90aff13d48142d124de9039d8511","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"9302837f1e35f153323bb4f166514c7e96e8ecdd","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"c488a3414dbae899488b6d46f6cb91575bc23b9e","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"8cb8fcc210edab1ae1adf4aee8cc6948f7e9f28e","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"15462d1ed04651ad3b430c682842ac400f6f9b47","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"5737164f5a77fb813b5bacba0a273d2a490a2ced","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"7c712719bb8960c335f94b519923e5a86ee7bd32","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"22e2ef30fe5eb1db7566e89943c74ece029b2a8e","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"26ac3fb930fe9f3ace0c5d0191b87425bf053e74","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"dd0bc119029b62dce5dc965d5de7377e438fa29a","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1651722516916},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1651722516920},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1651722516914},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1651722516920},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1651722516915},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1651722516920},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1651722516920},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1651722516920},{"_id":"source/img/bg.JPG","hash":"cd90f1acd674c5e2e622b5a1950a7749a0679aef","modified":1653830876543},{"_id":"public/404.html","hash":"ae356bea21a3d3f8da2866916b98f67a8eaf98b6","modified":1653834212549},{"_id":"public/categories/index.html","hash":"c9906502e50249d8598a6cda44338436f5b334f3","modified":1653834212549},{"_id":"public/about/index.html","hash":"7077810a08968ceaed57e92d42ef614a23f152dc","modified":1653834212549},{"_id":"public/tags/index.html","hash":"ae3724c66cd23620bc097e769a8d5019cf919ae2","modified":1653834212549},{"_id":"public/2022/05/15/build-your-own-react-translate/index.html","hash":"dc6808eec4f69578b8dc1a822ac7ee1cc1e83e8a","modified":1653834212549},{"_id":"public/2022/05/07/js-again-type-conversion/index.html","hash":"293468c3cfea4f0ef392595b118dc56429d47d7d","modified":1653834212549},{"_id":"public/2022/05/06/js-again-primitive-type-object/index.html","hash":"660cfcf934316b671ca626ea6e65f76ad99888dc","modified":1653834212549},{"_id":"public/2022/05/06/rxjs-first-sight/index.html","hash":"0452214ce438daf5e28b1aa46e560c830934ae48","modified":1653834212549},{"_id":"public/2022/05/06/js-again-primitive-type-bigint-symbol/index.html","hash":"10c87f8ef525f684bd4915a9104c2a64d528b7d2","modified":1653834212549},{"_id":"public/2022/05/05/js-again-primitive-type-boolean-undefined-null/index.html","hash":"8e82e27a5c7947ce038c3564410f16631c973ec9","modified":1653834212549},{"_id":"public/2022/05/05/js-again-primitive-type-string/index.html","hash":"1a2402cf4022e6a53e63c5ef9ef0791136a39b65","modified":1653834212549},{"_id":"public/2022/05/05/js-again-primitive-type-number/index.html","hash":"fdfa5e86a91883a0d52ba70d787b21f88a7ee8c2","modified":1653834212549},{"_id":"public/2022/05/05/js-again-varible/index.html","hash":"7aaab8b2787d3421523e658f81d3563136292b05","modified":1653834212549},{"_id":"public/bangumis/index.html","hash":"6f892036153a966cb475f8b5073212bb8deae5e1","modified":1653834212549},{"_id":"public/archives/index.html","hash":"66c8599715d504594b4fe3aa258207ab761e3c0c","modified":1653834212549},{"_id":"public/archives/2022/index.html","hash":"b7cc3c852631a02c34e1653e9e078526e5827c8e","modified":1653834212549},{"_id":"public/archives/2022/05/index.html","hash":"3a119e4f2b1a2fc8ddc6c553230b128ed02f4c02","modified":1653834212549},{"_id":"public/index.html","hash":"ab2acecea490d96b647e11c801d097d658ca8939","modified":1653834212549},{"_id":"public/categories/前端/index.html","hash":"41a671620c12a36df02509aee4eac1b08974c79e","modified":1653834212549},{"_id":"public/categories/前端/JavaScript/index.html","hash":"5d0fceb29bf7ec8362319fff47683b126ad1016a","modified":1653834212549},{"_id":"public/categories/前端/React/index.html","hash":"1199256dbea361b80acc72ec1942b97c12646290","modified":1653834212549},{"_id":"public/categories/翻译/index.html","hash":"aa1e7d61345a23cf4c0a4e3106c256dce1fad056","modified":1653834212549},{"_id":"public/categories/前端/RxJS/index.html","hash":"44f6331257ac4f14ba291c56c78b536c1428a72b","modified":1653834212549},{"_id":"public/tags/数据类型/index.html","hash":"997e0361c9404e9caa05a849965def2c0d320309","modified":1653834212549},{"_id":"public/tags/React/index.html","hash":"57baba3bf9968bb702342d2b47749afd43606644","modified":1653834212549},{"_id":"public/tags/类型转换/index.html","hash":"efb4e11bf639e3333fae56a31fb0c40276790cf3","modified":1653834212549},{"_id":"public/tags/变量/index.html","hash":"8cf099f6ef9013f5a5a5b50ce8f29d6c46928b61","modified":1653834212549},{"_id":"public/tags/RxJS/index.html","hash":"e1a402a1e12d2aa8331acf2d43e134ebfccec50f","modified":1653834212549},{"_id":"public/img/favicon.png","hash":"1f74195694c46c269bc0d5ff65226b299d94a8b4","modified":1653834212549},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1653834212549},{"_id":"public/CNAME","hash":"7ae7a0ca39848304ea46a80ea0b4c8cb3ef66294","modified":1653834212549},{"_id":"public/CNAME 2","hash":"7ae7a0ca39848304ea46a80ea0b4c8cb3ef66294","modified":1653834212549},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1653834212549},{"_id":"public/img/fiber-tree.png","hash":"af9fe559a1bf2d476f77752a6e98ea62baa1dd1f","modified":1653834212549},{"_id":"public/img/js-again.jpeg","hash":"db1e97ddb20f0082419210bff6c260b5d486349e","modified":1653834212549},{"_id":"public/img/rxjs-first-sight.jpeg","hash":"8e2822394b6df213a20d9b033c3f473cb645d9d5","modified":1653834212549},{"_id":"public/img/avatar.jpeg","hash":"08911bc926e1b42ee57b703a59ceebf7479e8778","modified":1653834212549},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653834212549},{"_id":"public/css/universe.css","hash":"d1905e8a01f207b5def2471c652f35c8f76b233b","modified":1653834212549},{"_id":"public/js/universe.js","hash":"61044db75fb5e35bc8ea513a318ab92c4b7cb139","modified":1653834212549},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1653834212549},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1653834212549},{"_id":"public/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1653834212549},{"_id":"public/css/index.css","hash":"9f488381868f20e80615224ebbd2e54b2152d3c2","modified":1653834212549},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1653834212549},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1653834212549},{"_id":"public/img/build-your-own-react.jpg","hash":"3e05724176c81730e202397a8d99bfec87903d87","modified":1653834212549},{"_id":"public/img/bg.JPG","hash":"cd90f1acd674c5e2e622b5a1950a7749a0679aef","modified":1653834212549}],"Category":[{"name":"前端","_id":"cl3re6un80007vuo98hkw2v50"},{"name":"JavaScript","parent":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6unb000lvuo96dds2lf9"},{"name":"React","parent":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6und000zvuo96qtr4miq"},{"name":"翻译","_id":"cl3re6und0019vuo9g4qfc0cq"},{"name":"RxJS","parent":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6ung001jvuo90c8l80vd"}],"Data":[{"_id":"bangumis","data":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}],"Page":[{"title":"文章分类","date":"2022-05-05T06:07:55.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2022-05-05 14:07:55\ntype: \"categories\"\n---\n","updated":"2022-05-29T13:27:56.539Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl3re6un20000vuo9ftvxfml6","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"cover":"https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","excerpt":"","more":""},{"title":"关于我","date":"2022-05-06T06:44:45.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-05-06 14:44:45\n---\n","updated":"2022-05-29T13:27:56.539Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl3re6un60002vuo95uspbl09","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"cover":"https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","excerpt":"","more":""},{"title":"文章标签","date":"2022-05-05T06:06:46.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 文章标签\ndate: 2022-05-05 14:06:46\ntype: \"tags\"\n---\n","updated":"2022-05-29T13:27:56.544Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl3re6un70005vuo98yzz7fcw","content":"","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"cover":"https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","excerpt":"","more":""}],"Post":[{"title":"再学 JS 之数据类型 —— bigint、symbol","date":"2022-05-06T02:20:04.000Z","updated":"2022-05-29T13:27:56.537Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# bigInt 与 symbol\n\n# bigInt\n\n在一个整数字面量后面加 `n` 的方式定义一个 `bigInt`的变量，或者通过调用函数`BigInt()`创建（不需要使用`new`关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。\n\n> `bigInt`类型不能和`number`类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用`+value`的形式来将`bigInt`类型的值转换为`number`类型，需使用`Number()`方法显式地进行转换；`BigInt`类型的值在转换为`number`类型的值时可能会丢失精度，建议在值可能大于`2^53`的情况下再使用 `bigInt`类型；同时`bigInt`类型的值不能使用`Math`对象的方法。\n> \n\n```js\ntypeof 4n === 'bigint'\ntypeof BigInt(3) === 'bigint'\n// 与number类型的值可进行比较\n\n// 宽松相等 严格不相等\n3n == 3 // true\n3n === 3 // false\n\n2 > 1n // true\n3.0 <= 3n // true\n\n// BigInt类型的值进行小数运算时会取整\n3n/2n === 1n // true\n\n+3n // Uncaught TypeError: Cannot convert a BigInt value to a number\n\nMath.ceil(5n/2n) // Uncaught TypeError: Cannot convert a BigInt value to a number\n```\n\n# symbol\n\n`symbol`类型只能通过调用`Symbol()`函数（不需要使用`new`关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。\n\n```js\ntypeof Symbol() === 'symbol'\n```\n\n`Symbol`函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于`symbol`类型的值是独一无二的，所以就算是传入相同的字符串的`symbol`也不相等。\n\n```js\nconst s1 = Symbol('foo')\nconst s2 = Symbol('foo')\n\nconsole.log(s1) // Symbol(foo)\n\ns1 == s2 // false\ns1 === s2 // false\n```\n\n## 内置的Symbol\n\nES6除了引入`symbol`这一基本类型以外，还提供了11个内置的`symbol`值，它们在语言内部使用，用于暴露语言内部的行为。比如`for...of`循环要求被循环的对象实现了`Symbol.iterator`这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。\n\n```js\n// 以下代码为使用 Symbol.iterator 来实现指针结构\n\nclass Node {\n  value;\n  next;\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n  [Symbol.iterator]() {\n    let iterator = { next: next };\n    let current = this;\n    function next() {\n      if (current) {\n        const value = current.value;\n        current = current.next;\n        return {\n          done: false,\n          value: value,\n        };\n      } else {\n        return {\n          done: true,\n        };\n      }\n    }\n    return iterator;\n  }\n}\n\nlet one = new Node(1);\nlet two = new Node(2);\nlet three = new Node(3);\n\none.next = two;\ntwo.next = three;\n\nfor (const n of one) {\n  console.log(n);\n}\n// 1 2 3\n```\n\n## 常用方法\n\n### Symbol.for(key)\n\n该方法会根据传入的`key`，在运行时的`全局symbol注册表`中去查找是否存在已经登记了相同`key`值的`symbol`，如果存在，则返回该`symbol`；反之则创建一个新的`symbol`，并将其登记到`全局symbol注册表`中去。这也是该方法与`Symbol`方法的区别，直接使用`Symbol`方法创建`symbol`类型的值不会被放到`全局symbol注册表`中。\n\n```js\nconst s1 = Symbol.for('foo')\nconst s2 = Symbol.for('foo')\n\ns1 === s2 // true\n```\n\n### Symbol.keyFor(symbol)\n\n该方法需要传入一个`symbol`类型的参数，然后会根据传入的参数在`全局symbol注册表`中查找与该参数相关联的`key`值，并返回`key`值；如果没有找到，则返回`undefined`。\n\n```js\nlet sym = Symbol();\nSymbol.keyFor(sym) // undefined\n\nsym = Symbol.for('foo')\nSymbol.keyFor(sym) // 'foo'\n```\n\n## symbol的实际应用\n\n### 消除魔法字符串\n\n魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。\n\n```js\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\nexport const REACT_PORTAL_TYPE = hasSymbol\n  ? Symbol.for('react.portal')\n  : 0xeaca;\nexport const REACT_FRAGMENT_TYPE = hasSymbol\n  ? Symbol.for('react.fragment')\n  : 0xeacb;\nexport const REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.strict_mode')\n  : 0xeacc;\nexport const REACT_PROFILER_TYPE = hasSymbol\n  ? Symbol.for('react.profiler')\n  : 0xead2;\nexport const REACT_PROVIDER_TYPE = hasSymbol\n  ? Symbol.for('react.provider')\n  : 0xeacd;\nexport const REACT_CONTEXT_TYPE = hasSymbol\n  ? Symbol.for('react.context')\n  : 0xeace;\nexport const REACT_CONCURRENT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.concurrent_mode')\n  : 0xeacf;\nexport const REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for('react.forward_ref')\n  : 0xead0;\nexport const REACT_SUSPENSE_TYPE = hasSymbol\n  ? Symbol.for('react.suspense')\n  : 0xead1;\nexport const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nexport const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n```\n\n### 隐藏属性\n\n这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且`symbol`类型的属性不会参与`for...in`、`for...of`等循环，但需要注意，可以通过`Object.getOwnPropertySymbols()`方法获取指定对象的所有 Symbol 属性名。","source":"_posts/js-again-primitive-type-bigint-symbol.md","raw":"---\ntitle: 再学 JS 之数据类型 —— bigint、symbol\ndate: 2022-05-06 10:20:04\nupdated:\ntags: \n  - 数据类型\ncategories: \n  - [前端, JavaScript]\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# bigInt 与 symbol\n\n# bigInt\n\n在一个整数字面量后面加 `n` 的方式定义一个 `bigInt`的变量，或者通过调用函数`BigInt()`创建（不需要使用`new`关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。\n\n> `bigInt`类型不能和`number`类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用`+value`的形式来将`bigInt`类型的值转换为`number`类型，需使用`Number()`方法显式地进行转换；`BigInt`类型的值在转换为`number`类型的值时可能会丢失精度，建议在值可能大于`2^53`的情况下再使用 `bigInt`类型；同时`bigInt`类型的值不能使用`Math`对象的方法。\n> \n\n```js\ntypeof 4n === 'bigint'\ntypeof BigInt(3) === 'bigint'\n// 与number类型的值可进行比较\n\n// 宽松相等 严格不相等\n3n == 3 // true\n3n === 3 // false\n\n2 > 1n // true\n3.0 <= 3n // true\n\n// BigInt类型的值进行小数运算时会取整\n3n/2n === 1n // true\n\n+3n // Uncaught TypeError: Cannot convert a BigInt value to a number\n\nMath.ceil(5n/2n) // Uncaught TypeError: Cannot convert a BigInt value to a number\n```\n\n# symbol\n\n`symbol`类型只能通过调用`Symbol()`函数（不需要使用`new`关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。\n\n```js\ntypeof Symbol() === 'symbol'\n```\n\n`Symbol`函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于`symbol`类型的值是独一无二的，所以就算是传入相同的字符串的`symbol`也不相等。\n\n```js\nconst s1 = Symbol('foo')\nconst s2 = Symbol('foo')\n\nconsole.log(s1) // Symbol(foo)\n\ns1 == s2 // false\ns1 === s2 // false\n```\n\n## 内置的Symbol\n\nES6除了引入`symbol`这一基本类型以外，还提供了11个内置的`symbol`值，它们在语言内部使用，用于暴露语言内部的行为。比如`for...of`循环要求被循环的对象实现了`Symbol.iterator`这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。\n\n```js\n// 以下代码为使用 Symbol.iterator 来实现指针结构\n\nclass Node {\n  value;\n  next;\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n  [Symbol.iterator]() {\n    let iterator = { next: next };\n    let current = this;\n    function next() {\n      if (current) {\n        const value = current.value;\n        current = current.next;\n        return {\n          done: false,\n          value: value,\n        };\n      } else {\n        return {\n          done: true,\n        };\n      }\n    }\n    return iterator;\n  }\n}\n\nlet one = new Node(1);\nlet two = new Node(2);\nlet three = new Node(3);\n\none.next = two;\ntwo.next = three;\n\nfor (const n of one) {\n  console.log(n);\n}\n// 1 2 3\n```\n\n## 常用方法\n\n### Symbol.for(key)\n\n该方法会根据传入的`key`，在运行时的`全局symbol注册表`中去查找是否存在已经登记了相同`key`值的`symbol`，如果存在，则返回该`symbol`；反之则创建一个新的`symbol`，并将其登记到`全局symbol注册表`中去。这也是该方法与`Symbol`方法的区别，直接使用`Symbol`方法创建`symbol`类型的值不会被放到`全局symbol注册表`中。\n\n```js\nconst s1 = Symbol.for('foo')\nconst s2 = Symbol.for('foo')\n\ns1 === s2 // true\n```\n\n### Symbol.keyFor(symbol)\n\n该方法需要传入一个`symbol`类型的参数，然后会根据传入的参数在`全局symbol注册表`中查找与该参数相关联的`key`值，并返回`key`值；如果没有找到，则返回`undefined`。\n\n```js\nlet sym = Symbol();\nSymbol.keyFor(sym) // undefined\n\nsym = Symbol.for('foo')\nSymbol.keyFor(sym) // 'foo'\n```\n\n## symbol的实际应用\n\n### 消除魔法字符串\n\n魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。\n\n```js\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\nexport const REACT_PORTAL_TYPE = hasSymbol\n  ? Symbol.for('react.portal')\n  : 0xeaca;\nexport const REACT_FRAGMENT_TYPE = hasSymbol\n  ? Symbol.for('react.fragment')\n  : 0xeacb;\nexport const REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.strict_mode')\n  : 0xeacc;\nexport const REACT_PROFILER_TYPE = hasSymbol\n  ? Symbol.for('react.profiler')\n  : 0xead2;\nexport const REACT_PROVIDER_TYPE = hasSymbol\n  ? Symbol.for('react.provider')\n  : 0xeacd;\nexport const REACT_CONTEXT_TYPE = hasSymbol\n  ? Symbol.for('react.context')\n  : 0xeace;\nexport const REACT_CONCURRENT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.concurrent_mode')\n  : 0xeacf;\nexport const REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for('react.forward_ref')\n  : 0xead0;\nexport const REACT_SUSPENSE_TYPE = hasSymbol\n  ? Symbol.for('react.suspense')\n  : 0xead1;\nexport const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nexport const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n```\n\n### 隐藏属性\n\n这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且`symbol`类型的属性不会参与`for...in`、`for...of`等循环，但需要注意，可以通过`Object.getOwnPropertySymbols()`方法获取指定对象的所有 Symbol 属性名。","slug":"js-again-primitive-type-bigint-symbol","published":1,"layout":"post","photos":[],"link":"","_id":"cl3re6un40001vuo9dxx92392","content":"<h1 id=\"bigInt-与-symbol\"><a href=\"#bigInt-与-symbol\" class=\"headerlink\" title=\"bigInt 与 symbol\"></a>bigInt 与 symbol</h1><h1 id=\"bigInt\"><a href=\"#bigInt\" class=\"headerlink\" title=\"bigInt\"></a>bigInt</h1><p>在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>bigInt</code>的变量，或者通过调用函数<code>BigInt()</code>创建（不需要使用<code>new</code>关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。</p>\n<blockquote>\n<p><code>bigInt</code>类型不能和<code>number</code>类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用<code>+value</code>的形式来将<code>bigInt</code>类型的值转换为<code>number</code>类型，需使用<code>Number()</code>方法显式地进行转换；<code>BigInt</code>类型的值在转换为<code>number</code>类型的值时可能会丢失精度，建议在值可能大于<code>2^53</code>的情况下再使用 <code>bigInt</code>类型；同时<code>bigInt</code>类型的值不能使用<code>Math</code>对象的方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">4n</span> === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">BigInt</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 与number类型的值可进行比较</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宽松相等 严格不相等</span></span><br><span class=\"line\"><span class=\"number\">3n</span> == <span class=\"number\">3</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3n</span> === <span class=\"number\">3</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span> &gt; <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3.0</span> &lt;= <span class=\"number\">3n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BigInt类型的值进行小数运算时会取整</span></span><br><span class=\"line\"><span class=\"number\">3n</span>/<span class=\"number\">2n</span> === <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"number\">3n</span> <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(<span class=\"number\">5n</span>/<span class=\"number\">2n</span>) <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p><code>symbol</code>类型只能通过调用<code>Symbol()</code>函数（不需要使用<code>new</code>关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>() === <span class=\"string\">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于<code>symbol</code>类型的值是独一无二的，所以就算是传入相同的字符串的<code>symbol</code>也不相等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s1) <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1 == s2 <span class=\"comment\">// false</span></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内置的Symbol\"><a href=\"#内置的Symbol\" class=\"headerlink\" title=\"内置的Symbol\"></a>内置的Symbol</h2><p>ES6除了引入<code>symbol</code>这一基本类型以外，还提供了11个内置的<code>symbol</code>值，它们在语言内部使用，用于暴露语言内部的行为。比如<code>for...of</code>循环要求被循环的对象实现了<code>Symbol.iterator</code>这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下代码为使用 Symbol.iterator 来实现指针结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  value;</span><br><span class=\"line\">  next;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">next</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> iterator = &#123; <span class=\"attr\">next</span>: next &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> value = current.<span class=\"property\">value</span>;</span><br><span class=\"line\">        current = current.<span class=\"property\">next</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"attr\">value</span>: value,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> three = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">one.<span class=\"property\">next</span> = two;</span><br><span class=\"line\">two.<span class=\"property\">next</span> = three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> one) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"Symbol-for-key\"><a href=\"#Symbol-for-key\" class=\"headerlink\" title=\"Symbol.for(key)\"></a>Symbol.for(key)</h3><p>该方法会根据传入的<code>key</code>，在运行时的<code>全局symbol注册表</code>中去查找是否存在已经登记了相同<code>key</code>值的<code>symbol</code>，如果存在，则返回该<code>symbol</code>；反之则创建一个新的<code>symbol</code>，并将其登记到<code>全局symbol注册表</code>中去。这也是该方法与<code>Symbol</code>方法的区别，直接使用<code>Symbol</code>方法创建<code>symbol</code>类型的值不会被放到<code>全局symbol注册表</code>中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol-keyFor-symbol\"><a href=\"#Symbol-keyFor-symbol\" class=\"headerlink\" title=\"Symbol.keyFor(symbol)\"></a>Symbol.keyFor(symbol)</h3><p>该方法需要传入一个<code>symbol</code>类型的参数，然后会根据传入的参数在<code>全局symbol注册表</code>中查找与该参数相关联的<code>key</code>值，并返回<code>key</code>值；如果没有找到，则返回<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">sym = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"symbol的实际应用\"><a href=\"#symbol的实际应用\" class=\"headerlink\" title=\"symbol的实际应用\"></a>symbol的实际应用</h2><h3 id=\"消除魔法字符串\"><a href=\"#消除魔法字符串\" class=\"headerlink\" title=\"消除魔法字符串\"></a>消除魔法字符串</h3><p>魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span></span><br><span class=\"line\"><span class=\"comment\">// nor polyfill, then a plain number is used for performance.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasSymbol = <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; <span class=\"title class_\">Symbol</span>.<span class=\"property\">for</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.element&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeac7</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PORTAL_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.portal&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeaca</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FRAGMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.fragment&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacb</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_STRICT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.strict_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacc</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROFILER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.profiler&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead2</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROVIDER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.provider&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacd</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONTEXT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.context&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeace</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONCURRENT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.concurrent_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacf</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FORWARD_REF_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.forward_ref&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_SUSPENSE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.suspense&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_MEMO_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.memo&#x27;</span>) : <span class=\"number\">0xead3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_LAZY_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.lazy&#x27;</span>) : <span class=\"number\">0xead4</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏属性\"><a href=\"#隐藏属性\" class=\"headerlink\" title=\"隐藏属性\"></a>隐藏属性</h3><p>这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且<code>symbol</code>类型的属性不会参与<code>for...in</code>、<code>for...of</code>等循环，但需要注意，可以通过<code>Object.getOwnPropertySymbols()</code>方法获取指定对象的所有 Symbol 属性名。</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"bigInt-与-symbol\"><a href=\"#bigInt-与-symbol\" class=\"headerlink\" title=\"bigInt 与 symbol\"></a>bigInt 与 symbol</h1><h1 id=\"bigInt\"><a href=\"#bigInt\" class=\"headerlink\" title=\"bigInt\"></a>bigInt</h1><p>在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>bigInt</code>的变量，或者通过调用函数<code>BigInt()</code>创建（不需要使用<code>new</code>关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。</p>\n<blockquote>\n<p><code>bigInt</code>类型不能和<code>number</code>类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用<code>+value</code>的形式来将<code>bigInt</code>类型的值转换为<code>number</code>类型，需使用<code>Number()</code>方法显式地进行转换；<code>BigInt</code>类型的值在转换为<code>number</code>类型的值时可能会丢失精度，建议在值可能大于<code>2^53</code>的情况下再使用 <code>bigInt</code>类型；同时<code>bigInt</code>类型的值不能使用<code>Math</code>对象的方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">4n</span> === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">BigInt</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 与number类型的值可进行比较</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宽松相等 严格不相等</span></span><br><span class=\"line\"><span class=\"number\">3n</span> == <span class=\"number\">3</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3n</span> === <span class=\"number\">3</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span> &gt; <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3.0</span> &lt;= <span class=\"number\">3n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BigInt类型的值进行小数运算时会取整</span></span><br><span class=\"line\"><span class=\"number\">3n</span>/<span class=\"number\">2n</span> === <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"number\">3n</span> <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(<span class=\"number\">5n</span>/<span class=\"number\">2n</span>) <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p><code>symbol</code>类型只能通过调用<code>Symbol()</code>函数（不需要使用<code>new</code>关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>() === <span class=\"string\">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于<code>symbol</code>类型的值是独一无二的，所以就算是传入相同的字符串的<code>symbol</code>也不相等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s1) <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1 == s2 <span class=\"comment\">// false</span></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内置的Symbol\"><a href=\"#内置的Symbol\" class=\"headerlink\" title=\"内置的Symbol\"></a>内置的Symbol</h2><p>ES6除了引入<code>symbol</code>这一基本类型以外，还提供了11个内置的<code>symbol</code>值，它们在语言内部使用，用于暴露语言内部的行为。比如<code>for...of</code>循环要求被循环的对象实现了<code>Symbol.iterator</code>这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下代码为使用 Symbol.iterator 来实现指针结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  value;</span><br><span class=\"line\">  next;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">next</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> iterator = &#123; <span class=\"attr\">next</span>: next &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> value = current.<span class=\"property\">value</span>;</span><br><span class=\"line\">        current = current.<span class=\"property\">next</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"attr\">value</span>: value,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> three = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">one.<span class=\"property\">next</span> = two;</span><br><span class=\"line\">two.<span class=\"property\">next</span> = three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> one) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"Symbol-for-key\"><a href=\"#Symbol-for-key\" class=\"headerlink\" title=\"Symbol.for(key)\"></a>Symbol.for(key)</h3><p>该方法会根据传入的<code>key</code>，在运行时的<code>全局symbol注册表</code>中去查找是否存在已经登记了相同<code>key</code>值的<code>symbol</code>，如果存在，则返回该<code>symbol</code>；反之则创建一个新的<code>symbol</code>，并将其登记到<code>全局symbol注册表</code>中去。这也是该方法与<code>Symbol</code>方法的区别，直接使用<code>Symbol</code>方法创建<code>symbol</code>类型的值不会被放到<code>全局symbol注册表</code>中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol-keyFor-symbol\"><a href=\"#Symbol-keyFor-symbol\" class=\"headerlink\" title=\"Symbol.keyFor(symbol)\"></a>Symbol.keyFor(symbol)</h3><p>该方法需要传入一个<code>symbol</code>类型的参数，然后会根据传入的参数在<code>全局symbol注册表</code>中查找与该参数相关联的<code>key</code>值，并返回<code>key</code>值；如果没有找到，则返回<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">sym = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"symbol的实际应用\"><a href=\"#symbol的实际应用\" class=\"headerlink\" title=\"symbol的实际应用\"></a>symbol的实际应用</h2><h3 id=\"消除魔法字符串\"><a href=\"#消除魔法字符串\" class=\"headerlink\" title=\"消除魔法字符串\"></a>消除魔法字符串</h3><p>魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span></span><br><span class=\"line\"><span class=\"comment\">// nor polyfill, then a plain number is used for performance.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasSymbol = <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; <span class=\"title class_\">Symbol</span>.<span class=\"property\">for</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.element&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeac7</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PORTAL_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.portal&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeaca</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FRAGMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.fragment&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacb</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_STRICT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.strict_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacc</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROFILER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.profiler&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead2</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROVIDER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.provider&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacd</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONTEXT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.context&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeace</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONCURRENT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.concurrent_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacf</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FORWARD_REF_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.forward_ref&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_SUSPENSE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.suspense&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_MEMO_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.memo&#x27;</span>) : <span class=\"number\">0xead3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_LAZY_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.lazy&#x27;</span>) : <span class=\"number\">0xead4</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏属性\"><a href=\"#隐藏属性\" class=\"headerlink\" title=\"隐藏属性\"></a>隐藏属性</h3><p>这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且<code>symbol</code>类型的属性不会参与<code>for...in</code>、<code>for...of</code>等循环，但需要注意，可以通过<code>Object.getOwnPropertySymbols()</code>方法获取指定对象的所有 Symbol 属性名。</p>\n"},{"title":"[译] Build your own React","date":"2022-05-15T08:17:23.000Z","updated":"2022-05-29T13:27:56.537Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/build-your-own-react.jpg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# Build your own React\n\n本文翻译自博文 **[Build your own React](https://pomb.us/build-your-own-react/)** ，原作者为 [Rodrigo Pombo](https://pomb.us/)，已获得作者授权。\n\n# 第零步：回顾 JSX to JS\n\n首先我们先通过以下三行代码来回顾一些 `React` 中的基本概念。\n\n```js\nconst element = <h1 title=\"foo\">Hello</h1>\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n第一行代码定义了一个`React`元素。\n\n第二行代码从`DOM`中获取了`id`为`root`的元素。\n\n第三行代码将第一行定义的`React`元素渲染到第二行获取到的元素中去。\n\n以上三行代码就构成了一个非常简单的`React App`，让我们来看看如何通过原生的`JS`来代替以上三行代码。\n\n```js\nconst element = <h1 title=\"foo\">Hello</h1>\n```\n\n先来看看第一行代码，其中的`React`元素就是通过`js`来定义的，它甚至不是合法的`JS`语法，为了用原生的`JS`来替代它，首先我们得让它变得合法。\n\nJSX到JS到转换是通过像[Babel](https://babeljs.io/)这样的工具来实现的，转换过程比较简单：把`js`语法中的标签`tag`、属性`props`、子元素`children`作为参数传入一个叫做`createElement`的函数来处理。\n\n```js\nconst element = React.createElement(\n  \"h1\",\n  { title: \"foo\" },\n  \"Hello\"\n)\n```\n\n`React.createElement`这个方法通过传入的参数创建了一个对象。抛开这个方法会对参数的一些验证以外，这就是它所做的全部事情。以此为基础，我们也可以简单模仿一下`React.createElement`创建的对象。\n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n```\n\n我们所定义的元素是一个具有两个属性（`type`和`props`）的对象（当然真正的`ReactElement`可不止这两个属性，不过在这里我们只关心这两个）。\n\n`type`指的是我们想要创建的`DOM`元素类型的字符串，等同于通过`document.createElement`方法来创建`DOM`元素时传入的`tagName`。`type`也可以是一个函数，但是为了不造成困惑，这个等到第七步时我们再说。 \n\n`props`也是一个对象，它存放的是JSX中设置的特性（`attributes`）的键与值，以及一个特殊的属性（`property`）`children`。\n\n`children`在这里是一个字符串，不过更多时候它会是一个包含许多元素的数组，这也是为什么众多的元素通过错综复杂的关系能够构建成树的原因。\n\n```js\nReactDOM.render(element, container)\n```\n\n另外我们需要来处理的一个方法是`ReactDOM.render`。`render`是`React`来改变`DOM`的方法，这样简单的一句描述有些过于宽泛了，不过我们先可以根据这点来试着捣鼓捣鼓它是怎么改变`DOM`的。\n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n```\n\n首先我们根据我们创建的`element`的属性`type`来创建对应的`DOM`节点，在这里是`h1`。然后我们根据**元素**`element`的属性为创建的**节点**设置属性，在这里是`title`。\n\n> 为了避免困扰，在这里说明一下，文中所说的**元素**指的是`React Element`，**节点**指的是`DOM Element`，以此来区分两者。\n> \n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n```\n\n然后我们来为子元素创建相应的节点。这里的话只有一个子元素，为此我们需要创建一个文本节点。之所以选择创建文本节点（`textNode`）而不是设置`innerText`属性，是因为这样做的话之后我们能够通过同一种方式来处理所有元素。\n\n同时需要注意，我们在为节点设置`nodeValue`属性的这个过程，与设置节点`h1`设置`title`属性类似，就像是在设置一个文本节点的`nodeValue`为`Hello`，即`props: {nodeValue: \"hello\"}`。\n\n```js\nconst container = document.getElementById(\"root\")\n\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n\n最后，我们将创建的文本节点放到节点`h1`上，将节点`h1`放到`id`为`root`的节点上去。\n\n到此为止，我们就完成了用原生的`JS`来替代`JSX`语法这一目标，完整的代码如下：\n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n\nconst container = document.getElementById(\"root\")\n\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n\n# 第一步：createElement\n\n```js\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n让我们从另外一个`React App`开始。这次，我们来尝试创建一个自己的`React`来替代真正的`React`。\n\n从实现`createElement`方法开始吧。\n\n首先，在JSX`转换到`JS`的这个过程中，让我们看看`createElement`这个方法到底都做了些什么吧。\n\n```js\n/** JSX */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\n\n/** JS */\nconst element = React.createElement(\n  \"div\",\n  { id: \"foo\" },\n  React.createElement(\"a\", null, \"bar\"),\n  React.createElement(\"b\")\n}\n```\n\n在前面我们提到过，一个元素（我们简化过的）实际上就是一个带有`type`和`props`这两个属性的对象。我们的方法唯一需要操心的就是如何去创建这个对象。\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children,\n    },\n  }\n}\n```\n\n在以上代码中，我们使用展开操作符`...`来处理`props`，使用剩余参数语法`...`（没错，还是这三个点，都是`ES6`语法）来处理`children`，经过剩余参数语法的处理，`children`就变成了一个数组。\n\n例如，`createElement(\"div\")`返回：\n\n```js\n{\n  type: \"div\",\n  props: { children: [] }\n}\n```\n\n`createElement(\"div\", null, a)`返回：\n\n```js\n{\n  type: \"div\",\n  props: { children: [a] }\n}\n```\n\n`createElement(\"div\", null, a, b)`返回：\n\n```js\n{\n  type: \"div\",\n  props: { children: [a, b] }\n}\n```\n\n需要注意的是，`children`数组中的元素不一定是对象，也有可能是原始类型的值如`number`或`string`。对于这种元素，我们需要封装成一个对象，并为其创建一种特殊的`type`：`TEXT_ELEMENT`。\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n```\n\n> 需要注意真正的`React`并没有封装原始类型的值或在没有`children`时创建一个空数组，我们这样做是为了简化我们的代码，因为我们的目标是易于理解，而不是追求高性能。\n> \n\n```js\nconst element = React.createElement(\n  \"div\",\n  { id: \"foo\" },\n  React.createElement(\"a\", null, \"bar\"),\n  React.createElement(\"b\")\n}\n```\n\n到此为止，我们还没有替换`React.createElement`这个方法\n\n替换`React`的第一步，给我们的库取个名字吧🤨。\n\n名字要听起来像`React`🤔，同时也要有教学（*`didactic`*）的味道🧐。\n\n有了💡，就叫它`Didact`吧。\n\n```js\nconst Didact = {\n  createElement,\n}\n\nconst element = Didact.createElement(\n  \"div\",\n  { id: \"foo\" },\n  Didact.createElement(\"a\", null, \"bar\"),\n  Didact.createElement(\"b\")\n}\n```\n\n但是我们仍然需要使用`JSX`语法，怎样才能让`babel`知道我们用的是`Didact`中的`createElement`方法而不是`React`的呢？\n\n```js\n/** @jsx Didact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\n```\n\n在元素前面添加像这样的注释，`babel`就会使用我们定义的方法去转换`JSX`了。（关于`babel`的解析规则这里就不过多深入）\n\n最后，本节实现的`createElement`方法完整代码如下：\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n```\n\n# 第二步：render\n\n```js\n/** @jsx Didact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n接着，让我们关注最后一行代码。是的没错，本节的目标就是实现我们自己的`render`方法以替换`ReactDOM.render`。\n\n对于现在的我们来说，我们只需要关心把元素变成节点添加到`DOM`上去。至于更新和删除，我们一步一步来，后面再考虑这些。\n\n下面的代码就先搭好了架子，接着就只需要在`render`方法内部去实现具体的功能就好了。\n\n```js\nfunction render(element, container) {\n  // TODO create dom nodes\n}\n\nconst Didact = {\n  createElement,\n  render,\n}\n\nDidact.render(element, container)\n```\n\n首先，我们先根据元素的类型`type`来创建相应的`DOM`节点，然后将这个节点添加到容器节点`container`中。\n\n```js\nfunction render(element, container) {\n  const dom = document.createElement(element.type)\n\n  container.appendChild(dom)\n}\n```\n\n当然，不要忘了子元素`children`，这里采用递归的方法来处理。\n\n```js\nfunction render(element, container) {\n  const dom = document.createElement(element.type)\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n等等，还有文本元素呢，如果元素的类型`type`是`TEXT_ELEMENT`，我们要为其创建文本节点。\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n最后，节点有了，就该为其添加属性`props`了。记得需要排除`props`中的`children`。\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\nBingo! That’s it! 我们做到了，现在我们的库`Didact` 也可以将`JSX`元素渲染成真正的`DOM`节点了。\n\n本节实现的`render`代码如下：\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n加上之前实现的完整代码如下：\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\" ? child : createTextElement(child)\n      )\n    }\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: []\n    }\n  };\n}\n\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type);\n  const isProperty = key => key !== \"children\";\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name];\n    });\n  element.props.children.forEach(child => render(child, dom));\n  container.appendChild(dom);\n}\n\nconst Didact = {\n  createElement,\n  render\n};\n\n/** @jsx Didact.createElement */\nconst element = (\n  <div style=\"background: salmon\">\n    <h1>Hello World</h1>\n    <h2 style=\"text-align:right\">from Didact</h2>\n  </div>\n);\nconst container = document.getElementById(\"root\");\nDidact.render(element, container);\n```\n\n当然，你也可以在[codesandbox](https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js:0-1113)上看看最终的效果怎么样。\n\n# 第三步：Concurrent Mode\n\n并发，听起来是不是非常地高大上？没错，本节就是要实现它！\n\n不过，在开始之前，我们需要来解决一点问题。\n\n```js\nfunction render(element, container) {\n  \n\t...\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n\t...\n  \n}\n```\n\n注意以上代码，因为采用的是递归，一旦我们开始渲染，在整个元素树渲染的过程是无法停下来的。如果元素树非常复杂的话，就会占用主线程非常多的时间，从而造成阻塞。试着想一下，如果浏览器需要处理优先级更高的事件如用户输入、保持动画流畅运行，这时浏览器就不得不等到`render`方法执行完后再来处理这些事情。\n\n既然递归会造成这么严重的问题，那我们之前为什么要采用递归的方式呢？我猜是因为React之前也是采用不可中断的递归的方式。（误\n\n走远了，让我们回到正题，来将这个过程变得可中断。\n\n首先，我们来将整个任务拆分成一个个小的任务单元`work unit`，然后在每次执行完一个小的任务单元后询问一下浏览器有没有其他需要优先处理的事情。这个反复的过程我们用`requestIdleCallback`这个原生方法来实现，这个函数会在浏览器空闲的时候执行，这样的话像一些关键事件如动画和用户输入就不会被影响延迟。`requestIdleCallback`同时也**提供**了一个类似于截止时间`deadline`的参数，如果传入的方法执行时间超过了这个时间，就会停止执行将主动权交还到浏览器手中。\n\n> 注意`React`不再使用`requestIdleCallback`这个方法，因为他们为了保证兼容性自己实现了一套！不过从方法的概念上是一致的，所以我们就采用`requestIdleCallback`这个方法。\n> \n\n在开始这个循环之前，我们需要先指定第一个任务单元，为此我们创建了`performUnitOfWork`方法，在这个方法中需要去执行这个任务，同时最后返回下一个需要执行的任务单元`nextUnitOfWork`。\n\n```js\nlet nextUnitOfWork = null\n\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n  requestIdleCallback(workLoop)\n}\n\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(nextUnitOfWork) {\n  // TODO\n}\n\n```\n\n# 第四步：Fibers\n\n为了分解任务单元，我们需要一种数据结构：`fiber tree`。\n\n一个`fiber`对应一个元素，同时每个`fiber`也是我们所划分出来的任务单元。\n\n那么`fiber tree`到底是长啥样的呢？\n\n举个🌰，比如我们想要渲染如下一棵元素树。\n\n```js\nDidact.render(\n  <div>\n    <h1>\n      <p />\n      <a />\n    </h1>\n    <h2 />\n  </div>,\n  container\n)\n```\n\n对应的`fiber tree`就长下面这个样子。\n\n![fiber-tree.png](https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/fiber-tree.png)\n\n在`render`方法中，我们先创建`root fiber`并把它作为第一个任务单元，即第一个`nextUnitOfWork`。其余的任务会在`performUnitOfWork`这个方法中去处理。对于每个`fiber`我们需要在`performUnitOfWork`这个方法中做三件事情：\n\n1. 将元素转换为节点并添加到`DOM`上。\n2. 为该元素的子元素`children`创建`fibers`。\n3. 设置下一个任务单元`nextUnitOfWork`。\n\n`fiber tree`的其中一个目标就是为了能够让设置下一个任务单元更加容易，这也是为什么每个fiber都需要有一个指针（逻辑上）指向第一个子元素`child`，一个指针指向兄弟节点`sibling`，一个指针指向父节点`parent`。\n\n当我们执行完一个`fiber`的任务时，如果它的`child`指针指向的元素不为空的话，则该元素将会被指定为`nextUnitOfWork`。以上图中的`fiber tree`为例，当我们执行完标签为`div`的`fiber`的任务时，`nextUnitOfWork`将会是它的`child`指针指向的标签为`h1`的`fiber`。\n\n如果一个`fiber`的`child`指针指向的元素为空，即该`fiber`不存在`child`时，我们将会指定`sibling`对应的`fiber`作为`nextUnitOfWork`。还是以上图的`fiber tree`为例，标签为`p`的`fiber`没有`child`，所以我们将`p`对应的`sibling`，即标签为`a`的`fiber`作为`nextUnitOfWork`。\n\n如果一个`fiber`即没有`child`也没有`sibling`，我们就指定`nextUnitOfWork`为该`fiber`的叔叔`uncle`，即该`fiber`的父节点`parent`的兄弟节点`sibling`。上图`fiber tree`中标签为`a`的`fiber`就没有`child`和`sibling`，于是向上寻找最后找到了它的叔叔，标签为`h2`的`fiber`。\n\n如果该`fiber`没有叔叔呢？我们将会继续沿着`parent`向上寻找，直到找到一个存在sibling的parent或者到达根`root`。如果是后者的话，那就说明我们已经执行完了本次渲染`render`的所有任务。\n\n接着，就让我们把想法转换为代码吧。\n\n在开始之前，我们先将`render`方法中之前的代码移除，并将移除的那部分放到方法`createDom`中去，这将会在之后用到。\n\n原`render`方法：\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n改造过后的`render`方法以及`createDom`方法：\n\n```js\nfunction createDom(fiber) {\n  const dom =\n    fiber.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(fiber.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = fiber.props[name]\n    })\n\n  return dom\n}\n\nfunction render(element, container) {\n  // TODO set next unit of work\n}\n```\n\n现在，让我们专注于实现`render`方法。\n\n首先，在`render`方法中我们先把`fiber tree`的根`root`作为`nextUnitOfWork`。\n\n```js\nfunction render(element, container) {\n  nextUnitOfWork = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n}\n```\n\n接着当浏览器有空的时候就会调用我们的任务循环`workLoop`，我们就会从根`root`开始执行任务。\n\n```js\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n  requestIdleCallback(workLoop)\n}\n\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(fiber) {\n  // TODO add dom node\n  // TODO create new fibers\n  // TODO return next unit of work\n}\n```\n\n在`performUnitOfWork`中，我们要先为传入的`fiber`创建对应的`DOM`节点。并且我们会使用`fiber.dom`属性来定位该`DOM`节点。\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n\n  // TODO create new fibers\n  // TODO return next unit of work\n}\n```\n\n然后对该`fiber`的子元素`children`创建相应的`fiber`。\n\n```js\nfunction performUnitOfWork(fiber) {\n  \n\t...\t\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n  }\n  // TODO return next unit of work\n}\n```\n\n再根据是否是第一个子元素来设置`child`和`sibling`。\n\n```js\nfunction performUnitOfWork(fiber) {\n  \n\t...\n\n  while (index < elements.length) {\n    \n\t\t...\n\n\t\tif (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n  // TODO return next unit of work\n}\n```\n\n最后，我们根据之前提到的`child-sibling-uncle（parent’s sibling）`的顺序来指定一下`nextUnitOfWork`。\n\n```js\nfunction performUnitOfWork(fiber) {\n  \n\t...\n\n  while (index < elements.length) {\n    ...\n  }\n\n\tif (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n完整的`performUnitOfWork`方法如下：\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n# 第五步：Render and Commit Phases\n\n这里我们又遇到了一个问题。\n\n```js\nfunction performUnitOfWork(fiber) {\n\n\t...\n\n\tif (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n\n\t...\n}\n```\n\n每次我们在处理一个元素时都需要将其新建的节点添加到`DOM`上去。但是不要忘了，浏览器能够在我们渲染完整棵`fiber tree`之前中断我们的渲染过程的。出现这种情况时，用户将会看到一个不完整的UI界面，那是我们不想看到的。\n\n所以，我们要将修改`DOM`的这部分代码从`performUnitOfWork`方法中移除。\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n相对地，我们需要保持对`fiber tree`的根`root`的引用。我们将其引用命名为`wipRoot`（work in progress root）。\n\n```js\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n  nextUnitOfWork = wipRoot\n}\n\nlet nextUnitOfWork = null\nlet wipRoot = null\n```\n\n一旦我们处理完了所有任务单元（可以根据`nextUnitOfWork`是否为空来判断），我们再将整棵`fiber tree`提交到`DOM`上。\n\n```js\nfunction commitRoot() {\n  // TODO add nodes to dom\n}\n\nfunction workLoop(deadline) {\n\t\n\t...\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot()\n  }\n\n  ...\n}\n```\n\n在`commitRoot`这个方法中，我们以递归的方式将所有节点添加到`DOM`上。\n\n```js\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  wipRoot = null\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  domParent.appendChild(fiber.dom)\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n# 第六步：****Reconciliation****\n\n目前为止，我们只是实现了添加节点到`DOM`上，删除和更新呢？\n\n这就是本节要实现的目标，为此我们需要将本次渲染的`fiber tree`即`wipRoot`与上一次提交到`DOM`上的`fiber tree`进行比较。\n\n那么，在每次提交阶段完成时，我们就需要保持对本次提交到`DOM`上的`fiber tree`的引用，以方便下次比较，我们将其引用命名为`currentRoot`。同时，我们也为每个`fiber`添加`alternate`属性，指向旧的`fiber`，即在上个提交阶段我们添加到`DOM`上的`fiber`。\n\n```js\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n\n...\n\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  nextUnitOfWork = wipRoot\n}\n\n...\n\nlet currentRoot = null\n\n...\n```\n\n接着，让我们从`performUnitOfWork`方法中抽离创建新的`fiber`那部分代码，原代码如下：\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n将抽离出来的方法放到`reconcileChildren`方法中，改造后的代码如下：\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  reconcileChildren(fiber, elements)\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: wipFiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n\n在`reconcileChildren`这个方法中，我们将对旧的`fiber`与新的元素进行调和`reconclie`。\n\n我们同时迭代旧`fiber`的子元素`wipFiber.alternate`以及`elements`数组中我们想要调和的元素。\n\n如果我们忽略同时迭代链表和数组所需要注意的那些通用代码，只关心其中最重要的部分：`oldFiber`和`element`，`element`是本次调和我们想要渲染到`DOM`上的`fiber`，`oldFiber`是我们上次渲染到`DOM`上的`fiber`。我们需要比较它们的差异。\n\n```js\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n\n    // TODO compare oldFiber to element\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n\n我们采用以下方式来对它们进行比较：\n\n- 如果`oldFiber`和`element`的`type`一样，我们可以保留其`DOM`节点，只更新其中的属性`props`。\n- 如果它们的type不一样：\n    - 对于`element`，我们需要创建新的`DOM`节点。\n    - 对于`oldFiber`，我们需要移除旧的`DOM`节点。\n\n> 在真正的React中，这里会使用`key`来优化调和。比如，它能够探测到数组中元素的位置是否发生变化。\n> \n\n```js\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n\n    const sameType =\n      oldFiber &&\n      element &&\n      element.type == oldFiber.type\n\n    if (sameType) {\n      // TODO update the node\n    }\n    if (element && !sameType) {\n      // TODO add this node\n    }\n    if (oldFiber && !sameType) {\n      // TODO delete the oldFiber's node\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n\n如果`oldFiber`和`element`的`type`一致时，我们创建一个新的`fiber`，其中保持原来的`DOM`不变，属性`props`采用`element.props`。\n\n```js\nif (sameType) {\n  newFiber = {\n    type: oldFiber.type,\n    props: element.props,\n    dom: oldFiber.dom,\n    parent: wipFiber,\n    alternate: oldFiber,\n    effectTag: 'UPDATE',\n  };\n}\n```\n\n同时我们为新的`fiber`新增了`effectTag`属性。这个属性我们将会在后面的提交阶段用到。\n\n对于`type`不一致的情况，我们为`element`创建新的`fiber`，并将`effectTag`设置为`PLACEMENT`。\n\n```js\nif (element && !sameType) {\n\tnewFiber = {\n\t  type: element.type,\n    props: element.props,\n    dom: null,\n    parent: wipFiber,\n    alternate: null,\n    effectTag: \"PLACEMENT\",\n  }\n}\n```\n\n对于`oldFiber`，我们需要删除对应的`node`。因为不会创建新的`fiber`，所以我们在旧的`fiber`上设置`effectTag`为`DELETION`。\n\n```js\nif (oldFiber && !sameType) {\n  oldFiber.effectTag = 'DELETION';\n  deletions.push(oldFiber);\n}\n```\n\n但是在提交阶段的时候，我们操作的`fiber tree`是`wipRoot`，并不需要旧的`fiber`。所以我们需要记住我们需要删除的节点（通过`deletions`数组来存放）。\n\n```js\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  deletions = []\n  nextUnitOfWork = wipRoot\n}\n\n...\n\nlet deletions = null\n\n...\n```\n\n接着，我们在提交阶段更新`DOM`时，只需要操作`deletions`数组中的`fiber`就可以了。\n\n```js\nfunction commitRoot() {\n  deletions.forEach(commitWork)\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n```\n\n现在，就让我们在`commitWork`方法中根据`effectTag`来对`DOM`进行不同的操作。\n\n如果`effectTag`是`PLACEMENT`，就像之前一样，将节点直接添加到`DOM`上即可。\n\n```js\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  domParent.appendChild(fiber.dom)\n\t\n\tif (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  }\n\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n如果`effectTag`是`DELETION`，与`PLACEMENT`相反，我们将节点从`DOM`上移除。\n\n```js\nif (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n```\n\n如果`effectTag`是`UPDATE`，我们需要在已存在的`DOM`上更新改变了的属性`props`。因为更新比较复杂，我们将具体的实现放在`updateDom`这个方法中。\n\n```js\nif (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n\nfunction updateDom(dom, prevProps, nextProps) {\n  // TODO\n}\n```\n\n在方法`updateDom`中，我们需要比较新旧fiber的属性props，删除旧的，添加新的以及变更值发生改变的。\n\n```js\nconst isProperty = key => key !== \"children\"\nconst isNew = (prev, next) => key =>\n  prev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)\nfunction updateDom(dom, prevProps, nextProps) {\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = \"\"\n    })\n\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = nextProps[name]\n    })\n}\n```\n\n等等，还有一种特殊的属性我们没有处理，那就是监听事件，在`React`中合成事件有一个特点，就是以`on`开头，所以当我们在`props`中识别到监听事件时，我们需要对其特殊处理。\n\n```js\nconst isEvent = key => key.startsWith(\"on\")\nconst isProperty = key =>\n  key !== \"children\" && !isEvent(key)\n```\n\n如果监听事件发生了改变，我们需要将它从节点上移除。\n\n```js\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n\n\t...\n\n}\n```\n\n然后我们新的监听事件添加到对应的节点上去。\n\n```js\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n\n\t...\n\t\n\t// Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.addEventListener(\n        eventType,\n        nextProps[name]\n      )\n    })\n\n}\n```\n\n这样，我们就实现了更新和删除，让我们在[codesandbox](https://codesandbox.io/s/didact-6-96533?file=/src/index.js)上看看加入了调和的`Didact`效果怎么样。\n\n# 第七步：****Function Components****\n\n接下来我们要做的就是让`Didact`支持函数组件。\n\n首先，让我们换个🌰，使用一个简单的函数组件，其返回一个`h1`元素。\n\n```js\n/** @jsx Didact.createElement */\nfunction App(props) {\n  return <h1>Hi {props.name}</h1>\n}\nconst element = <App name=\"foo\" />\nconst container = document.getElementById(\"root\")\nDidact.render(element, container)\n```\n\n如果我们将以上的`JSX`转换为`JS`，将会是下面这个样子：\n\n```js\nfunction App(props) {\n  return Didact.createElement(\n    \"h1\",\n    null,\n    \"Hi \",\n    props.name\n  )\n}\nconst element = Didact.createElement(App, {\n  name: \"foo\",\n})\n```\n\n函数组件在两个方面有所不同：\n\n- 函数组件的`fiber`没有与之对应的`DOM`节点。\n- 子元素`children`来自运行的函数而不是直接从`props`里面获取。\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  reconcileChildren(fiber, elements)\n\t\n\t...\n\n}\n```\n\n这样的话，我们需要对方法`performUnitOfWork`做出修改。\n\n首先，我们检查`fiber`的`type`是否为`function`，并以此为依据来判断是否采用不同的更新方法。\n\n```js\nfunction performUnitOfWork(fiber) {\n  const isFunctionComponent =\n    fiber.type instanceof Function\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber)\n  } else {\n    updateHostComponent(fiber)\n  }\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nfunction updateFunctionComponent(fiber) {\n  // TODO\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n  reconcileChildren(fiber, fiber.props.children)\n}\n```\n\n在`updateHostComponent`方法中使用原来的更新方式，而在`updateFunctionComponent`方法中，我们先执行这个函数去获取它的子元素。\n\n```js\nconst element = Didact.createElement(App, {\n  name: \"foo\",\n})\n```\n\n在我们的🌰中，`fiber.type`指的就是`App`这个函数，当我们运行它时，就能从返回值中获取子元素`h1`。一旦我们获取到了子元素，就可以像之前一样来进行调和，不需要在这个方法中额外做其他事情。\n\n```js\nfunction updateFunctionComponent(fiber) {\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n```\n\n既然现在我们会遇到没有`DOM`节点的`fiber`，我们需要在`commitWork`这个方法中做出两点改变。\n\n第一，沿着`parent`指针找到一个`DOM`节点的父节点，直到我们找到一个带有DOM节点的`fiber`。\n\n```js\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n\n\tlet domParentFiber = fiber.parent\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent\n  }\n  const domParent = domParentFiber.dom  \n\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n第二，当删除一个节点时，我们同样需要沿着`child`指针，找到一个带有`DOM`节点的`fiber`。\n\n```js\nfunction commitWork(fiber) {\n  \n\t...\n\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    commitDeletion(fiber, domParent)\n  }\n\n  ...\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom)\n  } else {\n    commitDeletion(fiber.child, domParent)\n  }\n}\n```\n\n# 第八步：Hooks\n\n最后一步，既然我们已经有了函数组件，让我们也把`state`加进来吧。\n\n```js\nconst Didact = {\n  createElement,\n  render,\n  useState,\n}\n\n/** @jsx Didact.createElement */\nfunction Counter() {\n  const [state, setState] = Didact.useState(1)\n  return (\n    <h1 onClick={() => setState(c => c + 1)}>\n      Count: {state}\n    </h1>\n  )\n}\nconst element = <Counter />\n```\n\n让我们以经典的计数器组件为例，每点击它一次，它的值就增加`1`。\n\n注意这里我们已经替换成了`Didact.useState`来获取并更新计数器的值。\n\n在方法`updateFunctionComponent`中我们会调用`Counter`这个函数组件，并且在这个方法中我们还会调用`useState`方法。\n\n```js\nfunction updateFunctionComponent(fiber) {\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n\nfunction useState(initial) {\n  // TODO\n}\n```\n\n在调用函数组件之前，我们需要先初始化几个全局变量，以便我们在`useState`方法中使用它们。\n\n首先，我们设置`wipFiber`（work in process fiber）。 \n\n同时，为了实现在同一个组件中能够调用`useState`方法多次，我们为`fiber`添加一个`hooks`数组。并且我们记录当前的`hook`索引。\n\n```js\nlet wipFiber = null\nlet hookIndex = null\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber\n  hookIndex = 0\n  wipFiber.hooks = []\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n```\n\n当函数组件调用`useState`方法时，我们先检查其中是否存在旧的`hook`。具体检查的方式是通过`fiber`的`alternate`属性来找到旧的`fiber`，再通过`hookIndex`找到旧`fiber`上对应的`hook`。\n\n如果存在旧的`hook`，我们直接从其中复制`state`到新的`hook`中。如果不存在，我们先初始化`state`。\n\n然后我们将新的`hook`添加到`fiber`的`hooks`数组中去，并让索引`hookIndex`增加`1`。\n\n最后返回`state`。\n\n```js\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state]\n}\n```\n\n`useState`方法也应该返回一个用来更新`state`的方法，所以我们定义了`setState`方法来接受一个动作`action`（比如在计数器组件中这个动作就是增加`1`的方法）。我们为`hook`新增一个队列`queue`，并将`action`放入其中。\n\n然后我们需要做的事情就跟之前我们在`render`方法中所做的类似，指定`nextUnitOfWork`为新的`wipRoot`，这样`workLoop`方法就能够开启一次新的渲染阶段。\n\n```js\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n\n\tconst setState = action => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n```\n\n但我们还没有执行这个动作。\n\n我们将会在下次渲染这个组件的时候再执行这个动作，我们会从旧的`hook`上的`queue`中获取所有的`action`，并且一个一个地执行，这样做之后，我们返回的已经是更新过的`state`。\n\n```js\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach(action => {\n    hook.state = action(hook.state)\n  })\n\n  const setState = action => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n```\n\n就是这样，我们构建了自己的`React`。\n\n在[codesandbox](https://codesandbox.io/s/didact-8-21ost)或[github](https://github.com/pomber/didact)上查看完整代码。\n\n","source":"_posts/build-your-own-react-translate.md","raw":"---\ntitle: '[译] Build your own React'\ndate: 2022-05-15 16:17:23\nupdated:\ntags: \n  - React\ncategories: \n  - [前端, React]\n  - [翻译]\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/build-your-own-react.jpg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# Build your own React\n\n本文翻译自博文 **[Build your own React](https://pomb.us/build-your-own-react/)** ，原作者为 [Rodrigo Pombo](https://pomb.us/)，已获得作者授权。\n\n# 第零步：回顾 JSX to JS\n\n首先我们先通过以下三行代码来回顾一些 `React` 中的基本概念。\n\n```js\nconst element = <h1 title=\"foo\">Hello</h1>\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n第一行代码定义了一个`React`元素。\n\n第二行代码从`DOM`中获取了`id`为`root`的元素。\n\n第三行代码将第一行定义的`React`元素渲染到第二行获取到的元素中去。\n\n以上三行代码就构成了一个非常简单的`React App`，让我们来看看如何通过原生的`JS`来代替以上三行代码。\n\n```js\nconst element = <h1 title=\"foo\">Hello</h1>\n```\n\n先来看看第一行代码，其中的`React`元素就是通过`js`来定义的，它甚至不是合法的`JS`语法，为了用原生的`JS`来替代它，首先我们得让它变得合法。\n\nJSX到JS到转换是通过像[Babel](https://babeljs.io/)这样的工具来实现的，转换过程比较简单：把`js`语法中的标签`tag`、属性`props`、子元素`children`作为参数传入一个叫做`createElement`的函数来处理。\n\n```js\nconst element = React.createElement(\n  \"h1\",\n  { title: \"foo\" },\n  \"Hello\"\n)\n```\n\n`React.createElement`这个方法通过传入的参数创建了一个对象。抛开这个方法会对参数的一些验证以外，这就是它所做的全部事情。以此为基础，我们也可以简单模仿一下`React.createElement`创建的对象。\n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n```\n\n我们所定义的元素是一个具有两个属性（`type`和`props`）的对象（当然真正的`ReactElement`可不止这两个属性，不过在这里我们只关心这两个）。\n\n`type`指的是我们想要创建的`DOM`元素类型的字符串，等同于通过`document.createElement`方法来创建`DOM`元素时传入的`tagName`。`type`也可以是一个函数，但是为了不造成困惑，这个等到第七步时我们再说。 \n\n`props`也是一个对象，它存放的是JSX中设置的特性（`attributes`）的键与值，以及一个特殊的属性（`property`）`children`。\n\n`children`在这里是一个字符串，不过更多时候它会是一个包含许多元素的数组，这也是为什么众多的元素通过错综复杂的关系能够构建成树的原因。\n\n```js\nReactDOM.render(element, container)\n```\n\n另外我们需要来处理的一个方法是`ReactDOM.render`。`render`是`React`来改变`DOM`的方法，这样简单的一句描述有些过于宽泛了，不过我们先可以根据这点来试着捣鼓捣鼓它是怎么改变`DOM`的。\n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n```\n\n首先我们根据我们创建的`element`的属性`type`来创建对应的`DOM`节点，在这里是`h1`。然后我们根据**元素**`element`的属性为创建的**节点**设置属性，在这里是`title`。\n\n> 为了避免困扰，在这里说明一下，文中所说的**元素**指的是`React Element`，**节点**指的是`DOM Element`，以此来区分两者。\n> \n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n```\n\n然后我们来为子元素创建相应的节点。这里的话只有一个子元素，为此我们需要创建一个文本节点。之所以选择创建文本节点（`textNode`）而不是设置`innerText`属性，是因为这样做的话之后我们能够通过同一种方式来处理所有元素。\n\n同时需要注意，我们在为节点设置`nodeValue`属性的这个过程，与设置节点`h1`设置`title`属性类似，就像是在设置一个文本节点的`nodeValue`为`Hello`，即`props: {nodeValue: \"hello\"}`。\n\n```js\nconst container = document.getElementById(\"root\")\n\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n\n最后，我们将创建的文本节点放到节点`h1`上，将节点`h1`放到`id`为`root`的节点上去。\n\n到此为止，我们就完成了用原生的`JS`来替代`JSX`语法这一目标，完整的代码如下：\n\n```js\nconst element = {\n  type: \"h1\",\n  props: {\n    title: \"foo\",\n    children: \"Hello\",\n  },\n}\n\nconst container = document.getElementById(\"root\")\n\nconst node = document.createElement(element.type)\nnode[\"title\"] = element.props.title\n\nconst text = document.createTextNode(\"\")\ntext[\"nodeValue\"] = element.props.children\n\nnode.appendChild(text)\ncontainer.appendChild(node)\n```\n\n# 第一步：createElement\n\n```js\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n让我们从另外一个`React App`开始。这次，我们来尝试创建一个自己的`React`来替代真正的`React`。\n\n从实现`createElement`方法开始吧。\n\n首先，在JSX`转换到`JS`的这个过程中，让我们看看`createElement`这个方法到底都做了些什么吧。\n\n```js\n/** JSX */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\n\n/** JS */\nconst element = React.createElement(\n  \"div\",\n  { id: \"foo\" },\n  React.createElement(\"a\", null, \"bar\"),\n  React.createElement(\"b\")\n}\n```\n\n在前面我们提到过，一个元素（我们简化过的）实际上就是一个带有`type`和`props`这两个属性的对象。我们的方法唯一需要操心的就是如何去创建这个对象。\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children,\n    },\n  }\n}\n```\n\n在以上代码中，我们使用展开操作符`...`来处理`props`，使用剩余参数语法`...`（没错，还是这三个点，都是`ES6`语法）来处理`children`，经过剩余参数语法的处理，`children`就变成了一个数组。\n\n例如，`createElement(\"div\")`返回：\n\n```js\n{\n  type: \"div\",\n  props: { children: [] }\n}\n```\n\n`createElement(\"div\", null, a)`返回：\n\n```js\n{\n  type: \"div\",\n  props: { children: [a] }\n}\n```\n\n`createElement(\"div\", null, a, b)`返回：\n\n```js\n{\n  type: \"div\",\n  props: { children: [a, b] }\n}\n```\n\n需要注意的是，`children`数组中的元素不一定是对象，也有可能是原始类型的值如`number`或`string`。对于这种元素，我们需要封装成一个对象，并为其创建一种特殊的`type`：`TEXT_ELEMENT`。\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n```\n\n> 需要注意真正的`React`并没有封装原始类型的值或在没有`children`时创建一个空数组，我们这样做是为了简化我们的代码，因为我们的目标是易于理解，而不是追求高性能。\n> \n\n```js\nconst element = React.createElement(\n  \"div\",\n  { id: \"foo\" },\n  React.createElement(\"a\", null, \"bar\"),\n  React.createElement(\"b\")\n}\n```\n\n到此为止，我们还没有替换`React.createElement`这个方法\n\n替换`React`的第一步，给我们的库取个名字吧🤨。\n\n名字要听起来像`React`🤔，同时也要有教学（*`didactic`*）的味道🧐。\n\n有了💡，就叫它`Didact`吧。\n\n```js\nconst Didact = {\n  createElement,\n}\n\nconst element = Didact.createElement(\n  \"div\",\n  { id: \"foo\" },\n  Didact.createElement(\"a\", null, \"bar\"),\n  Didact.createElement(\"b\")\n}\n```\n\n但是我们仍然需要使用`JSX`语法，怎样才能让`babel`知道我们用的是`Didact`中的`createElement`方法而不是`React`的呢？\n\n```js\n/** @jsx Didact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\n```\n\n在元素前面添加像这样的注释，`babel`就会使用我们定义的方法去转换`JSX`了。（关于`babel`的解析规则这里就不过多深入）\n\n最后，本节实现的`createElement`方法完整代码如下：\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n    },\n  }\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  }\n}\n```\n\n# 第二步：render\n\n```js\n/** @jsx Didact.createElement */\nconst element = (\n  <div id=\"foo\">\n    <a>bar</a>\n    <b />\n  </div>\n)\nconst container = document.getElementById(\"root\")\nReactDOM.render(element, container)\n```\n\n接着，让我们关注最后一行代码。是的没错，本节的目标就是实现我们自己的`render`方法以替换`ReactDOM.render`。\n\n对于现在的我们来说，我们只需要关心把元素变成节点添加到`DOM`上去。至于更新和删除，我们一步一步来，后面再考虑这些。\n\n下面的代码就先搭好了架子，接着就只需要在`render`方法内部去实现具体的功能就好了。\n\n```js\nfunction render(element, container) {\n  // TODO create dom nodes\n}\n\nconst Didact = {\n  createElement,\n  render,\n}\n\nDidact.render(element, container)\n```\n\n首先，我们先根据元素的类型`type`来创建相应的`DOM`节点，然后将这个节点添加到容器节点`container`中。\n\n```js\nfunction render(element, container) {\n  const dom = document.createElement(element.type)\n\n  container.appendChild(dom)\n}\n```\n\n当然，不要忘了子元素`children`，这里采用递归的方法来处理。\n\n```js\nfunction render(element, container) {\n  const dom = document.createElement(element.type)\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n等等，还有文本元素呢，如果元素的类型`type`是`TEXT_ELEMENT`，我们要为其创建文本节点。\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n最后，节点有了，就该为其添加属性`props`了。记得需要排除`props`中的`children`。\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\nBingo! That’s it! 我们做到了，现在我们的库`Didact` 也可以将`JSX`元素渲染成真正的`DOM`节点了。\n\n本节实现的`render`代码如下：\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n加上之前实现的完整代码如下：\n\n```js\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map(child =>\n        typeof child === \"object\" ? child : createTextElement(child)\n      )\n    }\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: text,\n      children: []\n    }\n  };\n}\n\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type);\n  const isProperty = key => key !== \"children\";\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name];\n    });\n  element.props.children.forEach(child => render(child, dom));\n  container.appendChild(dom);\n}\n\nconst Didact = {\n  createElement,\n  render\n};\n\n/** @jsx Didact.createElement */\nconst element = (\n  <div style=\"background: salmon\">\n    <h1>Hello World</h1>\n    <h2 style=\"text-align:right\">from Didact</h2>\n  </div>\n);\nconst container = document.getElementById(\"root\");\nDidact.render(element, container);\n```\n\n当然，你也可以在[codesandbox](https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js:0-1113)上看看最终的效果怎么样。\n\n# 第三步：Concurrent Mode\n\n并发，听起来是不是非常地高大上？没错，本节就是要实现它！\n\n不过，在开始之前，我们需要来解决一点问题。\n\n```js\nfunction render(element, container) {\n  \n\t...\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n\t...\n  \n}\n```\n\n注意以上代码，因为采用的是递归，一旦我们开始渲染，在整个元素树渲染的过程是无法停下来的。如果元素树非常复杂的话，就会占用主线程非常多的时间，从而造成阻塞。试着想一下，如果浏览器需要处理优先级更高的事件如用户输入、保持动画流畅运行，这时浏览器就不得不等到`render`方法执行完后再来处理这些事情。\n\n既然递归会造成这么严重的问题，那我们之前为什么要采用递归的方式呢？我猜是因为React之前也是采用不可中断的递归的方式。（误\n\n走远了，让我们回到正题，来将这个过程变得可中断。\n\n首先，我们来将整个任务拆分成一个个小的任务单元`work unit`，然后在每次执行完一个小的任务单元后询问一下浏览器有没有其他需要优先处理的事情。这个反复的过程我们用`requestIdleCallback`这个原生方法来实现，这个函数会在浏览器空闲的时候执行，这样的话像一些关键事件如动画和用户输入就不会被影响延迟。`requestIdleCallback`同时也**提供**了一个类似于截止时间`deadline`的参数，如果传入的方法执行时间超过了这个时间，就会停止执行将主动权交还到浏览器手中。\n\n> 注意`React`不再使用`requestIdleCallback`这个方法，因为他们为了保证兼容性自己实现了一套！不过从方法的概念上是一致的，所以我们就采用`requestIdleCallback`这个方法。\n> \n\n在开始这个循环之前，我们需要先指定第一个任务单元，为此我们创建了`performUnitOfWork`方法，在这个方法中需要去执行这个任务，同时最后返回下一个需要执行的任务单元`nextUnitOfWork`。\n\n```js\nlet nextUnitOfWork = null\n\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n  requestIdleCallback(workLoop)\n}\n\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(nextUnitOfWork) {\n  // TODO\n}\n\n```\n\n# 第四步：Fibers\n\n为了分解任务单元，我们需要一种数据结构：`fiber tree`。\n\n一个`fiber`对应一个元素，同时每个`fiber`也是我们所划分出来的任务单元。\n\n那么`fiber tree`到底是长啥样的呢？\n\n举个🌰，比如我们想要渲染如下一棵元素树。\n\n```js\nDidact.render(\n  <div>\n    <h1>\n      <p />\n      <a />\n    </h1>\n    <h2 />\n  </div>,\n  container\n)\n```\n\n对应的`fiber tree`就长下面这个样子。\n\n![fiber-tree.png](https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/fiber-tree.png)\n\n在`render`方法中，我们先创建`root fiber`并把它作为第一个任务单元，即第一个`nextUnitOfWork`。其余的任务会在`performUnitOfWork`这个方法中去处理。对于每个`fiber`我们需要在`performUnitOfWork`这个方法中做三件事情：\n\n1. 将元素转换为节点并添加到`DOM`上。\n2. 为该元素的子元素`children`创建`fibers`。\n3. 设置下一个任务单元`nextUnitOfWork`。\n\n`fiber tree`的其中一个目标就是为了能够让设置下一个任务单元更加容易，这也是为什么每个fiber都需要有一个指针（逻辑上）指向第一个子元素`child`，一个指针指向兄弟节点`sibling`，一个指针指向父节点`parent`。\n\n当我们执行完一个`fiber`的任务时，如果它的`child`指针指向的元素不为空的话，则该元素将会被指定为`nextUnitOfWork`。以上图中的`fiber tree`为例，当我们执行完标签为`div`的`fiber`的任务时，`nextUnitOfWork`将会是它的`child`指针指向的标签为`h1`的`fiber`。\n\n如果一个`fiber`的`child`指针指向的元素为空，即该`fiber`不存在`child`时，我们将会指定`sibling`对应的`fiber`作为`nextUnitOfWork`。还是以上图的`fiber tree`为例，标签为`p`的`fiber`没有`child`，所以我们将`p`对应的`sibling`，即标签为`a`的`fiber`作为`nextUnitOfWork`。\n\n如果一个`fiber`即没有`child`也没有`sibling`，我们就指定`nextUnitOfWork`为该`fiber`的叔叔`uncle`，即该`fiber`的父节点`parent`的兄弟节点`sibling`。上图`fiber tree`中标签为`a`的`fiber`就没有`child`和`sibling`，于是向上寻找最后找到了它的叔叔，标签为`h2`的`fiber`。\n\n如果该`fiber`没有叔叔呢？我们将会继续沿着`parent`向上寻找，直到找到一个存在sibling的parent或者到达根`root`。如果是后者的话，那就说明我们已经执行完了本次渲染`render`的所有任务。\n\n接着，就让我们把想法转换为代码吧。\n\n在开始之前，我们先将`render`方法中之前的代码移除，并将移除的那部分放到方法`createDom`中去，这将会在之后用到。\n\n原`render`方法：\n\n```js\nfunction render(element, container) {\n  const dom =\n    element.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(element.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(element.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = element.props[name]\n    })\n\n  element.props.children.forEach(child =>\n    render(child, dom)\n  )\n\n  container.appendChild(dom)\n}\n```\n\n改造过后的`render`方法以及`createDom`方法：\n\n```js\nfunction createDom(fiber) {\n  const dom =\n    fiber.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type)\n\n  const isProperty = key => key !== \"children\"\n  Object.keys(fiber.props)\n    .filter(isProperty)\n    .forEach(name => {\n      dom[name] = fiber.props[name]\n    })\n\n  return dom\n}\n\nfunction render(element, container) {\n  // TODO set next unit of work\n}\n```\n\n现在，让我们专注于实现`render`方法。\n\n首先，在`render`方法中我们先把`fiber tree`的根`root`作为`nextUnitOfWork`。\n\n```js\nfunction render(element, container) {\n  nextUnitOfWork = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n}\n```\n\n接着当浏览器有空的时候就会调用我们的任务循环`workLoop`，我们就会从根`root`开始执行任务。\n\n```js\nfunction workLoop(deadline) {\n  let shouldYield = false\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(\n      nextUnitOfWork\n    )\n    shouldYield = deadline.timeRemaining() < 1\n  }\n  requestIdleCallback(workLoop)\n}\n\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(fiber) {\n  // TODO add dom node\n  // TODO create new fibers\n  // TODO return next unit of work\n}\n```\n\n在`performUnitOfWork`中，我们要先为传入的`fiber`创建对应的`DOM`节点。并且我们会使用`fiber.dom`属性来定位该`DOM`节点。\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n\n  // TODO create new fibers\n  // TODO return next unit of work\n}\n```\n\n然后对该`fiber`的子元素`children`创建相应的`fiber`。\n\n```js\nfunction performUnitOfWork(fiber) {\n  \n\t...\t\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n  }\n  // TODO return next unit of work\n}\n```\n\n再根据是否是第一个子元素来设置`child`和`sibling`。\n\n```js\nfunction performUnitOfWork(fiber) {\n  \n\t...\n\n  while (index < elements.length) {\n    \n\t\t...\n\n\t\tif (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n  // TODO return next unit of work\n}\n```\n\n最后，我们根据之前提到的`child-sibling-uncle（parent’s sibling）`的顺序来指定一下`nextUnitOfWork`。\n\n```js\nfunction performUnitOfWork(fiber) {\n  \n\t...\n\n  while (index < elements.length) {\n    ...\n  }\n\n\tif (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n完整的`performUnitOfWork`方法如下：\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  if (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n# 第五步：Render and Commit Phases\n\n这里我们又遇到了一个问题。\n\n```js\nfunction performUnitOfWork(fiber) {\n\n\t...\n\n\tif (fiber.parent) {\n    fiber.parent.dom.appendChild(fiber.dom)\n  }\n\n\t...\n}\n```\n\n每次我们在处理一个元素时都需要将其新建的节点添加到`DOM`上去。但是不要忘了，浏览器能够在我们渲染完整棵`fiber tree`之前中断我们的渲染过程的。出现这种情况时，用户将会看到一个不完整的UI界面，那是我们不想看到的。\n\n所以，我们要将修改`DOM`的这部分代码从`performUnitOfWork`方法中移除。\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n相对地，我们需要保持对`fiber tree`的根`root`的引用。我们将其引用命名为`wipRoot`（work in progress root）。\n\n```js\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n  }\n  nextUnitOfWork = wipRoot\n}\n\nlet nextUnitOfWork = null\nlet wipRoot = null\n```\n\n一旦我们处理完了所有任务单元（可以根据`nextUnitOfWork`是否为空来判断），我们再将整棵`fiber tree`提交到`DOM`上。\n\n```js\nfunction commitRoot() {\n  // TODO add nodes to dom\n}\n\nfunction workLoop(deadline) {\n\t\n\t...\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot()\n  }\n\n  ...\n}\n```\n\n在`commitRoot`这个方法中，我们以递归的方式将所有节点添加到`DOM`上。\n\n```js\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  wipRoot = null\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  domParent.appendChild(fiber.dom)\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n# 第六步：****Reconciliation****\n\n目前为止，我们只是实现了添加节点到`DOM`上，删除和更新呢？\n\n这就是本节要实现的目标，为此我们需要将本次渲染的`fiber tree`即`wipRoot`与上一次提交到`DOM`上的`fiber tree`进行比较。\n\n那么，在每次提交阶段完成时，我们就需要保持对本次提交到`DOM`上的`fiber tree`的引用，以方便下次比较，我们将其引用命名为`currentRoot`。同时，我们也为每个`fiber`添加`alternate`属性，指向旧的`fiber`，即在上个提交阶段我们添加到`DOM`上的`fiber`。\n\n```js\nfunction commitRoot() {\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n\n...\n\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  nextUnitOfWork = wipRoot\n}\n\n...\n\nlet currentRoot = null\n\n...\n```\n\n接着，让我们从`performUnitOfWork`方法中抽离创建新的`fiber`那部分代码，原代码如下：\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: fiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      fiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n```\n\n将抽离出来的方法放到`reconcileChildren`方法中，改造后的代码如下：\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  reconcileChildren(fiber, elements)\n\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let prevSibling = null\n\n  while (index < elements.length) {\n    const element = elements[index]\n\n    const newFiber = {\n      type: element.type,\n      props: element.props,\n      parent: wipFiber,\n      dom: null,\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n\n在`reconcileChildren`这个方法中，我们将对旧的`fiber`与新的元素进行调和`reconclie`。\n\n我们同时迭代旧`fiber`的子元素`wipFiber.alternate`以及`elements`数组中我们想要调和的元素。\n\n如果我们忽略同时迭代链表和数组所需要注意的那些通用代码，只关心其中最重要的部分：`oldFiber`和`element`，`element`是本次调和我们想要渲染到`DOM`上的`fiber`，`oldFiber`是我们上次渲染到`DOM`上的`fiber`。我们需要比较它们的差异。\n\n```js\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n\n    // TODO compare oldFiber to element\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n\n我们采用以下方式来对它们进行比较：\n\n- 如果`oldFiber`和`element`的`type`一样，我们可以保留其`DOM`节点，只更新其中的属性`props`。\n- 如果它们的type不一样：\n    - 对于`element`，我们需要创建新的`DOM`节点。\n    - 对于`oldFiber`，我们需要移除旧的`DOM`节点。\n\n> 在真正的React中，这里会使用`key`来优化调和。比如，它能够探测到数组中元素的位置是否发生变化。\n> \n\n```js\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0\n  let oldFiber =\n    wipFiber.alternate && wipFiber.alternate.child\n  let prevSibling = null\n\n  while (\n    index < elements.length ||\n    oldFiber != null\n  ) {\n    const element = elements[index]\n    let newFiber = null\n\n    const sameType =\n      oldFiber &&\n      element &&\n      element.type == oldFiber.type\n\n    if (sameType) {\n      // TODO update the node\n    }\n    if (element && !sameType) {\n      // TODO add this node\n    }\n    if (oldFiber && !sameType) {\n      // TODO delete the oldFiber's node\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber\n    } else {\n      prevSibling.sibling = newFiber\n    }\n\n    prevSibling = newFiber\n    index++\n  }\n}\n```\n\n如果`oldFiber`和`element`的`type`一致时，我们创建一个新的`fiber`，其中保持原来的`DOM`不变，属性`props`采用`element.props`。\n\n```js\nif (sameType) {\n  newFiber = {\n    type: oldFiber.type,\n    props: element.props,\n    dom: oldFiber.dom,\n    parent: wipFiber,\n    alternate: oldFiber,\n    effectTag: 'UPDATE',\n  };\n}\n```\n\n同时我们为新的`fiber`新增了`effectTag`属性。这个属性我们将会在后面的提交阶段用到。\n\n对于`type`不一致的情况，我们为`element`创建新的`fiber`，并将`effectTag`设置为`PLACEMENT`。\n\n```js\nif (element && !sameType) {\n\tnewFiber = {\n\t  type: element.type,\n    props: element.props,\n    dom: null,\n    parent: wipFiber,\n    alternate: null,\n    effectTag: \"PLACEMENT\",\n  }\n}\n```\n\n对于`oldFiber`，我们需要删除对应的`node`。因为不会创建新的`fiber`，所以我们在旧的`fiber`上设置`effectTag`为`DELETION`。\n\n```js\nif (oldFiber && !sameType) {\n  oldFiber.effectTag = 'DELETION';\n  deletions.push(oldFiber);\n}\n```\n\n但是在提交阶段的时候，我们操作的`fiber tree`是`wipRoot`，并不需要旧的`fiber`。所以我们需要记住我们需要删除的节点（通过`deletions`数组来存放）。\n\n```js\nfunction render(element, container) {\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  }\n  deletions = []\n  nextUnitOfWork = wipRoot\n}\n\n...\n\nlet deletions = null\n\n...\n```\n\n接着，我们在提交阶段更新`DOM`时，只需要操作`deletions`数组中的`fiber`就可以了。\n\n```js\nfunction commitRoot() {\n  deletions.forEach(commitWork)\n  commitWork(wipRoot.child)\n  currentRoot = wipRoot\n  wipRoot = null\n}\n```\n\n现在，就让我们在`commitWork`方法中根据`effectTag`来对`DOM`进行不同的操作。\n\n如果`effectTag`是`PLACEMENT`，就像之前一样，将节点直接添加到`DOM`上即可。\n\n```js\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n  const domParent = fiber.parent.dom\n  domParent.appendChild(fiber.dom)\n\t\n\tif (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  }\n\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n如果`effectTag`是`DELETION`，与`PLACEMENT`相反，我们将节点从`DOM`上移除。\n\n```js\nif (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n```\n\n如果`effectTag`是`UPDATE`，我们需要在已存在的`DOM`上更新改变了的属性`props`。因为更新比较复杂，我们将具体的实现放在`updateDom`这个方法中。\n\n```js\nif (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n\nfunction updateDom(dom, prevProps, nextProps) {\n  // TODO\n}\n```\n\n在方法`updateDom`中，我们需要比较新旧fiber的属性props，删除旧的，添加新的以及变更值发生改变的。\n\n```js\nconst isProperty = key => key !== \"children\"\nconst isNew = (prev, next) => key =>\n  prev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)\nfunction updateDom(dom, prevProps, nextProps) {\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = \"\"\n    })\n\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = nextProps[name]\n    })\n}\n```\n\n等等，还有一种特殊的属性我们没有处理，那就是监听事件，在`React`中合成事件有一个特点，就是以`on`开头，所以当我们在`props`中识别到监听事件时，我们需要对其特殊处理。\n\n```js\nconst isEvent = key => key.startsWith(\"on\")\nconst isProperty = key =>\n  key !== \"children\" && !isEvent(key)\n```\n\n如果监听事件发生了改变，我们需要将它从节点上移除。\n\n```js\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n\n\t...\n\n}\n```\n\n然后我们新的监听事件添加到对应的节点上去。\n\n```js\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n\n\t...\n\t\n\t// Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.addEventListener(\n        eventType,\n        nextProps[name]\n      )\n    })\n\n}\n```\n\n这样，我们就实现了更新和删除，让我们在[codesandbox](https://codesandbox.io/s/didact-6-96533?file=/src/index.js)上看看加入了调和的`Didact`效果怎么样。\n\n# 第七步：****Function Components****\n\n接下来我们要做的就是让`Didact`支持函数组件。\n\n首先，让我们换个🌰，使用一个简单的函数组件，其返回一个`h1`元素。\n\n```js\n/** @jsx Didact.createElement */\nfunction App(props) {\n  return <h1>Hi {props.name}</h1>\n}\nconst element = <App name=\"foo\" />\nconst container = document.getElementById(\"root\")\nDidact.render(element, container)\n```\n\n如果我们将以上的`JSX`转换为`JS`，将会是下面这个样子：\n\n```js\nfunction App(props) {\n  return Didact.createElement(\n    \"h1\",\n    null,\n    \"Hi \",\n    props.name\n  )\n}\nconst element = Didact.createElement(App, {\n  name: \"foo\",\n})\n```\n\n函数组件在两个方面有所不同：\n\n- 函数组件的`fiber`没有与之对应的`DOM`节点。\n- 子元素`children`来自运行的函数而不是直接从`props`里面获取。\n\n```js\nfunction performUnitOfWork(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n\n  const elements = fiber.props.children\n  reconcileChildren(fiber, elements)\n\t\n\t...\n\n}\n```\n\n这样的话，我们需要对方法`performUnitOfWork`做出修改。\n\n首先，我们检查`fiber`的`type`是否为`function`，并以此为依据来判断是否采用不同的更新方法。\n\n```js\nfunction performUnitOfWork(fiber) {\n  const isFunctionComponent =\n    fiber.type instanceof Function\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber)\n  } else {\n    updateHostComponent(fiber)\n  }\n  if (fiber.child) {\n    return fiber.child\n  }\n  let nextFiber = fiber\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling\n    }\n    nextFiber = nextFiber.parent\n  }\n}\n\nfunction updateFunctionComponent(fiber) {\n  // TODO\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber)\n  }\n  reconcileChildren(fiber, fiber.props.children)\n}\n```\n\n在`updateHostComponent`方法中使用原来的更新方式，而在`updateFunctionComponent`方法中，我们先执行这个函数去获取它的子元素。\n\n```js\nconst element = Didact.createElement(App, {\n  name: \"foo\",\n})\n```\n\n在我们的🌰中，`fiber.type`指的就是`App`这个函数，当我们运行它时，就能从返回值中获取子元素`h1`。一旦我们获取到了子元素，就可以像之前一样来进行调和，不需要在这个方法中额外做其他事情。\n\n```js\nfunction updateFunctionComponent(fiber) {\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n```\n\n既然现在我们会遇到没有`DOM`节点的`fiber`，我们需要在`commitWork`这个方法中做出两点改变。\n\n第一，沿着`parent`指针找到一个`DOM`节点的父节点，直到我们找到一个带有DOM节点的`fiber`。\n\n```js\nfunction commitWork(fiber) {\n  if (!fiber) {\n    return\n  }\n\n\tlet domParentFiber = fiber.parent\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent\n  }\n  const domParent = domParentFiber.dom  \n\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    domParent.removeChild(fiber.dom)\n  }\n\n  commitWork(fiber.child)\n  commitWork(fiber.sibling)\n}\n```\n\n第二，当删除一个节点时，我们同样需要沿着`child`指针，找到一个带有`DOM`节点的`fiber`。\n\n```js\nfunction commitWork(fiber) {\n  \n\t...\n\n  if (\n    fiber.effectTag === \"PLACEMENT\" &&\n    fiber.dom != null\n  ) {\n    domParent.appendChild(fiber.dom)\n  } else if (\n    fiber.effectTag === \"UPDATE\" &&\n    fiber.dom != null\n  ) {\n    updateDom(\n      fiber.dom,\n      fiber.alternate.props,\n      fiber.props\n    )\n  } else if (fiber.effectTag === \"DELETION\") {\n    commitDeletion(fiber, domParent)\n  }\n\n  ...\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom)\n  } else {\n    commitDeletion(fiber.child, domParent)\n  }\n}\n```\n\n# 第八步：Hooks\n\n最后一步，既然我们已经有了函数组件，让我们也把`state`加进来吧。\n\n```js\nconst Didact = {\n  createElement,\n  render,\n  useState,\n}\n\n/** @jsx Didact.createElement */\nfunction Counter() {\n  const [state, setState] = Didact.useState(1)\n  return (\n    <h1 onClick={() => setState(c => c + 1)}>\n      Count: {state}\n    </h1>\n  )\n}\nconst element = <Counter />\n```\n\n让我们以经典的计数器组件为例，每点击它一次，它的值就增加`1`。\n\n注意这里我们已经替换成了`Didact.useState`来获取并更新计数器的值。\n\n在方法`updateFunctionComponent`中我们会调用`Counter`这个函数组件，并且在这个方法中我们还会调用`useState`方法。\n\n```js\nfunction updateFunctionComponent(fiber) {\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n\nfunction useState(initial) {\n  // TODO\n}\n```\n\n在调用函数组件之前，我们需要先初始化几个全局变量，以便我们在`useState`方法中使用它们。\n\n首先，我们设置`wipFiber`（work in process fiber）。 \n\n同时，为了实现在同一个组件中能够调用`useState`方法多次，我们为`fiber`添加一个`hooks`数组。并且我们记录当前的`hook`索引。\n\n```js\nlet wipFiber = null\nlet hookIndex = null\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber\n  hookIndex = 0\n  wipFiber.hooks = []\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n```\n\n当函数组件调用`useState`方法时，我们先检查其中是否存在旧的`hook`。具体检查的方式是通过`fiber`的`alternate`属性来找到旧的`fiber`，再通过`hookIndex`找到旧`fiber`上对应的`hook`。\n\n如果存在旧的`hook`，我们直接从其中复制`state`到新的`hook`中。如果不存在，我们先初始化`state`。\n\n然后我们将新的`hook`添加到`fiber`的`hooks`数组中去，并让索引`hookIndex`增加`1`。\n\n最后返回`state`。\n\n```js\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state]\n}\n```\n\n`useState`方法也应该返回一个用来更新`state`的方法，所以我们定义了`setState`方法来接受一个动作`action`（比如在计数器组件中这个动作就是增加`1`的方法）。我们为`hook`新增一个队列`queue`，并将`action`放入其中。\n\n然后我们需要做的事情就跟之前我们在`render`方法中所做的类似，指定`nextUnitOfWork`为新的`wipRoot`，这样`workLoop`方法就能够开启一次新的渲染阶段。\n\n```js\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n\n\tconst setState = action => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n```\n\n但我们还没有执行这个动作。\n\n我们将会在下次渲染这个组件的时候再执行这个动作，我们会从旧的`hook`上的`queue`中获取所有的`action`，并且一个一个地执行，这样做之后，我们返回的已经是更新过的`state`。\n\n```js\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex]\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: [],\n  }\n\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach(action => {\n    hook.state = action(hook.state)\n  })\n\n  const setState = action => {\n    hook.queue.push(action)\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot,\n    }\n    nextUnitOfWork = wipRoot\n    deletions = []\n  }\n\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n```\n\n就是这样，我们构建了自己的`React`。\n\n在[codesandbox](https://codesandbox.io/s/didact-8-21ost)或[github](https://github.com/pomber/didact)上查看完整代码。\n\n","slug":"build-your-own-react-translate","published":1,"layout":"post","photos":[],"link":"","_id":"cl3re6un60003vuo92ed1cs5u","content":"<h1 id=\"Build-your-own-React\"><a href=\"#Build-your-own-React\" class=\"headerlink\" title=\"Build your own React\"></a>Build your own React</h1><p>本文翻译自博文 <strong><a href=\"https://pomb.us/build-your-own-react/\">Build your own React</a></strong> ，原作者为 <a href=\"https://pomb.us/\">Rodrigo Pombo</a>，已获得作者授权。</p>\n<h1 id=\"第零步：回顾-JSX-to-JS\"><a href=\"#第零步：回顾-JSX-to-JS\" class=\"headerlink\" title=\"第零步：回顾 JSX to JS\"></a>第零步：回顾 JSX to JS</h1><p>首先我们先通过以下三行代码来回顾一些 <code>React</code> 中的基本概念。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>第一行代码定义了一个<code>React</code>元素。</p>\n<p>第二行代码从<code>DOM</code>中获取了<code>id</code>为<code>root</code>的元素。</p>\n<p>第三行代码将第一行定义的<code>React</code>元素渲染到第二行获取到的元素中去。</p>\n<p>以上三行代码就构成了一个非常简单的<code>React App</code>，让我们来看看如何通过原生的<code>JS</code>来代替以上三行代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>先来看看第一行代码，其中的<code>React</code>元素就是通过<code>js</code>来定义的，它甚至不是合法的<code>JS</code>语法，为了用原生的<code>JS</code>来替代它，首先我们得让它变得合法。</p>\n<p>JSX到JS到转换是通过像<a href=\"https://babeljs.io/\">Babel</a>这样的工具来实现的，转换过程比较简单：把<code>js</code>语法中的标签<code>tag</code>、属性<code>props</code>、子元素<code>children</code>作为参数传入一个叫做<code>createElement</code>的函数来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><code>React.createElement</code>这个方法通过传入的参数创建了一个对象。抛开这个方法会对参数的一些验证以外，这就是它所做的全部事情。以此为基础，我们也可以简单模仿一下<code>React.createElement</code>创建的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们所定义的元素是一个具有两个属性（<code>type</code>和<code>props</code>）的对象（当然真正的<code>ReactElement</code>可不止这两个属性，不过在这里我们只关心这两个）。</p>\n<p><code>type</code>指的是我们想要创建的<code>DOM</code>元素类型的字符串，等同于通过<code>document.createElement</code>方法来创建<code>DOM</code>元素时传入的<code>tagName</code>。<code>type</code>也可以是一个函数，但是为了不造成困惑，这个等到第七步时我们再说。 </p>\n<p><code>props</code>也是一个对象，它存放的是JSX中设置的特性（<code>attributes</code>）的键与值，以及一个特殊的属性（<code>property</code>）<code>children</code>。</p>\n<p><code>children</code>在这里是一个字符串，不过更多时候它会是一个包含许多元素的数组，这也是为什么众多的元素通过错综复杂的关系能够构建成树的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>另外我们需要来处理的一个方法是<code>ReactDOM.render</code>。<code>render</code>是<code>React</code>来改变<code>DOM</code>的方法，这样简单的一句描述有些过于宽泛了，不过我们先可以根据这点来试着捣鼓捣鼓它是怎么改变<code>DOM</code>的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\">node[<span class=\"string\">&quot;title&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">title</span></span><br></pre></td></tr></table></figure>\n\n<p>首先我们根据我们创建的<code>element</code>的属性<code>type</code>来创建对应的<code>DOM</code>节点，在这里是<code>h1</code>。然后我们根据<strong>元素</strong><code>element</code>的属性为创建的<strong>节点</strong>设置属性，在这里是<code>title</code>。</p>\n<blockquote>\n<p>为了避免困扰，在这里说明一下，文中所说的<strong>元素</strong>指的是<code>React Element</code>，<strong>节点</strong>指的是<code>DOM Element</code>，以此来区分两者。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">text[<span class=\"string\">&quot;nodeValue&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们来为子元素创建相应的节点。这里的话只有一个子元素，为此我们需要创建一个文本节点。之所以选择创建文本节点（<code>textNode</code>）而不是设置<code>innerText</code>属性，是因为这样做的话之后我们能够通过同一种方式来处理所有元素。</p>\n<p>同时需要注意，我们在为节点设置<code>nodeValue</code>属性的这个过程，与设置节点<code>h1</code>设置<code>title</code>属性类似，就像是在设置一个文本节点的<code>nodeValue</code>为<code>Hello</code>，即<code>props: &#123;nodeValue: &quot;hello&quot;&#125;</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">node.<span class=\"title function_\">appendChild</span>(text)</span><br><span class=\"line\">container.<span class=\"title function_\">appendChild</span>(node)</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们将创建的文本节点放到节点<code>h1</code>上，将节点<code>h1</code>放到<code>id</code>为<code>root</code>的节点上去。</p>\n<p>到此为止，我们就完成了用原生的<code>JS</code>来替代<code>JSX</code>语法这一目标，完整的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\">node[<span class=\"string\">&quot;title&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">title</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">text[<span class=\"string\">&quot;nodeValue&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\"></span><br><span class=\"line\">node.<span class=\"title function_\">appendChild</span>(text)</span><br><span class=\"line\">container.<span class=\"title function_\">appendChild</span>(node)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第一步：createElement\"><a href=\"#第一步：createElement\" class=\"headerlink\" title=\"第一步：createElement\"></a>第一步：createElement</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>让我们从另外一个<code>React App</code>开始。这次，我们来尝试创建一个自己的<code>React</code>来替代真正的<code>React</code>。</p>\n<p>从实现<code>createElement</code>方法开始吧。</p>\n<p>首先，在JSX<code>转换到</code>JS<code>的这个过程中，让我们看看</code>createElement&#96;这个方法到底都做了些什么吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** JSX */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** JS */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;bar&quot;</span>),</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前面我们提到过，一个元素（我们简化过的）实际上就是一个带有<code>type</code>和<code>props</code>这两个属性的对象。我们的方法唯一需要操心的就是如何去创建这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      children,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，我们使用展开操作符<code>...</code>来处理<code>props</code>，使用剩余参数语法<code>...</code>（没错，还是这三个点，都是<code>ES6</code>语法）来处理<code>children</code>，经过剩余参数语法的处理，<code>children</code>就变成了一个数组。</p>\n<p>例如，<code>createElement(&quot;div&quot;)</code>返回：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; <span class=\"attr\">children</span>: [] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createElement(&quot;div&quot;, null, a)</code>返回：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; <span class=\"attr\">children</span>: [a] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createElement(&quot;div&quot;, null, a, b)</code>返回：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; <span class=\"attr\">children</span>: [a, b] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，<code>children</code>数组中的元素不一定是对象，也有可能是原始类型的值如<code>number</code>或<code>string</code>。对于这种元素，我们需要封装成一个对象，并为其创建一种特殊的<code>type</code>：<code>TEXT_ELEMENT</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: children.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">&quot;object&quot;</span></span><br><span class=\"line\">          ? child</span><br><span class=\"line\">          : <span class=\"title function_\">createTextElement</span>(child)</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createTextElement</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">nodeValue</span>: text,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意真正的<code>React</code>并没有封装原始类型的值或在没有<code>children</code>时创建一个空数组，我们这样做是为了简化我们的代码，因为我们的目标是易于理解，而不是追求高性能。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;bar&quot;</span>),</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，我们还没有替换<code>React.createElement</code>这个方法</p>\n<p>替换<code>React</code>的第一步，给我们的库取个名字吧🤨。</p>\n<p>名字要听起来像<code>React</code>🤔，同时也要有教学（*<code>didactic</code>*）的味道🧐。</p>\n<p>有了💡，就叫它<code>Didact</code>吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;bar&quot;</span>),</span><br><span class=\"line\">  <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是我们仍然需要使用<code>JSX</code>语法，怎样才能让<code>babel</code>知道我们用的是<code>Didact</code>中的<code>createElement</code>方法而不是<code>React</code>的呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>在元素前面添加像这样的注释，<code>babel</code>就会使用我们定义的方法去转换<code>JSX</code>了。（关于<code>babel</code>的解析规则这里就不过多深入）</p>\n<p>最后，本节实现的<code>createElement</code>方法完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: children.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">&quot;object&quot;</span></span><br><span class=\"line\">          ? child</span><br><span class=\"line\">          : <span class=\"title function_\">createTextElement</span>(child)</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createTextElement</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">nodeValue</span>: text,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二步：render\"><a href=\"#第二步：render\" class=\"headerlink\" title=\"第二步：render\"></a>第二步：render</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>接着，让我们关注最后一行代码。是的没错，本节的目标就是实现我们自己的<code>render</code>方法以替换<code>ReactDOM.render</code>。</p>\n<p>对于现在的我们来说，我们只需要关心把元素变成节点添加到<code>DOM</code>上去。至于更新和删除，我们一步一步来，后面再考虑这些。</p>\n<p>下面的代码就先搭好了架子，接着就只需要在<code>render</code>方法内部去实现具体的功能就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO create dom nodes</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  render,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们先根据元素的类型<code>type</code>来创建相应的<code>DOM</code>节点，然后将这个节点添加到容器节点<code>container</code>中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，不要忘了子元素<code>children</code>，这里采用递归的方法来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等，还有文本元素呢，如果元素的类型<code>type</code>是<code>TEXT_ELEMENT</code>，我们要为其创建文本节点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，节点有了，就该为其添加属性<code>props</code>了。记得需要排除<code>props</code>中的<code>children</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Bingo! That’s it! 我们做到了，现在我们的库<code>Didact</code> 也可以将<code>JSX</code>元素渲染成真正的<code>DOM</code>节点了。</p>\n<p>本节实现的<code>render</code>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上之前实现的完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: children.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">&quot;object&quot;</span> ? child : <span class=\"title function_\">createTextElement</span>(child)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createTextElement</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">nodeValue</span>: text,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> <span class=\"title function_\">render</span>(child, dom));</span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  render</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background: salmon&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;text-align:right&quot;</span>&gt;</span>from Didact<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(element, container);</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以在<a href=\"https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js:0-1113\">codesandbox</a>上看看最终的效果怎么样。</p>\n<h1 id=\"第三步：Concurrent-Mode\"><a href=\"#第三步：Concurrent-Mode\" class=\"headerlink\" title=\"第三步：Concurrent Mode\"></a>第三步：Concurrent Mode</h1><p>并发，听起来是不是非常地高大上？没错，本节就是要实现它！</p>\n<p>不过，在开始之前，我们需要来解决一点问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意以上代码，因为采用的是递归，一旦我们开始渲染，在整个元素树渲染的过程是无法停下来的。如果元素树非常复杂的话，就会占用主线程非常多的时间，从而造成阻塞。试着想一下，如果浏览器需要处理优先级更高的事件如用户输入、保持动画流畅运行，这时浏览器就不得不等到<code>render</code>方法执行完后再来处理这些事情。</p>\n<p>既然递归会造成这么严重的问题，那我们之前为什么要采用递归的方式呢？我猜是因为React之前也是采用不可中断的递归的方式。（误</p>\n<p>走远了，让我们回到正题，来将这个过程变得可中断。</p>\n<p>首先，我们来将整个任务拆分成一个个小的任务单元<code>work unit</code>，然后在每次执行完一个小的任务单元后询问一下浏览器有没有其他需要优先处理的事情。这个反复的过程我们用<code>requestIdleCallback</code>这个原生方法来实现，这个函数会在浏览器空闲的时候执行，这样的话像一些关键事件如动画和用户输入就不会被影响延迟。<code>requestIdleCallback</code>同时也<strong>提供</strong>了一个类似于截止时间<code>deadline</code>的参数，如果传入的方法执行时间超过了这个时间，就会停止执行将主动权交还到浏览器手中。</p>\n<blockquote>\n<p>注意<code>React</code>不再使用<code>requestIdleCallback</code>这个方法，因为他们为了保证兼容性自己实现了一套！不过从方法的概念上是一致的，所以我们就采用<code>requestIdleCallback</code>这个方法。</p>\n</blockquote>\n<p>在开始这个循环之前，我们需要先指定第一个任务单元，为此我们创建了<code>performUnitOfWork</code>方法，在这个方法中需要去执行这个任务，同时最后返回下一个需要执行的任务单元<code>nextUnitOfWork</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\">deadline</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldYield = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = <span class=\"title function_\">performUnitOfWork</span>(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.<span class=\"title function_\">timeRemaining</span>() &lt; <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">nextUnitOfWork</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第四步：Fibers\"><a href=\"#第四步：Fibers\" class=\"headerlink\" title=\"第四步：Fibers\"></a>第四步：Fibers</h1><p>为了分解任务单元，我们需要一种数据结构：<code>fiber tree</code>。</p>\n<p>一个<code>fiber</code>对应一个元素，同时每个<code>fiber</code>也是我们所划分出来的任务单元。</p>\n<p>那么<code>fiber tree</code>到底是长啥样的呢？</p>\n<p>举个🌰，比如我们想要渲染如下一棵元素树。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>,</span><br><span class=\"line\">  container</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>对应的<code>fiber tree</code>就长下面这个样子。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/fiber-tree.png\" alt=\"fiber-tree.png\"></p>\n<p>在<code>render</code>方法中，我们先创建<code>root fiber</code>并把它作为第一个任务单元，即第一个<code>nextUnitOfWork</code>。其余的任务会在<code>performUnitOfWork</code>这个方法中去处理。对于每个<code>fiber</code>我们需要在<code>performUnitOfWork</code>这个方法中做三件事情：</p>\n<ol>\n<li>将元素转换为节点并添加到<code>DOM</code>上。</li>\n<li>为该元素的子元素<code>children</code>创建<code>fibers</code>。</li>\n<li>设置下一个任务单元<code>nextUnitOfWork</code>。</li>\n</ol>\n<p><code>fiber tree</code>的其中一个目标就是为了能够让设置下一个任务单元更加容易，这也是为什么每个fiber都需要有一个指针（逻辑上）指向第一个子元素<code>child</code>，一个指针指向兄弟节点<code>sibling</code>，一个指针指向父节点<code>parent</code>。</p>\n<p>当我们执行完一个<code>fiber</code>的任务时，如果它的<code>child</code>指针指向的元素不为空的话，则该元素将会被指定为<code>nextUnitOfWork</code>。以上图中的<code>fiber tree</code>为例，当我们执行完标签为<code>div</code>的<code>fiber</code>的任务时，<code>nextUnitOfWork</code>将会是它的<code>child</code>指针指向的标签为<code>h1</code>的<code>fiber</code>。</p>\n<p>如果一个<code>fiber</code>的<code>child</code>指针指向的元素为空，即该<code>fiber</code>不存在<code>child</code>时，我们将会指定<code>sibling</code>对应的<code>fiber</code>作为<code>nextUnitOfWork</code>。还是以上图的<code>fiber tree</code>为例，标签为<code>p</code>的<code>fiber</code>没有<code>child</code>，所以我们将<code>p</code>对应的<code>sibling</code>，即标签为<code>a</code>的<code>fiber</code>作为<code>nextUnitOfWork</code>。</p>\n<p>如果一个<code>fiber</code>即没有<code>child</code>也没有<code>sibling</code>，我们就指定<code>nextUnitOfWork</code>为该<code>fiber</code>的叔叔<code>uncle</code>，即该<code>fiber</code>的父节点<code>parent</code>的兄弟节点<code>sibling</code>。上图<code>fiber tree</code>中标签为<code>a</code>的<code>fiber</code>就没有<code>child</code>和<code>sibling</code>，于是向上寻找最后找到了它的叔叔，标签为<code>h2</code>的<code>fiber</code>。</p>\n<p>如果该<code>fiber</code>没有叔叔呢？我们将会继续沿着<code>parent</code>向上寻找，直到找到一个存在sibling的parent或者到达根<code>root</code>。如果是后者的话，那就说明我们已经执行完了本次渲染<code>render</code>的所有任务。</p>\n<p>接着，就让我们把想法转换为代码吧。</p>\n<p>在开始之前，我们先将<code>render</code>方法中之前的代码移除，并将移除的那部分放到方法<code>createDom</code>中去，这将会在之后用到。</p>\n<p>原<code>render</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改造过后的<code>render</code>方法以及<code>createDom</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createDom</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    fiber.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(fiber.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(fiber.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = fiber.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dom</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO set next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们专注于实现<code>render</code>方法。</p>\n<p>首先，在<code>render</code>方法中我们先把<code>fiber tree</code>的根<code>root</code>作为<code>nextUnitOfWork</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  nextUnitOfWork = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着当浏览器有空的时候就会调用我们的任务循环<code>workLoop</code>，我们就会从根<code>root</code>开始执行任务。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\">deadline</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldYield = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = <span class=\"title function_\">performUnitOfWork</span>(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.<span class=\"title function_\">timeRemaining</span>() &lt; <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO add dom node</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO create new fibers</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>performUnitOfWork</code>中，我们要先为传入的<code>fiber</code>创建对应的<code>DOM</code>节点。并且我们会使用<code>fiber.dom</code>属性来定位该<code>DOM</code>节点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span>.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// TODO create new fibers</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后对该<code>fiber</code>的子元素<code>children</code>创建相应的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...\t</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再根据是否是第一个子元素来设置<code>child</code>和<code>sibling</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们根据之前提到的<code>child-sibling-uncle（parent’s sibling）</code>的顺序来指定一下<code>nextUnitOfWork</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整的<code>performUnitOfWork</code>方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span>.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第五步：Render-and-Commit-Phases\"><a href=\"#第五步：Render-and-Commit-Phases\" class=\"headerlink\" title=\"第五步：Render and Commit Phases\"></a>第五步：Render and Commit Phases</h1><p>这里我们又遇到了一个问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fiber.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span>.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次我们在处理一个元素时都需要将其新建的节点添加到<code>DOM</code>上去。但是不要忘了，浏览器能够在我们渲染完整棵<code>fiber tree</code>之前中断我们的渲染过程的。出现这种情况时，用户将会看到一个不完整的UI界面，那是我们不想看到的。</p>\n<p>所以，我们要将修改<code>DOM</code>的这部分代码从<code>performUnitOfWork</code>方法中移除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相对地，我们需要保持对<code>fiber tree</code>的根<code>root</code>的引用。我们将其引用命名为<code>wipRoot</code>（work in progress root）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> wipRoot = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<p>一旦我们处理完了所有任务单元（可以根据<code>nextUnitOfWork</code>是否为空来判断），我们再将整棵<code>fiber tree</code>提交到<code>DOM</code>上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO add nodes to dom</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\">deadline</span>) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">commitRoot</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>commitRoot</code>这个方法中，我们以递归的方式将所有节点添加到<code>DOM</code>上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(wipRoot.<span class=\"property\">child</span>)</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span></span><br><span class=\"line\">  domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">child</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">sibling</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第六步：Reconciliation\"><a href=\"#第六步：Reconciliation\" class=\"headerlink\" title=\"第六步：Reconciliation\"></a>第六步：<strong><strong>Reconciliation</strong></strong></h1><p>目前为止，我们只是实现了添加节点到<code>DOM</code>上，删除和更新呢？</p>\n<p>这就是本节要实现的目标，为此我们需要将本次渲染的<code>fiber tree</code>即<code>wipRoot</code>与上一次提交到<code>DOM</code>上的<code>fiber tree</code>进行比较。</p>\n<p>那么，在每次提交阶段完成时，我们就需要保持对本次提交到<code>DOM</code>上的<code>fiber tree</code>的引用，以方便下次比较，我们将其引用命名为<code>currentRoot</code>。同时，我们也为每个<code>fiber</code>添加<code>alternate</code>属性，指向旧的<code>fiber</code>，即在上个提交阶段我们添加到<code>DOM</code>上的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(wipRoot.<span class=\"property\">child</span>)</span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentRoot = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>接着，让我们从<code>performUnitOfWork</code>方法中抽离创建新的<code>fiber</code>那部分代码，原代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将抽离出来的方法放到<code>reconcileChildren</code>方法中，改造后的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, elements)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: wipFiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>reconcileChildren</code>这个方法中，我们将对旧的<code>fiber</code>与新的元素进行调和<code>reconclie</code>。</p>\n<p>我们同时迭代旧<code>fiber</code>的子元素<code>wipFiber.alternate</code>以及<code>elements</code>数组中我们想要调和的元素。</p>\n<p>如果我们忽略同时迭代链表和数组所需要注意的那些通用代码，只关心其中最重要的部分：<code>oldFiber</code>和<code>element</code>，<code>element</code>是本次调和我们想要渲染到<code>DOM</code>上的<code>fiber</code>，<code>oldFiber</code>是我们上次渲染到<code>DOM</code>上的<code>fiber</code>。我们需要比较它们的差异。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldFiber =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp; wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">child</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    index &lt; elements.<span class=\"property\">length</span> ||</span><br><span class=\"line\">    oldFiber != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TODO compare oldFiber to element</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber) &#123;</span><br><span class=\"line\">      oldFiber = oldFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们采用以下方式来对它们进行比较：</p>\n<ul>\n<li>如果<code>oldFiber</code>和<code>element</code>的<code>type</code>一样，我们可以保留其<code>DOM</code>节点，只更新其中的属性<code>props</code>。</li>\n<li>如果它们的type不一样：<ul>\n<li>对于<code>element</code>，我们需要创建新的<code>DOM</code>节点。</li>\n<li>对于<code>oldFiber</code>，我们需要移除旧的<code>DOM</code>节点。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在真正的React中，这里会使用<code>key</code>来优化调和。比如，它能够探测到数组中元素的位置是否发生变化。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldFiber =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp; wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">child</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    index &lt; elements.<span class=\"property\">length</span> ||</span><br><span class=\"line\">    oldFiber != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> sameType =</span><br><span class=\"line\">      oldFiber &amp;&amp;</span><br><span class=\"line\">      element &amp;&amp;</span><br><span class=\"line\">      element.<span class=\"property\">type</span> == oldFiber.<span class=\"property\">type</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO update the node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO add this node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO delete the oldFiber&#x27;s node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber) &#123;</span><br><span class=\"line\">      oldFiber = oldFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>oldFiber</code>和<code>element</code>的<code>type</code>一致时，我们创建一个新的<code>fiber</code>，其中保持原来的<code>DOM</code>不变，属性<code>props</code>采用<code>element.props</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">  newFiber = &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: oldFiber.<span class=\"property\">type</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: oldFiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">    <span class=\"attr\">parent</span>: wipFiber,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: oldFiber,</span><br><span class=\"line\">    <span class=\"attr\">effectTag</span>: <span class=\"string\">&#x27;UPDATE&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时我们为新的<code>fiber</code>新增了<code>effectTag</code>属性。这个属性我们将会在后面的提交阶段用到。</p>\n<p>对于<code>type</code>不一致的情况，我们为<code>element</code>创建新的<code>fiber</code>，并将<code>effectTag</code>设置为<code>PLACEMENT</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">\tnewFiber = &#123;</span><br><span class=\"line\">\t  <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">parent</span>: wipFiber,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">effectTag</span>: <span class=\"string\">&quot;PLACEMENT&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>oldFiber</code>，我们需要删除对应的<code>node</code>。因为不会创建新的<code>fiber</code>，所以我们在旧的<code>fiber</code>上设置<code>effectTag</code>为<code>DELETION</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">  oldFiber.<span class=\"property\">effectTag</span> = <span class=\"string\">&#x27;DELETION&#x27;</span>;</span><br><span class=\"line\">  deletions.<span class=\"title function_\">push</span>(oldFiber);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是在提交阶段的时候，我们操作的<code>fiber tree</code>是<code>wipRoot</code>，并不需要旧的<code>fiber</code>。所以我们需要记住我们需要删除的节点（通过<code>deletions</code>数组来存放）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deletions = []</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deletions = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>接着，我们在提交阶段更新<code>DOM</code>时，只需要操作<code>deletions</code>数组中的<code>fiber</code>就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  deletions.<span class=\"title function_\">forEach</span>(commitWork)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(wipRoot.<span class=\"property\">child</span>)</span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，就让我们在<code>commitWork</code>方法中根据<code>effectTag</code>来对<code>DOM</code>进行不同的操作。</p>\n<p>如果<code>effectTag</code>是<code>PLACEMENT</code>，就像之前一样，将节点直接添加到<code>DOM</code>上即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span></span><br><span class=\"line\">  domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">child</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">sibling</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>effectTag</code>是<code>DELETION</code>，与<code>PLACEMENT</code>相反，我们将节点从<code>DOM</code>上移除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>effectTag</code>是<code>UPDATE</code>，我们需要在已存在的<code>DOM</code>上更新改变了的属性<code>props</code>。因为更新比较复杂，我们将具体的实现放在<code>updateDom</code>这个方法中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateDom</span>(</span><br><span class=\"line\">      fiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">alternate</span>.<span class=\"property\">props</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">props</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在方法<code>updateDom</code>中，我们需要比较新旧fiber的属性props，删除旧的，添加新的以及变更值发生改变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isNew</span> = (<span class=\"params\">prev, next</span>) =&gt; <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">  prev[key] !== next[key]</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isGone</span> = (<span class=\"params\">prev, next</span>) =&gt; <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> !(key <span class=\"keyword\">in</span> next)</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Remove old properties</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(prevProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(<span class=\"title function_\">isGone</span>(prevProps, nextProps))</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Set new or changed properties</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(nextProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(<span class=\"title function_\">isNew</span>(prevProps, nextProps))</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = nextProps[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等，还有一种特殊的属性我们没有处理，那就是监听事件，在<code>React</code>中合成事件有一个特点，就是以<code>on</code>开头，所以当我们在<code>props</code>中识别到监听事件时，我们需要对其特殊处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isEvent</span> = key =&gt; key.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&quot;on&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt;</span><br><span class=\"line\">  key !== <span class=\"string\">&quot;children&quot;</span> &amp;&amp; !<span class=\"title function_\">isEvent</span>(key)</span><br></pre></td></tr></table></figure>\n\n<p>如果监听事件发生了改变，我们需要将它从节点上移除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Remove old or changed event listeners</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(prevProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isEvent)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(</span><br><span class=\"line\">      <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">        !(key <span class=\"keyword\">in</span> nextProps) ||</span><br><span class=\"line\">        <span class=\"title function_\">isNew</span>(prevProps, nextProps)(key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .<span class=\"title function_\">toLowerCase</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">substring</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.<span class=\"title function_\">removeEventListener</span>(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        prevProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们新的监听事件添加到对应的节点上去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Remove old or changed event listeners</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(prevProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isEvent)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(</span><br><span class=\"line\">      <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">        !(key <span class=\"keyword\">in</span> nextProps) ||</span><br><span class=\"line\">        <span class=\"title function_\">isNew</span>(prevProps, nextProps)(key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .<span class=\"title function_\">toLowerCase</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">substring</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.<span class=\"title function_\">removeEventListener</span>(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        prevProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Add event listeners</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(nextProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isEvent)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(<span class=\"title function_\">isNew</span>(prevProps, nextProps))</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .<span class=\"title function_\">toLowerCase</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">substring</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        nextProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就实现了更新和删除，让我们在<a href=\"https://codesandbox.io/s/didact-6-96533?file=/src/index.js\">codesandbox</a>上看看加入了调和的<code>Didact</code>效果怎么样。</p>\n<h1 id=\"第七步：Function-Components\"><a href=\"#第七步：Function-Components\" class=\"headerlink\" title=\"第七步：Function Components\"></a>第七步：<strong><strong>Function Components</strong></strong></h1><p>接下来我们要做的就是让<code>Didact</code>支持函数组件。</p>\n<p>首先，让我们换个🌰，使用一个简单的函数组件，其返回一个<code>h1</code>元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;foo&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们将以上的<code>JSX</code>转换为<code>JS</code>，将会是下面这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Hi &quot;</span>,</span><br><span class=\"line\">    props.<span class=\"property\">name</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"title class_\">App</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>函数组件在两个方面有所不同：</p>\n<ul>\n<li>函数组件的<code>fiber</code>没有与之对应的<code>DOM</code>节点。</li>\n<li>子元素<code>children</code>来自运行的函数而不是直接从<code>props</code>里面获取。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, elements)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，我们需要对方法<code>performUnitOfWork</code>做出修改。</p>\n<p>首先，我们检查<code>fiber</code>的<code>type</code>是否为<code>function</code>，并以此为依据来判断是否采用不同的更新方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isFunctionComponent =</span><br><span class=\"line\">    fiber.<span class=\"property\">type</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Function</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isFunctionComponent) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateFunctionComponent</span>(fiber)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateHostComponent</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateHostComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>updateHostComponent</code>方法中使用原来的更新方式，而在<code>updateFunctionComponent</code>方法中，我们先执行这个函数去获取它的子元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"title class_\">App</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在我们的🌰中，<code>fiber.type</code>指的就是<code>App</code>这个函数，当我们运行它时，就能从返回值中获取子元素<code>h1</code>。一旦我们获取到了子元素，就可以像之前一样来进行调和，不需要在这个方法中额外做其他事情。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.<span class=\"title function_\">type</span>(fiber.<span class=\"property\">props</span>)]</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, children)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然现在我们会遇到没有<code>DOM</code>节点的<code>fiber</code>，我们需要在<code>commitWork</code>这个方法中做出两点改变。</p>\n<p>第一，沿着<code>parent</code>指针找到一个<code>DOM</code>节点的父节点，直到我们找到一个带有DOM节点的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> domParentFiber = fiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!domParentFiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    domParentFiber = domParentFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = domParentFiber.<span class=\"property\">dom</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateDom</span>(</span><br><span class=\"line\">      fiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">alternate</span>.<span class=\"property\">props</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">props</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">child</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">sibling</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二，当删除一个节点时，我们同样需要沿着<code>child</code>指针，找到一个带有<code>DOM</code>节点的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateDom</span>(</span><br><span class=\"line\">      fiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">alternate</span>.<span class=\"property\">props</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">props</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">commitDeletion</span>(fiber, domParent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitDeletion</span>(<span class=\"params\">fiber, domParent</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">commitDeletion</span>(fiber.<span class=\"property\">child</span>, domParent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第八步：Hooks\"><a href=\"#第八步：Hooks\" class=\"headerlink\" title=\"第八步：Hooks\"></a>第八步：Hooks</h1><p>最后一步，既然我们已经有了函数组件，让我们也把<code>state</code>加进来吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  render,</span><br><span class=\"line\">  useState,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [state, setState] = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">useState</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setState(c =&gt; c + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      Count: &#123;state&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Counter</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>让我们以经典的计数器组件为例，每点击它一次，它的值就增加<code>1</code>。</p>\n<p>注意这里我们已经替换成了<code>Didact.useState</code>来获取并更新计数器的值。</p>\n<p>在方法<code>updateFunctionComponent</code>中我们会调用<code>Counter</code>这个函数组件，并且在这个方法中我们还会调用<code>useState</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.<span class=\"title function_\">type</span>(fiber.<span class=\"property\">props</span>)]</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, children)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在调用函数组件之前，我们需要先初始化几个全局变量，以便我们在<code>useState</code>方法中使用它们。</p>\n<p>首先，我们设置<code>wipFiber</code>（work in process fiber）。 </p>\n<p>同时，为了实现在同一个组件中能够调用<code>useState</code>方法多次，我们为<code>fiber</code>添加一个<code>hooks</code>数组。并且我们记录当前的<code>hook</code>索引。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> wipFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hookIndex = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  wipFiber = fiber</span><br><span class=\"line\">  hookIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span> = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.<span class=\"title function_\">type</span>(fiber.<span class=\"property\">props</span>)]</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, children)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当函数组件调用<code>useState</code>方法时，我们先检查其中是否存在旧的<code>hook</code>。具体检查的方式是通过<code>fiber</code>的<code>alternate</code>属性来找到旧的<code>fiber</code>，再通过<code>hookIndex</code>找到旧<code>fiber</code>上对应的<code>hook</code>。</p>\n<p>如果存在旧的<code>hook</code>，我们直接从其中复制<code>state</code>到新的<code>hook</code>中。如果不存在，我们先初始化<code>state</code>。</p>\n<p>然后我们将新的<code>hook</code>添加到<code>fiber</code>的<code>hooks</code>数组中去，并让索引<code>hookIndex</code>增加<code>1</code>。</p>\n<p>最后返回<code>state</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span>[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    <span class=\"attr\">state</span>: oldHook ? oldHook.<span class=\"property\">state</span> : initial,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span>.<span class=\"title function_\">push</span>(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.<span class=\"property\">state</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>useState</code>方法也应该返回一个用来更新<code>state</code>的方法，所以我们定义了<code>setState</code>方法来接受一个动作<code>action</code>（比如在计数器组件中这个动作就是增加<code>1</code>的方法）。我们为<code>hook</code>新增一个队列<code>queue</code>，并将<code>action</code>放入其中。</p>\n<p>然后我们需要做的事情就跟之前我们在<code>render</code>方法中所做的类似，指定<code>nextUnitOfWork</code>为新的<code>wipRoot</code>，这样<code>workLoop</code>方法就能够开启一次新的渲染阶段。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span>[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    <span class=\"attr\">state</span>: oldHook ? oldHook.<span class=\"property\">state</span> : initial,</span><br><span class=\"line\">    <span class=\"attr\">queue</span>: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"title function_\">setState</span> = action =&gt; &#123;</span><br><span class=\"line\">    hook.<span class=\"property\">queue</span>.<span class=\"title function_\">push</span>(action)</span><br><span class=\"line\">    wipRoot = &#123;</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: currentRoot.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: currentRoot.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextUnitOfWork = wipRoot</span><br><span class=\"line\">    deletions = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span>.<span class=\"title function_\">push</span>(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.<span class=\"property\">state</span>, setState]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但我们还没有执行这个动作。</p>\n<p>我们将会在下次渲染这个组件的时候再执行这个动作，我们会从旧的<code>hook</code>上的<code>queue</code>中获取所有的<code>action</code>，并且一个一个地执行，这样做之后，我们返回的已经是更新过的<code>state</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span>[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    <span class=\"attr\">state</span>: oldHook ? oldHook.<span class=\"property\">state</span> : initial,</span><br><span class=\"line\">    <span class=\"attr\">queue</span>: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> actions = oldHook ? oldHook.<span class=\"property\">queue</span> : []</span><br><span class=\"line\">  actions.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    hook.<span class=\"property\">state</span> = <span class=\"title function_\">action</span>(hook.<span class=\"property\">state</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">setState</span> = action =&gt; &#123;</span><br><span class=\"line\">    hook.<span class=\"property\">queue</span>.<span class=\"title function_\">push</span>(action)</span><br><span class=\"line\">    wipRoot = &#123;</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: currentRoot.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: currentRoot.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextUnitOfWork = wipRoot</span><br><span class=\"line\">    deletions = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span>.<span class=\"title function_\">push</span>(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.<span class=\"property\">state</span>, setState]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是这样，我们构建了自己的<code>React</code>。</p>\n<p>在<a href=\"https://codesandbox.io/s/didact-8-21ost\">codesandbox</a>或<a href=\"https://github.com/pomber/didact\">github</a>上查看完整代码。</p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"Build-your-own-React\"><a href=\"#Build-your-own-React\" class=\"headerlink\" title=\"Build your own React\"></a>Build your own React</h1><p>本文翻译自博文 <strong><a href=\"https://pomb.us/build-your-own-react/\">Build your own React</a></strong> ，原作者为 <a href=\"https://pomb.us/\">Rodrigo Pombo</a>，已获得作者授权。</p>\n<h1 id=\"第零步：回顾-JSX-to-JS\"><a href=\"#第零步：回顾-JSX-to-JS\" class=\"headerlink\" title=\"第零步：回顾 JSX to JS\"></a>第零步：回顾 JSX to JS</h1><p>首先我们先通过以下三行代码来回顾一些 <code>React</code> 中的基本概念。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>第一行代码定义了一个<code>React</code>元素。</p>\n<p>第二行代码从<code>DOM</code>中获取了<code>id</code>为<code>root</code>的元素。</p>\n<p>第三行代码将第一行定义的<code>React</code>元素渲染到第二行获取到的元素中去。</p>\n<p>以上三行代码就构成了一个非常简单的<code>React App</code>，让我们来看看如何通过原生的<code>JS</code>来代替以上三行代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>先来看看第一行代码，其中的<code>React</code>元素就是通过<code>js</code>来定义的，它甚至不是合法的<code>JS</code>语法，为了用原生的<code>JS</code>来替代它，首先我们得让它变得合法。</p>\n<p>JSX到JS到转换是通过像<a href=\"https://babeljs.io/\">Babel</a>这样的工具来实现的，转换过程比较简单：把<code>js</code>语法中的标签<code>tag</code>、属性<code>props</code>、子元素<code>children</code>作为参数传入一个叫做<code>createElement</code>的函数来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><code>React.createElement</code>这个方法通过传入的参数创建了一个对象。抛开这个方法会对参数的一些验证以外，这就是它所做的全部事情。以此为基础，我们也可以简单模仿一下<code>React.createElement</code>创建的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们所定义的元素是一个具有两个属性（<code>type</code>和<code>props</code>）的对象（当然真正的<code>ReactElement</code>可不止这两个属性，不过在这里我们只关心这两个）。</p>\n<p><code>type</code>指的是我们想要创建的<code>DOM</code>元素类型的字符串，等同于通过<code>document.createElement</code>方法来创建<code>DOM</code>元素时传入的<code>tagName</code>。<code>type</code>也可以是一个函数，但是为了不造成困惑，这个等到第七步时我们再说。 </p>\n<p><code>props</code>也是一个对象，它存放的是JSX中设置的特性（<code>attributes</code>）的键与值，以及一个特殊的属性（<code>property</code>）<code>children</code>。</p>\n<p><code>children</code>在这里是一个字符串，不过更多时候它会是一个包含许多元素的数组，这也是为什么众多的元素通过错综复杂的关系能够构建成树的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>另外我们需要来处理的一个方法是<code>ReactDOM.render</code>。<code>render</code>是<code>React</code>来改变<code>DOM</code>的方法，这样简单的一句描述有些过于宽泛了，不过我们先可以根据这点来试着捣鼓捣鼓它是怎么改变<code>DOM</code>的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\">node[<span class=\"string\">&quot;title&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">title</span></span><br></pre></td></tr></table></figure>\n\n<p>首先我们根据我们创建的<code>element</code>的属性<code>type</code>来创建对应的<code>DOM</code>节点，在这里是<code>h1</code>。然后我们根据<strong>元素</strong><code>element</code>的属性为创建的<strong>节点</strong>设置属性，在这里是<code>title</code>。</p>\n<blockquote>\n<p>为了避免困扰，在这里说明一下，文中所说的<strong>元素</strong>指的是<code>React Element</code>，<strong>节点</strong>指的是<code>DOM Element</code>，以此来区分两者。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">text[<span class=\"string\">&quot;nodeValue&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们来为子元素创建相应的节点。这里的话只有一个子元素，为此我们需要创建一个文本节点。之所以选择创建文本节点（<code>textNode</code>）而不是设置<code>innerText</code>属性，是因为这样做的话之后我们能够通过同一种方式来处理所有元素。</p>\n<p>同时需要注意，我们在为节点设置<code>nodeValue</code>属性的这个过程，与设置节点<code>h1</code>设置<code>title</code>属性类似，就像是在设置一个文本节点的<code>nodeValue</code>为<code>Hello</code>，即<code>props: &#123;nodeValue: &quot;hello&quot;&#125;</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">node.<span class=\"title function_\">appendChild</span>(text)</span><br><span class=\"line\">container.<span class=\"title function_\">appendChild</span>(node)</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们将创建的文本节点放到节点<code>h1</code>上，将节点<code>h1</code>放到<code>id</code>为<code>root</code>的节点上去。</p>\n<p>到此为止，我们就完成了用原生的<code>JS</code>来替代<code>JSX</code>语法这一目标，完整的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = &#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">children</span>: <span class=\"string\">&quot;Hello&quot;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\">node[<span class=\"string\">&quot;title&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">title</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> text = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">text[<span class=\"string\">&quot;nodeValue&quot;</span>] = element.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\"></span><br><span class=\"line\">node.<span class=\"title function_\">appendChild</span>(text)</span><br><span class=\"line\">container.<span class=\"title function_\">appendChild</span>(node)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第一步：createElement\"><a href=\"#第一步：createElement\" class=\"headerlink\" title=\"第一步：createElement\"></a>第一步：createElement</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>让我们从另外一个<code>React App</code>开始。这次，我们来尝试创建一个自己的<code>React</code>来替代真正的<code>React</code>。</p>\n<p>从实现<code>createElement</code>方法开始吧。</p>\n<p>首先，在JSX<code>转换到</code>JS<code>的这个过程中，让我们看看</code>createElement&#96;这个方法到底都做了些什么吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** JSX */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** JS */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;bar&quot;</span>),</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前面我们提到过，一个元素（我们简化过的）实际上就是一个带有<code>type</code>和<code>props</code>这两个属性的对象。我们的方法唯一需要操心的就是如何去创建这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      children,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，我们使用展开操作符<code>...</code>来处理<code>props</code>，使用剩余参数语法<code>...</code>（没错，还是这三个点，都是<code>ES6</code>语法）来处理<code>children</code>，经过剩余参数语法的处理，<code>children</code>就变成了一个数组。</p>\n<p>例如，<code>createElement(&quot;div&quot;)</code>返回：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; <span class=\"attr\">children</span>: [] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createElement(&quot;div&quot;, null, a)</code>返回：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; <span class=\"attr\">children</span>: [a] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createElement(&quot;div&quot;, null, a, b)</code>返回：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">props</span>: &#123; <span class=\"attr\">children</span>: [a, b] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，<code>children</code>数组中的元素不一定是对象，也有可能是原始类型的值如<code>number</code>或<code>string</code>。对于这种元素，我们需要封装成一个对象，并为其创建一种特殊的<code>type</code>：<code>TEXT_ELEMENT</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: children.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">&quot;object&quot;</span></span><br><span class=\"line\">          ? child</span><br><span class=\"line\">          : <span class=\"title function_\">createTextElement</span>(child)</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createTextElement</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">nodeValue</span>: text,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意真正的<code>React</code>并没有封装原始类型的值或在没有<code>children</code>时创建一个空数组，我们这样做是为了简化我们的代码，因为我们的目标是易于理解，而不是追求高性能。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;bar&quot;</span>),</span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，我们还没有替换<code>React.createElement</code>这个方法</p>\n<p>替换<code>React</code>的第一步，给我们的库取个名字吧🤨。</p>\n<p>名字要听起来像<code>React</code>🤔，同时也要有教学（*<code>didactic</code>*）的味道🧐。</p>\n<p>有了💡，就叫它<code>Didact</code>吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;foo&quot;</span> &#125;,</span><br><span class=\"line\">  <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;bar&quot;</span>),</span><br><span class=\"line\">  <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;b&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是我们仍然需要使用<code>JSX</code>语法，怎样才能让<code>babel</code>知道我们用的是<code>Didact</code>中的<code>createElement</code>方法而不是<code>React</code>的呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>在元素前面添加像这样的注释，<code>babel</code>就会使用我们定义的方法去转换<code>JSX</code>了。（关于<code>babel</code>的解析规则这里就不过多深入）</p>\n<p>最后，本节实现的<code>createElement</code>方法完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: children.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">&quot;object&quot;</span></span><br><span class=\"line\">          ? child</span><br><span class=\"line\">          : <span class=\"title function_\">createTextElement</span>(child)</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createTextElement</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">nodeValue</span>: text,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二步：render\"><a href=\"#第二步：render\" class=\"headerlink\" title=\"第二步：render\"></a>第二步：render</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;foo&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span>&gt;</span>bar<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">b</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>接着，让我们关注最后一行代码。是的没错，本节的目标就是实现我们自己的<code>render</code>方法以替换<code>ReactDOM.render</code>。</p>\n<p>对于现在的我们来说，我们只需要关心把元素变成节点添加到<code>DOM</code>上去。至于更新和删除，我们一步一步来，后面再考虑这些。</p>\n<p>下面的代码就先搭好了架子，接着就只需要在<code>render</code>方法内部去实现具体的功能就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO create dom nodes</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  render,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们先根据元素的类型<code>type</code>来创建相应的<code>DOM</code>节点，然后将这个节点添加到容器节点<code>container</code>中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然，不要忘了子元素<code>children</code>，这里采用递归的方法来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等，还有文本元素呢，如果元素的类型<code>type</code>是<code>TEXT_ELEMENT</code>，我们要为其创建文本节点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，节点有了，就该为其添加属性<code>props</code>了。记得需要排除<code>props</code>中的<code>children</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Bingo! That’s it! 我们做到了，现在我们的库<code>Didact</code> 也可以将<code>JSX</code>元素渲染成真正的<code>DOM</code>节点了。</p>\n<p>本节实现的<code>render</code>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上之前实现的完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createElement</span>(<span class=\"params\">type, props, ...children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      ...props,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: children.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">typeof</span> child === <span class=\"string\">&quot;object&quot;</span> ? child : <span class=\"title function_\">createTextElement</span>(child)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createTextElement</span>(<span class=\"params\">text</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">nodeValue</span>: text,</span><br><span class=\"line\">      <span class=\"attr\">children</span>: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span>;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span> <span class=\"title function_\">render</span>(child, dom));</span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  render</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background: salmon&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello World<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;text-align:right&quot;</span>&gt;</span>from Didact<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>);</span><br><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(element, container);</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以在<a href=\"https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js:0-1113\">codesandbox</a>上看看最终的效果怎么样。</p>\n<h1 id=\"第三步：Concurrent-Mode\"><a href=\"#第三步：Concurrent-Mode\" class=\"headerlink\" title=\"第三步：Concurrent Mode\"></a>第三步：Concurrent Mode</h1><p>并发，听起来是不是非常地高大上？没错，本节就是要实现它！</p>\n<p>不过，在开始之前，我们需要来解决一点问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意以上代码，因为采用的是递归，一旦我们开始渲染，在整个元素树渲染的过程是无法停下来的。如果元素树非常复杂的话，就会占用主线程非常多的时间，从而造成阻塞。试着想一下，如果浏览器需要处理优先级更高的事件如用户输入、保持动画流畅运行，这时浏览器就不得不等到<code>render</code>方法执行完后再来处理这些事情。</p>\n<p>既然递归会造成这么严重的问题，那我们之前为什么要采用递归的方式呢？我猜是因为React之前也是采用不可中断的递归的方式。（误</p>\n<p>走远了，让我们回到正题，来将这个过程变得可中断。</p>\n<p>首先，我们来将整个任务拆分成一个个小的任务单元<code>work unit</code>，然后在每次执行完一个小的任务单元后询问一下浏览器有没有其他需要优先处理的事情。这个反复的过程我们用<code>requestIdleCallback</code>这个原生方法来实现，这个函数会在浏览器空闲的时候执行，这样的话像一些关键事件如动画和用户输入就不会被影响延迟。<code>requestIdleCallback</code>同时也<strong>提供</strong>了一个类似于截止时间<code>deadline</code>的参数，如果传入的方法执行时间超过了这个时间，就会停止执行将主动权交还到浏览器手中。</p>\n<blockquote>\n<p>注意<code>React</code>不再使用<code>requestIdleCallback</code>这个方法，因为他们为了保证兼容性自己实现了一套！不过从方法的概念上是一致的，所以我们就采用<code>requestIdleCallback</code>这个方法。</p>\n</blockquote>\n<p>在开始这个循环之前，我们需要先指定第一个任务单元，为此我们创建了<code>performUnitOfWork</code>方法，在这个方法中需要去执行这个任务，同时最后返回下一个需要执行的任务单元<code>nextUnitOfWork</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\">deadline</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldYield = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = <span class=\"title function_\">performUnitOfWork</span>(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.<span class=\"title function_\">timeRemaining</span>() &lt; <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">nextUnitOfWork</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第四步：Fibers\"><a href=\"#第四步：Fibers\" class=\"headerlink\" title=\"第四步：Fibers\"></a>第四步：Fibers</h1><p>为了分解任务单元，我们需要一种数据结构：<code>fiber tree</code>。</p>\n<p>一个<code>fiber</code>对应一个元素，同时每个<code>fiber</code>也是我们所划分出来的任务单元。</p>\n<p>那么<code>fiber tree</code>到底是长啥样的呢？</p>\n<p>举个🌰，比如我们想要渲染如下一棵元素树。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>,</span><br><span class=\"line\">  container</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>对应的<code>fiber tree</code>就长下面这个样子。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/fiber-tree.png\" alt=\"fiber-tree.png\"></p>\n<p>在<code>render</code>方法中，我们先创建<code>root fiber</code>并把它作为第一个任务单元，即第一个<code>nextUnitOfWork</code>。其余的任务会在<code>performUnitOfWork</code>这个方法中去处理。对于每个<code>fiber</code>我们需要在<code>performUnitOfWork</code>这个方法中做三件事情：</p>\n<ol>\n<li>将元素转换为节点并添加到<code>DOM</code>上。</li>\n<li>为该元素的子元素<code>children</code>创建<code>fibers</code>。</li>\n<li>设置下一个任务单元<code>nextUnitOfWork</code>。</li>\n</ol>\n<p><code>fiber tree</code>的其中一个目标就是为了能够让设置下一个任务单元更加容易，这也是为什么每个fiber都需要有一个指针（逻辑上）指向第一个子元素<code>child</code>，一个指针指向兄弟节点<code>sibling</code>，一个指针指向父节点<code>parent</code>。</p>\n<p>当我们执行完一个<code>fiber</code>的任务时，如果它的<code>child</code>指针指向的元素不为空的话，则该元素将会被指定为<code>nextUnitOfWork</code>。以上图中的<code>fiber tree</code>为例，当我们执行完标签为<code>div</code>的<code>fiber</code>的任务时，<code>nextUnitOfWork</code>将会是它的<code>child</code>指针指向的标签为<code>h1</code>的<code>fiber</code>。</p>\n<p>如果一个<code>fiber</code>的<code>child</code>指针指向的元素为空，即该<code>fiber</code>不存在<code>child</code>时，我们将会指定<code>sibling</code>对应的<code>fiber</code>作为<code>nextUnitOfWork</code>。还是以上图的<code>fiber tree</code>为例，标签为<code>p</code>的<code>fiber</code>没有<code>child</code>，所以我们将<code>p</code>对应的<code>sibling</code>，即标签为<code>a</code>的<code>fiber</code>作为<code>nextUnitOfWork</code>。</p>\n<p>如果一个<code>fiber</code>即没有<code>child</code>也没有<code>sibling</code>，我们就指定<code>nextUnitOfWork</code>为该<code>fiber</code>的叔叔<code>uncle</code>，即该<code>fiber</code>的父节点<code>parent</code>的兄弟节点<code>sibling</code>。上图<code>fiber tree</code>中标签为<code>a</code>的<code>fiber</code>就没有<code>child</code>和<code>sibling</code>，于是向上寻找最后找到了它的叔叔，标签为<code>h2</code>的<code>fiber</code>。</p>\n<p>如果该<code>fiber</code>没有叔叔呢？我们将会继续沿着<code>parent</code>向上寻找，直到找到一个存在sibling的parent或者到达根<code>root</code>。如果是后者的话，那就说明我们已经执行完了本次渲染<code>render</code>的所有任务。</p>\n<p>接着，就让我们把想法转换为代码吧。</p>\n<p>在开始之前，我们先将<code>render</code>方法中之前的代码移除，并将移除的那部分放到方法<code>createDom</code>中去，这将会在之后用到。</p>\n<p>原<code>render</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    element.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = element.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(child, dom)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  container.<span class=\"title function_\">appendChild</span>(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改造过后的<code>render</code>方法以及<code>createDom</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createDom</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom =</span><br><span class=\"line\">    fiber.<span class=\"property\">type</span> == <span class=\"string\">&quot;TEXT_ELEMENT&quot;</span></span><br><span class=\"line\">      ? <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">      : <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(fiber.<span class=\"property\">type</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(fiber.<span class=\"property\">props</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = fiber.<span class=\"property\">props</span>[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> dom</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO set next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们专注于实现<code>render</code>方法。</p>\n<p>首先，在<code>render</code>方法中我们先把<code>fiber tree</code>的根<code>root</code>作为<code>nextUnitOfWork</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  nextUnitOfWork = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着当浏览器有空的时候就会调用我们的任务循环<code>workLoop</code>，我们就会从根<code>root</code>开始执行任务。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\">deadline</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> shouldYield = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class=\"line\">    nextUnitOfWork = <span class=\"title function_\">performUnitOfWork</span>(</span><br><span class=\"line\">      nextUnitOfWork</span><br><span class=\"line\">    )</span><br><span class=\"line\">    shouldYield = deadline.<span class=\"title function_\">timeRemaining</span>() &lt; <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(workLoop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO add dom node</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO create new fibers</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>performUnitOfWork</code>中，我们要先为传入的<code>fiber</code>创建对应的<code>DOM</code>节点。并且我们会使用<code>fiber.dom</code>属性来定位该<code>DOM</code>节点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span>.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// TODO create new fibers</span></span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后对该<code>fiber</code>的子元素<code>children</code>创建相应的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...\t</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再根据是否是第一个子元素来设置<code>child</code>和<code>sibling</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// TODO return next unit of work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们根据之前提到的<code>child-sibling-uncle（parent’s sibling）</code>的顺序来指定一下<code>nextUnitOfWork</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整的<code>performUnitOfWork</code>方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span>.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第五步：Render-and-Commit-Phases\"><a href=\"#第五步：Render-and-Commit-Phases\" class=\"headerlink\" title=\"第五步：Render and Commit Phases\"></a>第五步：Render and Commit Phases</h1><p>这里我们又遇到了一个问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fiber.<span class=\"property\">parent</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span>.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次我们在处理一个元素时都需要将其新建的节点添加到<code>DOM</code>上去。但是不要忘了，浏览器能够在我们渲染完整棵<code>fiber tree</code>之前中断我们的渲染过程的。出现这种情况时，用户将会看到一个不完整的UI界面，那是我们不想看到的。</p>\n<p>所以，我们要将修改<code>DOM</code>的这部分代码从<code>performUnitOfWork</code>方法中移除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相对地，我们需要保持对<code>fiber tree</code>的根<code>root</code>的引用。我们将其引用命名为<code>wipRoot</code>（work in progress root）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> wipRoot = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<p>一旦我们处理完了所有任务单元（可以根据<code>nextUnitOfWork</code>是否为空来判断），我们再将整棵<code>fiber tree</code>提交到<code>DOM</code>上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO add nodes to dom</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\">deadline</span>) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">commitRoot</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>commitRoot</code>这个方法中，我们以递归的方式将所有节点添加到<code>DOM</code>上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(wipRoot.<span class=\"property\">child</span>)</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span></span><br><span class=\"line\">  domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">child</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">sibling</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第六步：Reconciliation\"><a href=\"#第六步：Reconciliation\" class=\"headerlink\" title=\"第六步：Reconciliation\"></a>第六步：<strong><strong>Reconciliation</strong></strong></h1><p>目前为止，我们只是实现了添加节点到<code>DOM</code>上，删除和更新呢？</p>\n<p>这就是本节要实现的目标，为此我们需要将本次渲染的<code>fiber tree</code>即<code>wipRoot</code>与上一次提交到<code>DOM</code>上的<code>fiber tree</code>进行比较。</p>\n<p>那么，在每次提交阶段完成时，我们就需要保持对本次提交到<code>DOM</code>上的<code>fiber tree</code>的引用，以方便下次比较，我们将其引用命名为<code>currentRoot</code>。同时，我们也为每个<code>fiber</code>添加<code>alternate</code>属性，指向旧的<code>fiber</code>，即在上个提交阶段我们添加到<code>DOM</code>上的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(wipRoot.<span class=\"property\">child</span>)</span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentRoot = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>接着，让我们从<code>performUnitOfWork</code>方法中抽离创建新的<code>fiber</code>那部分代码，原代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: fiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      fiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将抽离出来的方法放到<code>reconcileChildren</code>方法中，改造后的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, elements)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; elements.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newFiber = &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">parent</span>: wipFiber,</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>reconcileChildren</code>这个方法中，我们将对旧的<code>fiber</code>与新的元素进行调和<code>reconclie</code>。</p>\n<p>我们同时迭代旧<code>fiber</code>的子元素<code>wipFiber.alternate</code>以及<code>elements</code>数组中我们想要调和的元素。</p>\n<p>如果我们忽略同时迭代链表和数组所需要注意的那些通用代码，只关心其中最重要的部分：<code>oldFiber</code>和<code>element</code>，<code>element</code>是本次调和我们想要渲染到<code>DOM</code>上的<code>fiber</code>，<code>oldFiber</code>是我们上次渲染到<code>DOM</code>上的<code>fiber</code>。我们需要比较它们的差异。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldFiber =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp; wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">child</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    index &lt; elements.<span class=\"property\">length</span> ||</span><br><span class=\"line\">    oldFiber != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TODO compare oldFiber to element</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber) &#123;</span><br><span class=\"line\">      oldFiber = oldFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们采用以下方式来对它们进行比较：</p>\n<ul>\n<li>如果<code>oldFiber</code>和<code>element</code>的<code>type</code>一样，我们可以保留其<code>DOM</code>节点，只更新其中的属性<code>props</code>。</li>\n<li>如果它们的type不一样：<ul>\n<li>对于<code>element</code>，我们需要创建新的<code>DOM</code>节点。</li>\n<li>对于<code>oldFiber</code>，我们需要移除旧的<code>DOM</code>节点。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在真正的React中，这里会使用<code>key</code>来优化调和。比如，它能够探测到数组中元素的位置是否发生变化。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">wipFiber, elements</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldFiber =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp; wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">child</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> prevSibling = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (</span><br><span class=\"line\">    index &lt; elements.<span class=\"property\">length</span> ||</span><br><span class=\"line\">    oldFiber != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> element = elements[index]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> sameType =</span><br><span class=\"line\">      oldFiber &amp;&amp;</span><br><span class=\"line\">      element &amp;&amp;</span><br><span class=\"line\">      element.<span class=\"property\">type</span> == oldFiber.<span class=\"property\">type</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO update the node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO add this node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// TODO delete the oldFiber&#x27;s node</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldFiber) &#123;</span><br><span class=\"line\">      oldFiber = oldFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      wipFiber.<span class=\"property\">child</span> = newFiber</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      prevSibling.<span class=\"property\">sibling</span> = newFiber</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    prevSibling = newFiber</span><br><span class=\"line\">    index++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>oldFiber</code>和<code>element</code>的<code>type</code>一致时，我们创建一个新的<code>fiber</code>，其中保持原来的<code>DOM</code>不变，属性<code>props</code>采用<code>element.props</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sameType) &#123;</span><br><span class=\"line\">  newFiber = &#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: oldFiber.<span class=\"property\">type</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: oldFiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">    <span class=\"attr\">parent</span>: wipFiber,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: oldFiber,</span><br><span class=\"line\">    <span class=\"attr\">effectTag</span>: <span class=\"string\">&#x27;UPDATE&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时我们为新的<code>fiber</code>新增了<code>effectTag</code>属性。这个属性我们将会在后面的提交阶段用到。</p>\n<p>对于<code>type</code>不一致的情况，我们为<code>element</code>创建新的<code>fiber</code>，并将<code>effectTag</code>设置为<code>PLACEMENT</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">\tnewFiber = &#123;</span><br><span class=\"line\">\t  <span class=\"attr\">type</span>: element.<span class=\"property\">type</span>,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: element.<span class=\"property\">props</span>,</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">parent</span>: wipFiber,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">effectTag</span>: <span class=\"string\">&quot;PLACEMENT&quot;</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>oldFiber</code>，我们需要删除对应的<code>node</code>。因为不会创建新的<code>fiber</code>，所以我们在旧的<code>fiber</code>上设置<code>effectTag</code>为<code>DELETION</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class=\"line\">  oldFiber.<span class=\"property\">effectTag</span> = <span class=\"string\">&#x27;DELETION&#x27;</span>;</span><br><span class=\"line\">  deletions.<span class=\"title function_\">push</span>(oldFiber);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是在提交阶段的时候，我们操作的<code>fiber tree</code>是<code>wipRoot</code>，并不需要旧的<code>fiber</code>。所以我们需要记住我们需要删除的节点（通过<code>deletions</code>数组来存放）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) &#123;</span><br><span class=\"line\">  wipRoot = &#123;</span><br><span class=\"line\">    <span class=\"attr\">dom</span>: container,</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">children</span>: [element],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deletions = []</span><br><span class=\"line\">  nextUnitOfWork = wipRoot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deletions = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>接着，我们在提交阶段更新<code>DOM</code>时，只需要操作<code>deletions</code>数组中的<code>fiber</code>就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitRoot</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  deletions.<span class=\"title function_\">forEach</span>(commitWork)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(wipRoot.<span class=\"property\">child</span>)</span><br><span class=\"line\">  currentRoot = wipRoot</span><br><span class=\"line\">  wipRoot = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，就让我们在<code>commitWork</code>方法中根据<code>effectTag</code>来对<code>DOM</code>进行不同的操作。</p>\n<p>如果<code>effectTag</code>是<code>PLACEMENT</code>，就像之前一样，将节点直接添加到<code>DOM</code>上即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = fiber.<span class=\"property\">parent</span>.<span class=\"property\">dom</span></span><br><span class=\"line\">  domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">child</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">sibling</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>effectTag</code>是<code>DELETION</code>，与<code>PLACEMENT</code>相反，我们将节点从<code>DOM</code>上移除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>effectTag</code>是<code>UPDATE</code>，我们需要在已存在的<code>DOM</code>上更新改变了的属性<code>props</code>。因为更新比较复杂，我们将具体的实现放在<code>updateDom</code>这个方法中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateDom</span>(</span><br><span class=\"line\">      fiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">alternate</span>.<span class=\"property\">props</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">props</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在方法<code>updateDom</code>中，我们需要比较新旧fiber的属性props，删除旧的，添加新的以及变更值发生改变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt; key !== <span class=\"string\">&quot;children&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isNew</span> = (<span class=\"params\">prev, next</span>) =&gt; <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">  prev[key] !== next[key]</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isGone</span> = (<span class=\"params\">prev, next</span>) =&gt; <span class=\"function\"><span class=\"params\">key</span> =&gt;</span> !(key <span class=\"keyword\">in</span> next)</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Remove old properties</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(prevProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(<span class=\"title function_\">isGone</span>(prevProps, nextProps))</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Set new or changed properties</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(nextProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isProperty)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(<span class=\"title function_\">isNew</span>(prevProps, nextProps))</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dom[name] = nextProps[name]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等等，还有一种特殊的属性我们没有处理，那就是监听事件，在<code>React</code>中合成事件有一个特点，就是以<code>on</code>开头，所以当我们在<code>props</code>中识别到监听事件时，我们需要对其特殊处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isEvent</span> = key =&gt; key.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&quot;on&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isProperty</span> = key =&gt;</span><br><span class=\"line\">  key !== <span class=\"string\">&quot;children&quot;</span> &amp;&amp; !<span class=\"title function_\">isEvent</span>(key)</span><br></pre></td></tr></table></figure>\n\n<p>如果监听事件发生了改变，我们需要将它从节点上移除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Remove old or changed event listeners</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(prevProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isEvent)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(</span><br><span class=\"line\">      <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">        !(key <span class=\"keyword\">in</span> nextProps) ||</span><br><span class=\"line\">        <span class=\"title function_\">isNew</span>(prevProps, nextProps)(key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .<span class=\"title function_\">toLowerCase</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">substring</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.<span class=\"title function_\">removeEventListener</span>(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        prevProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们新的监听事件添加到对应的节点上去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateDom</span>(<span class=\"params\">dom, prevProps, nextProps</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Remove old or changed event listeners</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(prevProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isEvent)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(</span><br><span class=\"line\">      <span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">        !(key <span class=\"keyword\">in</span> nextProps) ||</span><br><span class=\"line\">        <span class=\"title function_\">isNew</span>(prevProps, nextProps)(key)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .<span class=\"title function_\">toLowerCase</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">substring</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.<span class=\"title function_\">removeEventListener</span>(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        prevProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// Add event listeners</span></span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(nextProps)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(isEvent)</span><br><span class=\"line\">    .<span class=\"title function_\">filter</span>(<span class=\"title function_\">isNew</span>(prevProps, nextProps))</span><br><span class=\"line\">    .<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> eventType = name</span><br><span class=\"line\">        .<span class=\"title function_\">toLowerCase</span>()</span><br><span class=\"line\">        .<span class=\"title function_\">substring</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">      dom.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">        eventType,</span><br><span class=\"line\">        nextProps[name]</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就实现了更新和删除，让我们在<a href=\"https://codesandbox.io/s/didact-6-96533?file=/src/index.js\">codesandbox</a>上看看加入了调和的<code>Didact</code>效果怎么样。</p>\n<h1 id=\"第七步：Function-Components\"><a href=\"#第七步：Function-Components\" class=\"headerlink\" title=\"第七步：Function Components\"></a>第七步：<strong><strong>Function Components</strong></strong></h1><p>接下来我们要做的就是让<code>Didact</code>支持函数组件。</p>\n<p>首先，让我们换个🌰，使用一个简单的函数组件，其返回一个<code>h1</code>元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;foo&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\"><span class=\"title class_\">Didact</span>.<span class=\"title function_\">render</span>(element, container)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们将以上的<code>JSX</code>转换为<code>JS</code>，将会是下面这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;h1&quot;</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Hi &quot;</span>,</span><br><span class=\"line\">    props.<span class=\"property\">name</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"title class_\">App</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>函数组件在两个方面有所不同：</p>\n<ul>\n<li>函数组件的<code>fiber</code>没有与之对应的<code>DOM</code>节点。</li>\n<li>子元素<code>children</code>来自运行的函数而不是直接从<code>props</code>里面获取。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> elements = fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span></span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, elements)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，我们需要对方法<code>performUnitOfWork</code>做出修改。</p>\n<p>首先，我们检查<code>fiber</code>的<code>type</code>是否为<code>function</code>，并以此为依据来判断是否采用不同的更新方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isFunctionComponent =</span><br><span class=\"line\">    fiber.<span class=\"property\">type</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Function</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isFunctionComponent) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateFunctionComponent</span>(fiber)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateHostComponent</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">child</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber.<span class=\"property\">child</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFiber = fiber</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nextFiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextFiber.<span class=\"property\">sibling</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextFiber.<span class=\"property\">sibling</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextFiber = nextFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateHostComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> = <span class=\"title function_\">createDom</span>(fiber)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, fiber.<span class=\"property\">props</span>.<span class=\"property\">children</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>updateHostComponent</code>方法中使用原来的更新方式，而在<code>updateFunctionComponent</code>方法中，我们先执行这个函数去获取它的子元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">createElement</span>(<span class=\"title class_\">App</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在我们的🌰中，<code>fiber.type</code>指的就是<code>App</code>这个函数，当我们运行它时，就能从返回值中获取子元素<code>h1</code>。一旦我们获取到了子元素，就可以像之前一样来进行调和，不需要在这个方法中额外做其他事情。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.<span class=\"title function_\">type</span>(fiber.<span class=\"property\">props</span>)]</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, children)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然现在我们会遇到没有<code>DOM</code>节点的<code>fiber</code>，我们需要在<code>commitWork</code>这个方法中做出两点改变。</p>\n<p>第一，沿着<code>parent</code>指针找到一个<code>DOM</code>节点的父节点，直到我们找到一个带有DOM节点的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!fiber) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> domParentFiber = fiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!domParentFiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    domParentFiber = domParentFiber.<span class=\"property\">parent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> domParent = domParentFiber.<span class=\"property\">dom</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateDom</span>(</span><br><span class=\"line\">      fiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">alternate</span>.<span class=\"property\">props</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">props</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">child</span>)</span><br><span class=\"line\">  <span class=\"title function_\">commitWork</span>(fiber.<span class=\"property\">sibling</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二，当删除一个节点时，我们同样需要沿着<code>child</code>指针，找到一个带有<code>DOM</code>节点的<code>fiber</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitWork</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">appendChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class=\"line\">    fiber.<span class=\"property\">dom</span> != <span class=\"literal\">null</span></span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateDom</span>(</span><br><span class=\"line\">      fiber.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">alternate</span>.<span class=\"property\">props</span>,</span><br><span class=\"line\">      fiber.<span class=\"property\">props</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fiber.<span class=\"property\">effectTag</span> === <span class=\"string\">&quot;DELETION&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">commitDeletion</span>(fiber, domParent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">commitDeletion</span>(<span class=\"params\">fiber, domParent</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fiber.<span class=\"property\">dom</span>) &#123;</span><br><span class=\"line\">    domParent.<span class=\"title function_\">removeChild</span>(fiber.<span class=\"property\">dom</span>)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">commitDeletion</span>(fiber.<span class=\"property\">child</span>, domParent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第八步：Hooks\"><a href=\"#第八步：Hooks\" class=\"headerlink\" title=\"第八步：Hooks\"></a>第八步：Hooks</h1><p>最后一步，既然我们已经有了函数组件，让我们也把<code>state</code>加进来吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Didact</span> = &#123;</span><br><span class=\"line\">  createElement,</span><br><span class=\"line\">  render,</span><br><span class=\"line\">  useState,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@jsx</span> Didact.createElement */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [state, setState] = <span class=\"title class_\">Didact</span>.<span class=\"title function_\">useState</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setState(c =&gt; c + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      Count: &#123;state&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Counter</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>让我们以经典的计数器组件为例，每点击它一次，它的值就增加<code>1</code>。</p>\n<p>注意这里我们已经替换成了<code>Didact.useState</code>来获取并更新计数器的值。</p>\n<p>在方法<code>updateFunctionComponent</code>中我们会调用<code>Counter</code>这个函数组件，并且在这个方法中我们还会调用<code>useState</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.<span class=\"title function_\">type</span>(fiber.<span class=\"property\">props</span>)]</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, children)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在调用函数组件之前，我们需要先初始化几个全局变量，以便我们在<code>useState</code>方法中使用它们。</p>\n<p>首先，我们设置<code>wipFiber</code>（work in process fiber）。 </p>\n<p>同时，为了实现在同一个组件中能够调用<code>useState</code>方法多次，我们为<code>fiber</code>添加一个<code>hooks</code>数组。并且我们记录当前的<code>hook</code>索引。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> wipFiber = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hookIndex = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateFunctionComponent</span>(<span class=\"params\">fiber</span>) &#123;</span><br><span class=\"line\">  wipFiber = fiber</span><br><span class=\"line\">  hookIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span> = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = [fiber.<span class=\"title function_\">type</span>(fiber.<span class=\"property\">props</span>)]</span><br><span class=\"line\">  <span class=\"title function_\">reconcileChildren</span>(fiber, children)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当函数组件调用<code>useState</code>方法时，我们先检查其中是否存在旧的<code>hook</code>。具体检查的方式是通过<code>fiber</code>的<code>alternate</code>属性来找到旧的<code>fiber</code>，再通过<code>hookIndex</code>找到旧<code>fiber</code>上对应的<code>hook</code>。</p>\n<p>如果存在旧的<code>hook</code>，我们直接从其中复制<code>state</code>到新的<code>hook</code>中。如果不存在，我们先初始化<code>state</code>。</p>\n<p>然后我们将新的<code>hook</code>添加到<code>fiber</code>的<code>hooks</code>数组中去，并让索引<code>hookIndex</code>增加<code>1</code>。</p>\n<p>最后返回<code>state</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span>[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    <span class=\"attr\">state</span>: oldHook ? oldHook.<span class=\"property\">state</span> : initial,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span>.<span class=\"title function_\">push</span>(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.<span class=\"property\">state</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>useState</code>方法也应该返回一个用来更新<code>state</code>的方法，所以我们定义了<code>setState</code>方法来接受一个动作<code>action</code>（比如在计数器组件中这个动作就是增加<code>1</code>的方法）。我们为<code>hook</code>新增一个队列<code>queue</code>，并将<code>action</code>放入其中。</p>\n<p>然后我们需要做的事情就跟之前我们在<code>render</code>方法中所做的类似，指定<code>nextUnitOfWork</code>为新的<code>wipRoot</code>，这样<code>workLoop</code>方法就能够开启一次新的渲染阶段。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span>[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    <span class=\"attr\">state</span>: oldHook ? oldHook.<span class=\"property\">state</span> : initial,</span><br><span class=\"line\">    <span class=\"attr\">queue</span>: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"title function_\">setState</span> = action =&gt; &#123;</span><br><span class=\"line\">    hook.<span class=\"property\">queue</span>.<span class=\"title function_\">push</span>(action)</span><br><span class=\"line\">    wipRoot = &#123;</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: currentRoot.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: currentRoot.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextUnitOfWork = wipRoot</span><br><span class=\"line\">    deletions = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span>.<span class=\"title function_\">push</span>(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.<span class=\"property\">state</span>, setState]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但我们还没有执行这个动作。</p>\n<p>我们将会在下次渲染这个组件的时候再执行这个动作，我们会从旧的<code>hook</code>上的<code>queue</code>中获取所有的<code>action</code>，并且一个一个地执行，这样做之后，我们返回的已经是更新过的<code>state</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useState</span>(<span class=\"params\">initial</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldHook =</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span> &amp;&amp;</span><br><span class=\"line\">    wipFiber.<span class=\"property\">alternate</span>.<span class=\"property\">hooks</span>[hookIndex]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hook = &#123;</span><br><span class=\"line\">    <span class=\"attr\">state</span>: oldHook ? oldHook.<span class=\"property\">state</span> : initial,</span><br><span class=\"line\">    <span class=\"attr\">queue</span>: [],</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> actions = oldHook ? oldHook.<span class=\"property\">queue</span> : []</span><br><span class=\"line\">  actions.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    hook.<span class=\"property\">state</span> = <span class=\"title function_\">action</span>(hook.<span class=\"property\">state</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">setState</span> = action =&gt; &#123;</span><br><span class=\"line\">    hook.<span class=\"property\">queue</span>.<span class=\"title function_\">push</span>(action)</span><br><span class=\"line\">    wipRoot = &#123;</span><br><span class=\"line\">      <span class=\"attr\">dom</span>: currentRoot.<span class=\"property\">dom</span>,</span><br><span class=\"line\">      <span class=\"attr\">props</span>: currentRoot.<span class=\"property\">props</span>,</span><br><span class=\"line\">      <span class=\"attr\">alternate</span>: currentRoot,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextUnitOfWork = wipRoot</span><br><span class=\"line\">    deletions = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  wipFiber.<span class=\"property\">hooks</span>.<span class=\"title function_\">push</span>(hook)</span><br><span class=\"line\">  hookIndex++</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [hook.<span class=\"property\">state</span>, setState]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是这样，我们构建了自己的<code>React</code>。</p>\n<p>在<a href=\"https://codesandbox.io/s/didact-8-21ost\">codesandbox</a>或<a href=\"https://github.com/pomber/didact\">github</a>上查看完整代码。</p>\n"},{"title":"再学 JS 之数据类型 —— boolean、undefined、null","date":"2022-05-05T11:35:21.000Z","updated":"2022-05-29T13:27:56.537Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages//img/js-again.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# boolean\n\n原始类型中的`boolean`类型仅有两个值：`true`和`false`，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。\n\n```js\ntypeof true === 'boolean' // true\n\n// 逻辑运算符的使用与隐式类型转换\ntypeof !'false' === 'boolean' // true\n```\n\n## 有关boolean类型转换\n\n### 显式类型转换\n\n可以使用之前提到过的对象包装器`Boolean`将其他类型的值进行显示地转换为boolean的值，或者使用双重非（`!!`）。\n\n```js\nconst bool1 = !!{x:100} // 将对象显式转换为boolean值\nconst bool2 = Boolean('Yui') // 将字符串显式转换为boolean值\n// 使用new关键字时创建的是一个对象，而不是类型转换\nconst boolObj = new Boolean(false)\n\ntypeof bool1 // 'boolean'\ntypeof bool2 // 'boolean'\ntypeof boolObj // 'object'\n```\n\n### 隐式类型转换\n\n类型转换指的是将其他类型的值转换为`boolean`的值时所采用的规则。如在使用`Boolean`转换其他类型的值时，未传入参数或者参数值为`0`、`null`、`undefined`、`NaN`、`''`时转换后的布尔值为`false`。\n\n因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。\n\n```js\n// 一个涉及对象的隐式类型转换的例子\n[] == ![] // true\n```\n\n隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。\n# undefined\n\n原始类型中的`undefined`只包含一个值：`undefined`，意为未被赋值。当使用`var`、`let`关键字声明变量而赋值时，变量的值就为`undefined`，同时也可以显示地给变量赋值为`undefined`（不建议这样做）。\n\n```js\ntypeof undefined // 'undefined'\n\nlet undefinedX\ntypeof undefinedX // 'undefined'\n```\n\n# null\n\nnull同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。\n\n```js\ntypeof null // 'object'\n```\n\n虽然`null`是原始类型的值，但是在这里却被“错误”地判断为`object`，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为`0`的话就会被认为是`object`，而`null`的二进制表示全为`0`，故被错误地识别为`object`。\n\n## undefined 与 null 的区别\n\n从逻辑上讲，`null`处于主动，需要使用时必须显式地赋值；`undefined`处于被动，当使用者忘记赋值时系统会默认赋值为`undefined`，如函数没有返回值时会默认返回`undefined`、调用函数未传入应该提供的参数时参数默认值为`undefined`等。\n\n另外需要注意的是`undefined`在进行类型转换时与`null`的区别。\n\n```js\n// 涉及隐式类型转换\n// 关系运算符与相等运算符的规则不同\n// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑\nundefined == null // true\n10 + null // 10\n10 + undefined // NaN\n\nnull > 0  // null会被转换为0， 结果为false\nnull == 0 // null在此处不会进行类型转换 结果为false\n\nNumber(null) // 0\nNumber(undefined) // NaN\n\n// 使用全等运算符判断结果为false\n// 关于全等运算符与相等运算符的差别后面会讲\nundefined === null // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/js-again-primitive-type-boolean-undefined-null.md","raw":"---\ntitle: 再学 JS 之数据类型 —— boolean、undefined、null\ndate: 2022-05-05 19:35:21\nupdated:\ntags: \n  - 数据类型\ncategories: \n  - [前端, JavaScript]\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages//img/js-again.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# boolean\n\n原始类型中的`boolean`类型仅有两个值：`true`和`false`，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。\n\n```js\ntypeof true === 'boolean' // true\n\n// 逻辑运算符的使用与隐式类型转换\ntypeof !'false' === 'boolean' // true\n```\n\n## 有关boolean类型转换\n\n### 显式类型转换\n\n可以使用之前提到过的对象包装器`Boolean`将其他类型的值进行显示地转换为boolean的值，或者使用双重非（`!!`）。\n\n```js\nconst bool1 = !!{x:100} // 将对象显式转换为boolean值\nconst bool2 = Boolean('Yui') // 将字符串显式转换为boolean值\n// 使用new关键字时创建的是一个对象，而不是类型转换\nconst boolObj = new Boolean(false)\n\ntypeof bool1 // 'boolean'\ntypeof bool2 // 'boolean'\ntypeof boolObj // 'object'\n```\n\n### 隐式类型转换\n\n类型转换指的是将其他类型的值转换为`boolean`的值时所采用的规则。如在使用`Boolean`转换其他类型的值时，未传入参数或者参数值为`0`、`null`、`undefined`、`NaN`、`''`时转换后的布尔值为`false`。\n\n因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。\n\n```js\n// 一个涉及对象的隐式类型转换的例子\n[] == ![] // true\n```\n\n隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。\n# undefined\n\n原始类型中的`undefined`只包含一个值：`undefined`，意为未被赋值。当使用`var`、`let`关键字声明变量而赋值时，变量的值就为`undefined`，同时也可以显示地给变量赋值为`undefined`（不建议这样做）。\n\n```js\ntypeof undefined // 'undefined'\n\nlet undefinedX\ntypeof undefinedX // 'undefined'\n```\n\n# null\n\nnull同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。\n\n```js\ntypeof null // 'object'\n```\n\n虽然`null`是原始类型的值，但是在这里却被“错误”地判断为`object`，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为`0`的话就会被认为是`object`，而`null`的二进制表示全为`0`，故被错误地识别为`object`。\n\n## undefined 与 null 的区别\n\n从逻辑上讲，`null`处于主动，需要使用时必须显式地赋值；`undefined`处于被动，当使用者忘记赋值时系统会默认赋值为`undefined`，如函数没有返回值时会默认返回`undefined`、调用函数未传入应该提供的参数时参数默认值为`undefined`等。\n\n另外需要注意的是`undefined`在进行类型转换时与`null`的区别。\n\n```js\n// 涉及隐式类型转换\n// 关系运算符与相等运算符的规则不同\n// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑\nundefined == null // true\n10 + null // 10\n10 + undefined // NaN\n\nnull > 0  // null会被转换为0， 结果为false\nnull == 0 // null在此处不会进行类型转换 结果为false\n\nNumber(null) // 0\nNumber(undefined) // NaN\n\n// 使用全等运算符判断结果为false\n// 关于全等运算符与相等运算符的差别后面会讲\nundefined === null // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"js-again-primitive-type-boolean-undefined-null","published":1,"layout":"post","photos":[],"link":"","_id":"cl3re6un70006vuo9dbo8c100","content":"<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>原始类型中的<code>boolean</code>类型仅有两个值：<code>true</code>和<code>false</code>，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 逻辑运算符的使用与隐式类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> !<span class=\"string\">&#x27;false&#x27;</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有关boolean类型转换\"><a href=\"#有关boolean类型转换\" class=\"headerlink\" title=\"有关boolean类型转换\"></a>有关boolean类型转换</h2><h3 id=\"显式类型转换\"><a href=\"#显式类型转换\" class=\"headerlink\" title=\"显式类型转换\"></a>显式类型转换</h3><p>可以使用之前提到过的对象包装器<code>Boolean</code>将其他类型的值进行显示地转换为boolean的值，或者使用双重非（<code>!!</code>）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bool1 = !!&#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125; <span class=\"comment\">// 将对象显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bool2 = <span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;Yui&#x27;</span>) <span class=\"comment\">// 将字符串显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"comment\">// 使用new关键字时创建的是一个对象，而不是类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> boolObj = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool1 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool2 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> boolObj <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>类型转换指的是将其他类型的值转换为<code>boolean</code>的值时所采用的规则。如在使用<code>Boolean</code>转换其他类型的值时，未传入参数或者参数值为<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>&#39;&#39;</code>时转换后的布尔值为<code>false</code>。</p>\n<p>因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个涉及对象的隐式类型转换的例子</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>原始类型中的<code>undefined</code>只包含一个值：<code>undefined</code>，意为未被赋值。当使用<code>var</code>、<code>let</code>关键字声明变量而赋值时，变量的值就为<code>undefined</code>，同时也可以显示地给变量赋值为<code>undefined</code>（不建议这样做）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> undefinedX</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undefinedX <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>null同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然<code>null</code>是原始类型的值，但是在这里却被“错误”地判断为<code>object</code>，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为<code>0</code>的话就会被认为是<code>object</code>，而<code>null</code>的二进制表示全为<code>0</code>，故被错误地识别为<code>object</code>。</p>\n<h2 id=\"undefined-与-null-的区别\"><a href=\"#undefined-与-null-的区别\" class=\"headerlink\" title=\"undefined 与 null 的区别\"></a>undefined 与 null 的区别</h2><p>从逻辑上讲，<code>null</code>处于主动，需要使用时必须显式地赋值；<code>undefined</code>处于被动，当使用者忘记赋值时系统会默认赋值为<code>undefined</code>，如函数没有返回值时会默认返回<code>undefined</code>、调用函数未传入应该提供的参数时参数默认值为<code>undefined</code>等。</p>\n<p>另外需要注意的是<code>undefined</code>在进行类型转换时与<code>null</code>的区别。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 涉及隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// 关系运算符与相等运算符的规则不同</span></span><br><span class=\"line\"><span class=\"comment\">// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> &gt; <span class=\"number\">0</span>  <span class=\"comment\">// null会被转换为0， 结果为false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// null在此处不会进行类型转换 结果为false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用全等运算符判断结果为false</span></span><br><span class=\"line\"><span class=\"comment\">// 关于全等运算符与相等运算符的差别后面会讲</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>原始类型中的<code>boolean</code>类型仅有两个值：<code>true</code>和<code>false</code>，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 逻辑运算符的使用与隐式类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> !<span class=\"string\">&#x27;false&#x27;</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有关boolean类型转换\"><a href=\"#有关boolean类型转换\" class=\"headerlink\" title=\"有关boolean类型转换\"></a>有关boolean类型转换</h2><h3 id=\"显式类型转换\"><a href=\"#显式类型转换\" class=\"headerlink\" title=\"显式类型转换\"></a>显式类型转换</h3><p>可以使用之前提到过的对象包装器<code>Boolean</code>将其他类型的值进行显示地转换为boolean的值，或者使用双重非（<code>!!</code>）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bool1 = !!&#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125; <span class=\"comment\">// 将对象显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bool2 = <span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;Yui&#x27;</span>) <span class=\"comment\">// 将字符串显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"comment\">// 使用new关键字时创建的是一个对象，而不是类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> boolObj = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool1 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool2 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> boolObj <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>类型转换指的是将其他类型的值转换为<code>boolean</code>的值时所采用的规则。如在使用<code>Boolean</code>转换其他类型的值时，未传入参数或者参数值为<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>&#39;&#39;</code>时转换后的布尔值为<code>false</code>。</p>\n<p>因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个涉及对象的隐式类型转换的例子</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>原始类型中的<code>undefined</code>只包含一个值：<code>undefined</code>，意为未被赋值。当使用<code>var</code>、<code>let</code>关键字声明变量而赋值时，变量的值就为<code>undefined</code>，同时也可以显示地给变量赋值为<code>undefined</code>（不建议这样做）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> undefinedX</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undefinedX <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>null同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然<code>null</code>是原始类型的值，但是在这里却被“错误”地判断为<code>object</code>，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为<code>0</code>的话就会被认为是<code>object</code>，而<code>null</code>的二进制表示全为<code>0</code>，故被错误地识别为<code>object</code>。</p>\n<h2 id=\"undefined-与-null-的区别\"><a href=\"#undefined-与-null-的区别\" class=\"headerlink\" title=\"undefined 与 null 的区别\"></a>undefined 与 null 的区别</h2><p>从逻辑上讲，<code>null</code>处于主动，需要使用时必须显式地赋值；<code>undefined</code>处于被动，当使用者忘记赋值时系统会默认赋值为<code>undefined</code>，如函数没有返回值时会默认返回<code>undefined</code>、调用函数未传入应该提供的参数时参数默认值为<code>undefined</code>等。</p>\n<p>另外需要注意的是<code>undefined</code>在进行类型转换时与<code>null</code>的区别。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 涉及隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// 关系运算符与相等运算符的规则不同</span></span><br><span class=\"line\"><span class=\"comment\">// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> &gt; <span class=\"number\">0</span>  <span class=\"comment\">// null会被转换为0， 结果为false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// null在此处不会进行类型转换 结果为false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用全等运算符判断结果为false</span></span><br><span class=\"line\"><span class=\"comment\">// 关于全等运算符与相等运算符的差别后面会讲</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之数据类型 —— number","date":"2022-05-05T08:35:21.000Z","updated":"2022-05-29T13:27:56.537Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# 原始类型(primitive values)\n\n原始类型一共有七种：`number`、`string`、`boolean`、`undefined`、`null`、`bigInt`、`symbol`。\n\n原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。\n\n> 在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（`String`、`Number`、`Boolean`、`Symbol`），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。\n\n```js\n// 不能为原始类型的实例直接添加属性\nlet str = 'Hi'\nstr.test = 4\nconsole.log(str.test) // undefined\n\n// 可以显式地为原始类型进行“包装”\nlet num = new Number(2)\nnum.test = 33\nconsole.log(num.test) // 33\n\n// 在调用原始类型的方法时，由于原始类型上并没有方法\n// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法\n// 调用完此方法后会将该临时对象销毁，留下原始值\nconst lower = 'lowercase'\nconst upper = lower.toUpperCase()\nconsole.log(lower) // lowercase\nconsole.log(upper) // LOWERCASE\n```\n\n# number\n\n在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。\n\n```js\ntypeof 1 === 'number'\n\n// NaN(Not-a-Number) 表示非数值\ntypeof NaN === 'number'\n\nNumber.MAX_SAFE_INTEGER // 9007199254740991\n\nNumber.MIN_SAFE_INTEGER // -9007199254740991\n\n// Infinity 表示无穷\ntypeof Infinity === 'number'\n\n// +Infinity 表示正无穷 -Infinity 表示负无穷\n+Infinity > 0 // true\n```\n\n需要注意的是，在 JavaScript 中，可以直接使用`number`类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（[具体原理涉及汇编，有基础的话可参考这篇文章](https://zhuanlan.zhihu.com/p/352723802)），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。\n\n> 实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用`toFixed`方法对数字显式地进行格式化\n\n```js\nconst floatNum1 = 1.9\n\nconst floatNum2 = .2 // 小数点前可以不需要整数，但这种做法并不推荐\n\nconst floatNum3 = 3.000 // 会被当作整数3处理\n```\n\n## 精度丢失问题（0.1+0.2 !== 0.3）\n\n造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6)转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。\n\n> 虽然存在一位用于表示符号，但是`+0`与`-0`在 JavaScript 中被认为是相等的，但可以使用`Object.is()`方法可以判断`+0`与`-0`不相等，此为特殊情况。\n>\n> ```js\n> +0 === -0 // true\n> Object.is(+0, -0) // false\n> ```\n\n```js\n0.1+0.2 // 0.30000000000000004\n\n// 该数字转换为二进制后存在53位，超出范围\n9999999999999999 // 10000000000000000\n```\n\n并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。\n\n## 使用科学计数法表示\n\n```js\n// 使用科学计数法\n1e2 === 100 // true\n1e-3 === 0.001 // true\n```\n\n## 二进制，八进制与十六进制\n\njavaScript 中默认支持这三种进制的写法，其他进制可以通过方法`parseInt`转换\n\n```js\n// 不正确的进制表示会报语法错误\n// 二进制数字每位只能是1或0\n0b103 // Uncaught SyntaxError: Invalid or unexpected token\n\n// 不同进制的数字在进行数学操作时都会被视作为十进制数字\n0b101+017 === 20 // true\n0xff + 0o377 === 510 // true\n\n// 二进制 使用0b前缀\n0b101 === 5 // true\n\n// 八进制 使用0o前缀\n0o17 === 15 // true\n\n// 非严格模式下可以使用前缀0来表示八进制（不推荐）\n017 === 15 // true\n// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字\n019 === 19 // true\n\n// 十六进制 使用0x前缀\n0xff === 255 // true\n// 大小写不会造成影响\n0xfF === 0xff // true\n```\n\n## 常用方法\n\n> 不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。\n\n```js\n6.toString() // Uncaught SyntaxError: Invalid or unexpected token\n\n(0xfe).toString() === '254' // true\n(20).toString() === '20' // true\n20..toString() === '20' // true\n\n```\n\n### **num.toString(base)**\n\n将数字转换为字符串，参数`base`表示需要转换的进制，默认值为 10。\n\n```js\n// 十进制转换为二进制\n2.toString(2) === '10' // true\n\n// 八进制转换为十六进制\n(0o377).toString(16) === 'ff' // true\n```\n\n### **num.toFixed(digits)**\n\n格式化数字，返回字符串。参数`digits`表示需要保留几位小数。该方法会对数字进行四舍五入。\n\n```js\n// 保留小数点后3位\n1.23.toFixed(3) === '1.230' // true\n\n// 保留小数点后2位\n1.256.toFixed(2) === '1.26' // true\n```\n\n注意 toFixed 方法同样存在精度丢失的问题。\n\n```js\n// 如果小数部分是一个无限的二进制,存储会造成精度损失\n\n1.35.toFixed(20) // 1.35000000000000008882\n1.55.toFixed(1) === '1.6' // true\n\n6.35.toFixed(20) // 6.34999999999999964473\n6.35.toFixed(1) === '6.3' // true\n\n// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字\n// 等操作完后再进行还原\n(6.35 * 10).toFixed(20) // 63.50000000000000000000\n```\n\n### **isNaN(value)**\n\n判断一个值是否为 NaN\n\n> 注意`NaN === NaN`的比较结果为`false`，这是因为`NaN`是独一无二的，它不等于任何东西，这也是`isNaN`方法存在的意义。不过，使用`Object.is()`方法同样可以判断是否为`NaN`。\n\n```js\nisNaN(12) === false // true\n\n// 此处发生了类型的隐式转换\n// 如果参数不是数字，会尝试将参数转换为数值\nisNaN('11') === false // true\n\nisNaN('ab') === true // true\n\n// 使用Object.is()方法判断\nObject.is(NaN, NaN) // true\n```\n\n### **isFinite(value)**\n\n判断传入的数字是否为有限数字，参数是  `NaN`、正无穷大或者负无穷大，会返回`false`，其他返回  `true`。\n\n### **parseInt(string, radix)**\n\n### **parseFloat(string, radix)**\n\n将字符串强制转换为十进制数字。参数`string`表示需要解析的字符串，`radix`表示解析时采用什么进制，有效范围为`2到36`。\n\n不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回`NaN`。\n\n第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回`NaN`。\n\n```js\n// 如果第一个字符不能转换为数字，则直接返回NaN\n// 遇到其他进制的数字会正常解析，如二进制以0b开头等\nparseInt('a12') // NaN\nparseInt('0b101') === 5 // true\n\n// 直到读取到非数字为止，会转换之前读取到的数字\nparseInt('2a1') === 2 // true\n\n// 第二个参数传入非有效进制\nparseFloat('1.2', 1) // NaN\n\n// 第二个参数传入0时按照十进制解析\nparseFloat('1.2', 0) === 1.2 // true\n\n// 3 并非有效的二进制表示\nparseInt('3', 2) // NaN\n```\n\n### **Number(value)**\n\n`number`类型的对象包装器，可以通过`Number()`构造函数来创建`number`类型，这个函数的参数`value`可以为其他类型如`stirng`、`boolean`等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：\n\n- `boolean`，`true`返回`1`，`false`返回`0`。\n- `number`，直接返回值。\n- `null`，返回`0`。\n- `undefined`，返回`NaN`。\n- `string`，规则如下:\n  - 字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字\n  - 空字符串返回`0`\n  - 如果字符串中包含其他字符，则直接返回`NaN`，注意就算是像`'12a'`这样的值也会返回`NaN`，这点与`parseInt`方法中解析规则直到读取到非数字为止不同。\n\n这里已经涉及到**隐式类型转换**，具体的会在之后详细地解释。\n\n## 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**\n\n","source":"_posts/js-again-primitive-type-number.md","raw":"---\ntitle: 再学 JS 之数据类型 —— number\ndate: 2022-05-05 16:35:21\nupdated:\ntags: \n  - 数据类型\ncategories: \n  - [前端, JavaScript]\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# 原始类型(primitive values)\n\n原始类型一共有七种：`number`、`string`、`boolean`、`undefined`、`null`、`bigInt`、`symbol`。\n\n原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。\n\n> 在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（`String`、`Number`、`Boolean`、`Symbol`），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。\n\n```js\n// 不能为原始类型的实例直接添加属性\nlet str = 'Hi'\nstr.test = 4\nconsole.log(str.test) // undefined\n\n// 可以显式地为原始类型进行“包装”\nlet num = new Number(2)\nnum.test = 33\nconsole.log(num.test) // 33\n\n// 在调用原始类型的方法时，由于原始类型上并没有方法\n// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法\n// 调用完此方法后会将该临时对象销毁，留下原始值\nconst lower = 'lowercase'\nconst upper = lower.toUpperCase()\nconsole.log(lower) // lowercase\nconsole.log(upper) // LOWERCASE\n```\n\n# number\n\n在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。\n\n```js\ntypeof 1 === 'number'\n\n// NaN(Not-a-Number) 表示非数值\ntypeof NaN === 'number'\n\nNumber.MAX_SAFE_INTEGER // 9007199254740991\n\nNumber.MIN_SAFE_INTEGER // -9007199254740991\n\n// Infinity 表示无穷\ntypeof Infinity === 'number'\n\n// +Infinity 表示正无穷 -Infinity 表示负无穷\n+Infinity > 0 // true\n```\n\n需要注意的是，在 JavaScript 中，可以直接使用`number`类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（[具体原理涉及汇编，有基础的话可参考这篇文章](https://zhuanlan.zhihu.com/p/352723802)），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。\n\n> 实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用`toFixed`方法对数字显式地进行格式化\n\n```js\nconst floatNum1 = 1.9\n\nconst floatNum2 = .2 // 小数点前可以不需要整数，但这种做法并不推荐\n\nconst floatNum3 = 3.000 // 会被当作整数3处理\n```\n\n## 精度丢失问题（0.1+0.2 !== 0.3）\n\n造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6)转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。\n\n> 虽然存在一位用于表示符号，但是`+0`与`-0`在 JavaScript 中被认为是相等的，但可以使用`Object.is()`方法可以判断`+0`与`-0`不相等，此为特殊情况。\n>\n> ```js\n> +0 === -0 // true\n> Object.is(+0, -0) // false\n> ```\n\n```js\n0.1+0.2 // 0.30000000000000004\n\n// 该数字转换为二进制后存在53位，超出范围\n9999999999999999 // 10000000000000000\n```\n\n并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。\n\n## 使用科学计数法表示\n\n```js\n// 使用科学计数法\n1e2 === 100 // true\n1e-3 === 0.001 // true\n```\n\n## 二进制，八进制与十六进制\n\njavaScript 中默认支持这三种进制的写法，其他进制可以通过方法`parseInt`转换\n\n```js\n// 不正确的进制表示会报语法错误\n// 二进制数字每位只能是1或0\n0b103 // Uncaught SyntaxError: Invalid or unexpected token\n\n// 不同进制的数字在进行数学操作时都会被视作为十进制数字\n0b101+017 === 20 // true\n0xff + 0o377 === 510 // true\n\n// 二进制 使用0b前缀\n0b101 === 5 // true\n\n// 八进制 使用0o前缀\n0o17 === 15 // true\n\n// 非严格模式下可以使用前缀0来表示八进制（不推荐）\n017 === 15 // true\n// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字\n019 === 19 // true\n\n// 十六进制 使用0x前缀\n0xff === 255 // true\n// 大小写不会造成影响\n0xfF === 0xff // true\n```\n\n## 常用方法\n\n> 不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。\n\n```js\n6.toString() // Uncaught SyntaxError: Invalid or unexpected token\n\n(0xfe).toString() === '254' // true\n(20).toString() === '20' // true\n20..toString() === '20' // true\n\n```\n\n### **num.toString(base)**\n\n将数字转换为字符串，参数`base`表示需要转换的进制，默认值为 10。\n\n```js\n// 十进制转换为二进制\n2.toString(2) === '10' // true\n\n// 八进制转换为十六进制\n(0o377).toString(16) === 'ff' // true\n```\n\n### **num.toFixed(digits)**\n\n格式化数字，返回字符串。参数`digits`表示需要保留几位小数。该方法会对数字进行四舍五入。\n\n```js\n// 保留小数点后3位\n1.23.toFixed(3) === '1.230' // true\n\n// 保留小数点后2位\n1.256.toFixed(2) === '1.26' // true\n```\n\n注意 toFixed 方法同样存在精度丢失的问题。\n\n```js\n// 如果小数部分是一个无限的二进制,存储会造成精度损失\n\n1.35.toFixed(20) // 1.35000000000000008882\n1.55.toFixed(1) === '1.6' // true\n\n6.35.toFixed(20) // 6.34999999999999964473\n6.35.toFixed(1) === '6.3' // true\n\n// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字\n// 等操作完后再进行还原\n(6.35 * 10).toFixed(20) // 63.50000000000000000000\n```\n\n### **isNaN(value)**\n\n判断一个值是否为 NaN\n\n> 注意`NaN === NaN`的比较结果为`false`，这是因为`NaN`是独一无二的，它不等于任何东西，这也是`isNaN`方法存在的意义。不过，使用`Object.is()`方法同样可以判断是否为`NaN`。\n\n```js\nisNaN(12) === false // true\n\n// 此处发生了类型的隐式转换\n// 如果参数不是数字，会尝试将参数转换为数值\nisNaN('11') === false // true\n\nisNaN('ab') === true // true\n\n// 使用Object.is()方法判断\nObject.is(NaN, NaN) // true\n```\n\n### **isFinite(value)**\n\n判断传入的数字是否为有限数字，参数是  `NaN`、正无穷大或者负无穷大，会返回`false`，其他返回  `true`。\n\n### **parseInt(string, radix)**\n\n### **parseFloat(string, radix)**\n\n将字符串强制转换为十进制数字。参数`string`表示需要解析的字符串，`radix`表示解析时采用什么进制，有效范围为`2到36`。\n\n不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回`NaN`。\n\n第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回`NaN`。\n\n```js\n// 如果第一个字符不能转换为数字，则直接返回NaN\n// 遇到其他进制的数字会正常解析，如二进制以0b开头等\nparseInt('a12') // NaN\nparseInt('0b101') === 5 // true\n\n// 直到读取到非数字为止，会转换之前读取到的数字\nparseInt('2a1') === 2 // true\n\n// 第二个参数传入非有效进制\nparseFloat('1.2', 1) // NaN\n\n// 第二个参数传入0时按照十进制解析\nparseFloat('1.2', 0) === 1.2 // true\n\n// 3 并非有效的二进制表示\nparseInt('3', 2) // NaN\n```\n\n### **Number(value)**\n\n`number`类型的对象包装器，可以通过`Number()`构造函数来创建`number`类型，这个函数的参数`value`可以为其他类型如`stirng`、`boolean`等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：\n\n- `boolean`，`true`返回`1`，`false`返回`0`。\n- `number`，直接返回值。\n- `null`，返回`0`。\n- `undefined`，返回`NaN`。\n- `string`，规则如下:\n  - 字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字\n  - 空字符串返回`0`\n  - 如果字符串中包含其他字符，则直接返回`NaN`，注意就算是像`'12a'`这样的值也会返回`NaN`，这点与`parseInt`方法中解析规则直到读取到非数字为止不同。\n\n这里已经涉及到**隐式类型转换**，具体的会在之后详细地解释。\n\n## 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**\n\n","slug":"js-again-primitive-type-number","published":1,"layout":"post","photos":[],"link":"","_id":"cl3re6un80008vuo969qd4xri","content":"<h1 id=\"原始类型-primitive-values\"><a href=\"#原始类型-primitive-values\" class=\"headerlink\" title=\"原始类型(primitive values)\"></a>原始类型(primitive values)</h1><p>原始类型一共有七种：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>bigInt</code>、<code>symbol</code>。</p>\n<p>原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。</p>\n<blockquote>\n<p>在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code>），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不能为原始类型的实例直接添加属性</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Hi&#x27;</span></span><br><span class=\"line\">str.<span class=\"property\">test</span> = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"property\">test</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以显式地为原始类型进行“包装”</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">num.<span class=\"property\">test</span> = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num.<span class=\"property\">test</span>) <span class=\"comment\">// 33</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在调用原始类型的方法时，由于原始类型上并没有方法</span></span><br><span class=\"line\"><span class=\"comment\">// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法</span></span><br><span class=\"line\"><span class=\"comment\">// 调用完此方法后会将该临时对象销毁，留下原始值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> lower = <span class=\"string\">&#x27;lowercase&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> upper = lower.<span class=\"title function_\">toUpperCase</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(lower) <span class=\"comment\">// lowercase</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(upper) <span class=\"comment\">// LOWERCASE</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">1</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NaN(Not-a-Number) 表示非数值</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">NaN</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span> <span class=\"comment\">// 9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MIN_SAFE_INTEGER</span> <span class=\"comment\">// -9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Infinity 表示无穷</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Infinity</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +Infinity 表示正无穷 -Infinity 表示负无穷</span></span><br><span class=\"line\">+<span class=\"title class_\">Infinity</span> &gt; <span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在 JavaScript 中，可以直接使用<code>number</code>类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（<a href=\"https://zhuanlan.zhihu.com/p/352723802\">具体原理涉及汇编，有基础的话可参考这篇文章</a>），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。</p>\n<blockquote>\n<p>实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用<code>toFixed</code>方法对数字显式地进行格式化</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floatNum1 = <span class=\"number\">1.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum2 = <span class=\"number\">.2</span> <span class=\"comment\">// 小数点前可以不需要整数，但这种做法并不推荐</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum3 = <span class=\"number\">3.000</span> <span class=\"comment\">// 会被当作整数3处理</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"精度丢失问题（0-1-0-2-x3D-x3D-0-3）\"><a href=\"#精度丢失问题（0-1-0-2-x3D-x3D-0-3）\" class=\"headerlink\" title=\"精度丢失问题（0.1+0.2 !&#x3D;&#x3D; 0.3）\"></a>精度丢失问题（0.1+0.2 !&#x3D;&#x3D; 0.3）</h2><p>造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6\">二进制</a>转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式<a href=\"https://zh.wikipedia.org/wiki/IEEE_754\">IEEE 754</a> 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。</p>\n<blockquote>\n<p>虽然存在一位用于表示符号，但是<code>+0</code>与<code>-0</code>在 JavaScript 中被认为是相等的，但可以使用<code>Object.is()</code>方法可以判断<code>+0</code>与<code>-0</code>不相等，此为特殊情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">+<span class=\"number\">0</span> === -<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span>+<span class=\"number\">0.2</span> <span class=\"comment\">// 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该数字转换为二进制后存在53位，超出范围</span></span><br><span class=\"line\"><span class=\"number\">9999999999999999</span> <span class=\"comment\">// 10000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<p>并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。</p>\n<h2 id=\"使用科学计数法表示\"><a href=\"#使用科学计数法表示\" class=\"headerlink\" title=\"使用科学计数法表示\"></a>使用科学计数法表示</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用科学计数法</span></span><br><span class=\"line\"><span class=\"number\">1e2</span> === <span class=\"number\">100</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">1e-3</span> === <span class=\"number\">0.001</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二进制，八进制与十六进制\"><a href=\"#二进制，八进制与十六进制\" class=\"headerlink\" title=\"二进制，八进制与十六进制\"></a>二进制，八进制与十六进制</h2><p>javaScript 中默认支持这三种进制的写法，其他进制可以通过方法<code>parseInt</code>转换</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不正确的进制表示会报语法错误</span></span><br><span class=\"line\"><span class=\"comment\">// 二进制数字每位只能是1或0</span></span><br><span class=\"line\">0b103 <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同进制的数字在进行数学操作时都会被视作为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">0b101</span>+<span class=\"number\">017</span> === <span class=\"number\">20</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> + <span class=\"number\">0o377</span> === <span class=\"number\">510</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制 使用0b前缀</span></span><br><span class=\"line\"><span class=\"number\">0b101</span> === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制 使用0o前缀</span></span><br><span class=\"line\"><span class=\"number\">0o17</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非严格模式下可以使用前缀0来表示八进制（不推荐）</span></span><br><span class=\"line\"><span class=\"number\">017</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">019</span> === <span class=\"number\">19</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制 使用0x前缀</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> === <span class=\"number\">255</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 大小写不会造成影响</span></span><br><span class=\"line\"><span class=\"number\">0xfF</span> === <span class=\"number\">0xff</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><blockquote>\n<p>不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6.</span><span class=\"title function_\">toString</span>() <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">0xfe</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;254&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"number\">20</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">20.</span>.<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toString-base\"><a href=\"#num-toString-base\" class=\"headerlink\" title=\"num.toString(base)\"></a><strong>num.toString(base)</strong></h3><p>将数字转换为字符串，参数<code>base</code>表示需要转换的进制，默认值为 10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转换为二进制</span></span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"title function_\">toString</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;10&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制转换为十六进制</span></span><br><span class=\"line\">(<span class=\"number\">0o377</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>) === <span class=\"string\">&#x27;ff&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toFixed-digits\"><a href=\"#num-toFixed-digits\" class=\"headerlink\" title=\"num.toFixed(digits)\"></a><strong>num.toFixed(digits)</strong></h3><p>格式化数字，返回字符串。参数<code>digits</code>表示需要保留几位小数。该方法会对数字进行四舍五入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保留小数点后3位</span></span><br><span class=\"line\"><span class=\"number\">1.23</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;1.230&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 保留小数点后2位</span></span><br><span class=\"line\"><span class=\"number\">1.256</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;1.26&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>注意 toFixed 方法同样存在精度丢失的问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果小数部分是一个无限的二进制,存储会造成精度损失</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 1.35000000000000008882</span></span><br><span class=\"line\"><span class=\"number\">1.55</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;1.6&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 6.34999999999999964473</span></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;6.3&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 等操作完后再进行还原</span></span><br><span class=\"line\">(<span class=\"number\">6.35</span> * <span class=\"number\">10</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 63.50000000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isNaN-value\"><a href=\"#isNaN-value\" class=\"headerlink\" title=\"isNaN(value)\"></a><strong>isNaN(value)</strong></h3><p>判断一个值是否为 NaN</p>\n<blockquote>\n<p>注意<code>NaN === NaN</code>的比较结果为<code>false</code>，这是因为<code>NaN</code>是独一无二的，它不等于任何东西，这也是<code>isNaN</code>方法存在的意义。不过，使用<code>Object.is()</code>方法同样可以判断是否为<code>NaN</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">12</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此处发生了类型的隐式转换</span></span><br><span class=\"line\"><span class=\"comment\">// 如果参数不是数字，会尝试将参数转换为数值</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;11&#x27;</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;ab&#x27;</span>) === <span class=\"literal\">true</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Object.is()方法判断</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(<span class=\"title class_\">NaN</span>, <span class=\"title class_\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isFinite-value\"><a href=\"#isFinite-value\" class=\"headerlink\" title=\"isFinite(value)\"></a><strong>isFinite(value)</strong></h3><p>判断传入的数字是否为有限数字，参数是  <code>NaN</code>、正无穷大或者负无穷大，会返回<code>false</code>，其他返回  <code>true</code>。</p>\n<h3 id=\"parseInt-string-radix\"><a href=\"#parseInt-string-radix\" class=\"headerlink\" title=\"parseInt(string, radix)\"></a><strong>parseInt(string, radix)</strong></h3><h3 id=\"parseFloat-string-radix\"><a href=\"#parseFloat-string-radix\" class=\"headerlink\" title=\"parseFloat(string, radix)\"></a><strong>parseFloat(string, radix)</strong></h3><p>将字符串强制转换为十进制数字。参数<code>string</code>表示需要解析的字符串，<code>radix</code>表示解析时采用什么进制，有效范围为<code>2到36</code>。</p>\n<p>不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回<code>NaN</code>。</p>\n<p>第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回<code>NaN</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果第一个字符不能转换为数字，则直接返回NaN</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到其他进制的数字会正常解析，如二进制以0b开头等</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;a12&#x27;</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0b101&#x27;</span>) === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直到读取到非数字为止，会转换之前读取到的数字</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;2a1&#x27;</span>) === <span class=\"number\">2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入非有效进制</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">1</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入0时按照十进制解析</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">0</span>) === <span class=\"number\">1.2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3 并非有效的二进制表示</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Number-value\"><a href=\"#Number-value\" class=\"headerlink\" title=\"Number(value)\"></a><strong>Number(value)</strong></h3><p><code>number</code>类型的对象包装器，可以通过<code>Number()</code>构造函数来创建<code>number</code>类型，这个函数的参数<code>value</code>可以为其他类型如<code>stirng</code>、<code>boolean</code>等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：</p>\n<ul>\n<li><code>boolean</code>，<code>true</code>返回<code>1</code>，<code>false</code>返回<code>0</code>。</li>\n<li><code>number</code>，直接返回值。</li>\n<li><code>null</code>，返回<code>0</code>。</li>\n<li><code>undefined</code>，返回<code>NaN</code>。</li>\n<li><code>string</code>，规则如下:<ul>\n<li>字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字</li>\n<li>空字符串返回<code>0</code></li>\n<li>如果字符串中包含其他字符，则直接返回<code>NaN</code>，注意就算是像<code>&#39;12a&#39;</code>这样的值也会返回<code>NaN</code>，这点与<code>parseInt</code>方法中解析规则直到读取到非数字为止不同。</li>\n</ul>\n</li>\n</ul>\n<p>这里已经涉及到<strong>隐式类型转换</strong>，具体的会在之后详细地解释。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"原始类型-primitive-values\"><a href=\"#原始类型-primitive-values\" class=\"headerlink\" title=\"原始类型(primitive values)\"></a>原始类型(primitive values)</h1><p>原始类型一共有七种：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>bigInt</code>、<code>symbol</code>。</p>\n<p>原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。</p>\n<blockquote>\n<p>在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code>），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不能为原始类型的实例直接添加属性</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Hi&#x27;</span></span><br><span class=\"line\">str.<span class=\"property\">test</span> = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"property\">test</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以显式地为原始类型进行“包装”</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">num.<span class=\"property\">test</span> = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num.<span class=\"property\">test</span>) <span class=\"comment\">// 33</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在调用原始类型的方法时，由于原始类型上并没有方法</span></span><br><span class=\"line\"><span class=\"comment\">// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法</span></span><br><span class=\"line\"><span class=\"comment\">// 调用完此方法后会将该临时对象销毁，留下原始值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> lower = <span class=\"string\">&#x27;lowercase&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> upper = lower.<span class=\"title function_\">toUpperCase</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(lower) <span class=\"comment\">// lowercase</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(upper) <span class=\"comment\">// LOWERCASE</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">1</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NaN(Not-a-Number) 表示非数值</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">NaN</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span> <span class=\"comment\">// 9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MIN_SAFE_INTEGER</span> <span class=\"comment\">// -9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Infinity 表示无穷</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Infinity</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +Infinity 表示正无穷 -Infinity 表示负无穷</span></span><br><span class=\"line\">+<span class=\"title class_\">Infinity</span> &gt; <span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在 JavaScript 中，可以直接使用<code>number</code>类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（<a href=\"https://zhuanlan.zhihu.com/p/352723802\">具体原理涉及汇编，有基础的话可参考这篇文章</a>），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。</p>\n<blockquote>\n<p>实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用<code>toFixed</code>方法对数字显式地进行格式化</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floatNum1 = <span class=\"number\">1.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum2 = <span class=\"number\">.2</span> <span class=\"comment\">// 小数点前可以不需要整数，但这种做法并不推荐</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum3 = <span class=\"number\">3.000</span> <span class=\"comment\">// 会被当作整数3处理</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"精度丢失问题（0-1-0-2-x3D-x3D-0-3）\"><a href=\"#精度丢失问题（0-1-0-2-x3D-x3D-0-3）\" class=\"headerlink\" title=\"精度丢失问题（0.1+0.2 !&#x3D;&#x3D; 0.3）\"></a>精度丢失问题（0.1+0.2 !&#x3D;&#x3D; 0.3）</h2><p>造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6\">二进制</a>转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式<a href=\"https://zh.wikipedia.org/wiki/IEEE_754\">IEEE 754</a> 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。</p>\n<blockquote>\n<p>虽然存在一位用于表示符号，但是<code>+0</code>与<code>-0</code>在 JavaScript 中被认为是相等的，但可以使用<code>Object.is()</code>方法可以判断<code>+0</code>与<code>-0</code>不相等，此为特殊情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">+<span class=\"number\">0</span> === -<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span>+<span class=\"number\">0.2</span> <span class=\"comment\">// 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该数字转换为二进制后存在53位，超出范围</span></span><br><span class=\"line\"><span class=\"number\">9999999999999999</span> <span class=\"comment\">// 10000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<p>并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。</p>\n<h2 id=\"使用科学计数法表示\"><a href=\"#使用科学计数法表示\" class=\"headerlink\" title=\"使用科学计数法表示\"></a>使用科学计数法表示</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用科学计数法</span></span><br><span class=\"line\"><span class=\"number\">1e2</span> === <span class=\"number\">100</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">1e-3</span> === <span class=\"number\">0.001</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二进制，八进制与十六进制\"><a href=\"#二进制，八进制与十六进制\" class=\"headerlink\" title=\"二进制，八进制与十六进制\"></a>二进制，八进制与十六进制</h2><p>javaScript 中默认支持这三种进制的写法，其他进制可以通过方法<code>parseInt</code>转换</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不正确的进制表示会报语法错误</span></span><br><span class=\"line\"><span class=\"comment\">// 二进制数字每位只能是1或0</span></span><br><span class=\"line\">0b103 <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同进制的数字在进行数学操作时都会被视作为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">0b101</span>+<span class=\"number\">017</span> === <span class=\"number\">20</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> + <span class=\"number\">0o377</span> === <span class=\"number\">510</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制 使用0b前缀</span></span><br><span class=\"line\"><span class=\"number\">0b101</span> === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制 使用0o前缀</span></span><br><span class=\"line\"><span class=\"number\">0o17</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非严格模式下可以使用前缀0来表示八进制（不推荐）</span></span><br><span class=\"line\"><span class=\"number\">017</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">019</span> === <span class=\"number\">19</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制 使用0x前缀</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> === <span class=\"number\">255</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 大小写不会造成影响</span></span><br><span class=\"line\"><span class=\"number\">0xfF</span> === <span class=\"number\">0xff</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><blockquote>\n<p>不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6.</span><span class=\"title function_\">toString</span>() <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">0xfe</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;254&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"number\">20</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">20.</span>.<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toString-base\"><a href=\"#num-toString-base\" class=\"headerlink\" title=\"num.toString(base)\"></a><strong>num.toString(base)</strong></h3><p>将数字转换为字符串，参数<code>base</code>表示需要转换的进制，默认值为 10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转换为二进制</span></span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"title function_\">toString</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;10&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制转换为十六进制</span></span><br><span class=\"line\">(<span class=\"number\">0o377</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>) === <span class=\"string\">&#x27;ff&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toFixed-digits\"><a href=\"#num-toFixed-digits\" class=\"headerlink\" title=\"num.toFixed(digits)\"></a><strong>num.toFixed(digits)</strong></h3><p>格式化数字，返回字符串。参数<code>digits</code>表示需要保留几位小数。该方法会对数字进行四舍五入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保留小数点后3位</span></span><br><span class=\"line\"><span class=\"number\">1.23</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;1.230&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 保留小数点后2位</span></span><br><span class=\"line\"><span class=\"number\">1.256</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;1.26&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>注意 toFixed 方法同样存在精度丢失的问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果小数部分是一个无限的二进制,存储会造成精度损失</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 1.35000000000000008882</span></span><br><span class=\"line\"><span class=\"number\">1.55</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;1.6&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 6.34999999999999964473</span></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;6.3&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 等操作完后再进行还原</span></span><br><span class=\"line\">(<span class=\"number\">6.35</span> * <span class=\"number\">10</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 63.50000000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isNaN-value\"><a href=\"#isNaN-value\" class=\"headerlink\" title=\"isNaN(value)\"></a><strong>isNaN(value)</strong></h3><p>判断一个值是否为 NaN</p>\n<blockquote>\n<p>注意<code>NaN === NaN</code>的比较结果为<code>false</code>，这是因为<code>NaN</code>是独一无二的，它不等于任何东西，这也是<code>isNaN</code>方法存在的意义。不过，使用<code>Object.is()</code>方法同样可以判断是否为<code>NaN</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">12</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此处发生了类型的隐式转换</span></span><br><span class=\"line\"><span class=\"comment\">// 如果参数不是数字，会尝试将参数转换为数值</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;11&#x27;</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;ab&#x27;</span>) === <span class=\"literal\">true</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Object.is()方法判断</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(<span class=\"title class_\">NaN</span>, <span class=\"title class_\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isFinite-value\"><a href=\"#isFinite-value\" class=\"headerlink\" title=\"isFinite(value)\"></a><strong>isFinite(value)</strong></h3><p>判断传入的数字是否为有限数字，参数是  <code>NaN</code>、正无穷大或者负无穷大，会返回<code>false</code>，其他返回  <code>true</code>。</p>\n<h3 id=\"parseInt-string-radix\"><a href=\"#parseInt-string-radix\" class=\"headerlink\" title=\"parseInt(string, radix)\"></a><strong>parseInt(string, radix)</strong></h3><h3 id=\"parseFloat-string-radix\"><a href=\"#parseFloat-string-radix\" class=\"headerlink\" title=\"parseFloat(string, radix)\"></a><strong>parseFloat(string, radix)</strong></h3><p>将字符串强制转换为十进制数字。参数<code>string</code>表示需要解析的字符串，<code>radix</code>表示解析时采用什么进制，有效范围为<code>2到36</code>。</p>\n<p>不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回<code>NaN</code>。</p>\n<p>第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回<code>NaN</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果第一个字符不能转换为数字，则直接返回NaN</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到其他进制的数字会正常解析，如二进制以0b开头等</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;a12&#x27;</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0b101&#x27;</span>) === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直到读取到非数字为止，会转换之前读取到的数字</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;2a1&#x27;</span>) === <span class=\"number\">2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入非有效进制</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">1</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入0时按照十进制解析</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">0</span>) === <span class=\"number\">1.2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3 并非有效的二进制表示</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Number-value\"><a href=\"#Number-value\" class=\"headerlink\" title=\"Number(value)\"></a><strong>Number(value)</strong></h3><p><code>number</code>类型的对象包装器，可以通过<code>Number()</code>构造函数来创建<code>number</code>类型，这个函数的参数<code>value</code>可以为其他类型如<code>stirng</code>、<code>boolean</code>等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：</p>\n<ul>\n<li><code>boolean</code>，<code>true</code>返回<code>1</code>，<code>false</code>返回<code>0</code>。</li>\n<li><code>number</code>，直接返回值。</li>\n<li><code>null</code>，返回<code>0</code>。</li>\n<li><code>undefined</code>，返回<code>NaN</code>。</li>\n<li><code>string</code>，规则如下:<ul>\n<li>字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字</li>\n<li>空字符串返回<code>0</code></li>\n<li>如果字符串中包含其他字符，则直接返回<code>NaN</code>，注意就算是像<code>&#39;12a&#39;</code>这样的值也会返回<code>NaN</code>，这点与<code>parseInt</code>方法中解析规则直到读取到非数字为止不同。</li>\n</ul>\n</li>\n</ul>\n<p>这里已经涉及到<strong>隐式类型转换</strong>，具体的会在之后详细地解释。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之数据类型 —— object","date":"2022-05-06T11:46:33.000Z","cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg","_content":"# object\n\n在JavaScript中，可以认为除了原始类型以外，一切皆为对象。像函数、数组等都是对象的子类型，只是表现形式很像其他语言中单独的类型。所以`typeof`在判断`object`类型的变量时只会返回`object`或`function`，无法做到精确地判断具体是某一子类型。判断具体是哪一子类型时一般会使用`instanceof`来判断，但当页面存在多个`iframe`的时候，它也会失灵。最稳妥的方法是使用`Object.prototype.toString.call(obj)`去判断，这里就不做过多地展开。同样地，由于涉及`object`可以延伸的内容非常的多，如`原型`、`原型链`、`this指向`、`扩展运算符`等，这里只对`object`作一些基础的介绍。\n\n## 创建对象\n\n创建一个对象有两种方式，一是通过构造函数来创建，二是通过字面量创建。\n\n```js\nconst obj1 = new Object(); // 通过构造函数创建\nconst obj2 = {}; // 通过字面量创建\n```\n\n在创建对象的时候可以向其中预置一些属性，也可以在创建后之后添加属性或对属性做出修改。\n\n属性是以键值对的形式存储在对象中，属性的值可以是任意的类型。注意要删除属性的时候需要用关键字`delete`。访问属性可以用`object.key`或是`object['key']`的形式。\n\n```js\nconst user = {\n\tname: 'Joe',\n  age: '20',\n\tintroduce: function() {\n\t\tconsole.log(`name: ${this.name}, age: ${this.age}`)\n\t}\n}\n\nuser.introduce() // name: Joe, age: 20\nuser.age = '19'\nuser.introduce() // name: Joe, age: 19\n\ndelete user.age\nuser.introduce() // name: Joe, age: undefined\n```\n\n## 引用类型与原始类型的区别\n\n在`JavaScript`中，只有原始类型与引用类型，而这两种类型最大的不同在于存储方式上的选择。就像谷歌开发的`V8`引擎在处理垃圾回收时会区别对待占用空间大小不同、存活时间长短不同的对象一样，`JavaScript`对此也作出了抉择。\n\n一般来说，原始值就是最简单的数据，占用的空间较小，使用的频率高；而引用值则是由多个值构成的对象，占用的空间较大，使用的频率相对较低。基于这样的特性通常我们也将原始类型称为简单类型，将引用类型称为复杂类型。\n\n原始类型的值会直接保存在栈内存中，访问原始类型变量的方式是按值访问，也就是说，我们访问到的就是存储在变量中实际的值。而访问引用类型的变量时我们实际上访问到的是对该对象的引用，而并非对象本身，即访问引用类型变量的方式是引用访问。\n\n这样设计的原因就是考虑到了原始类型使用频率高、占用内存空间小的特性，就算直接将值放在内存中也不会影响程序运行时的性能，而且访问起来更快。引用类型往往是由多个值构成，因为使用频率没原始类型那么高，同时占用内存较大，如果直接将值放在内存中会造成程序运行时性能下降。\n\n再深入一点，`JavaScript`中内存空间分为栈与堆，先不讨论栈与堆在数据结构上的特性，只需知道变量都是放在栈中，对于原始类型来说，存放的就是实际的值；对于引用类型来说，存放的是指向实际对象值的地址。\n\n```js\nlet a1 = 1\nlet a2 = true\nlet a3 = '#fff'\nlet a4 = [{x:100}]\nlet a5 = null\n```\n\n存储方式如下图所示\n\n![原始类型与引用类型.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d55eb02b-bd83-4430-8b75-ad5131d5f41c/原始类型与引用类型.png)\n\n## 浅拷贝与深拷贝\n\n使用赋值运算符（`=`）能够直接对变量进行拷贝，包括原始类型的变量与引用类型的变量，但需要注意的是，这里拷贝的是栈中的值。也就是说，在使用赋值运算符时，拷贝原始类型的变量，获取到的时原始类型实际的值；拷贝引用类型的值，获取到的是**指向引用类型实际值的地址**。\n\n对于原始类型来说，因为可以直接获取到实际的值，并不存在所谓的浅拷贝与深拷贝；对于引用类型来说，**浅拷贝**就是直接通过赋值运算符去拷贝引用地址，而不是真实的值；**深拷贝**指的才是完全拷贝了一份引用类型变量的值。\n\n### 浅拷贝\n\n由于通过浅拷贝获取到的是同一个引用地址，所以使用相等运算符（`==`）和严格相等运算符（`===`）来与拷贝前的变量比较时是相等的。\n\n```js\nlet a1 = {x:100}\nlet a2 = a1\na2 == a1 // true\na2 === a1 // true\n```\n\n同时，通过浅拷贝获取的变量在修改原来的对象时，修改的是存在堆中的实际值，而存在栈中的引用地址并没有改变。也就是说，浅拷贝前的变量与浅拷贝后的变量实际指向的对象是同一个，无论哪一个变量去修改对象，另一个变量也能感知到变化。\n\n```js\nlet obj1 = { x:100 }\nlet obj2 = obj1\nobj2.x = 'yahaha'\n\nobj1 == obj2 // true\nobj1 === obj2 // true\n\nobj1.x // 'yahaha'\n```\n\n### 深拷贝\n\n首先明确一点，深拷贝是在堆中另外开辟一块空间来存放拷贝对象的值，其引用地址不一样，是无法使用相等运算符与严格相等运算符来判断两个对象是否真正相等。\n\n深拷贝无法简单地使用赋值运算符来完成，这里讲一个简易的实现深拷贝的思路：\n\n1. 判断传入参数为原始类型还是引用类型，如果是原始类型直接返回；如果是引用类型则继续进行下一步。\n\n```js\n// 暂时忽略 typeof value === 'function' 的情况\nconst isObject = (value) => typeof value === 'object' && value !== null\n```\n\n2. 判断引用类型具体是哪一子类型，根据子类型的特性来采取不同的拷贝方式。\n\n```js\nlet result\n\n// 这里以数组和对象举例\n// 用 Object.prototype.toString.call(value) 可判断对象子类型\nconst isArray = (value) => Array.isArray(value)\nresult = isArray(value) ? [] : {}\n```\n\n3. 通过递归的方式来拷贝其对象属性。\n\n```js\n// 数组和对象都可以用下列方式来进行递归拷贝\nfor(let key in value) {\n\t// 确保属性来自 value 本身而不是原型链\n\t// Object.property.hasOwnProperty() 方法可判断传入的键是否来自对象实例本身\n\tif(value.hasOwnProperty(key)) {\n\t\t\t// 递归拷贝\n\t\t\tresult[key] = deepClone(value[key])\n\t}\n}\n```\n\n当然上述内容有很多不足，如没有考虑循环引用、每一种对象子类型、对象子类型是否可遍历等问题，光是这些细节就可以拿出来单独讲很久，这里只提供一个整体思路。完整的深拷贝学习可以参考`lodash`源码中`deepClone`部分。\n\n```js\nconst isObject = (value) => typeof value === 'object' && value !== null;\nconst isArray = (value) => Array.isArray(value);\n\nconst deepClone = (value) => {\n  if (!isObject(value)) {\n    return value;\n  }\n\n  let result = isArray(value) ? [] : {};\n\n  for (const key in value) {\n    if (value.hasOwnProperty(key)) {\n      result[key] = deepClone(value[key]);\n    }\n  }\n  return result;\n};\n```\n\n## 对象比较\n\n前面提到对象之间无法通过相等运算符或者严格相等运算符来进行比较。这里也提供一个大体的思路以供参考，同样地，完整的对象比较可以参考`lodash`源码的`eqDeep`部分。\n\n```js\nconst isObj = (obj) => typeof obj === 'object' && obj !== null;\nfunction isEqual(obj1, obj2) {\n  // 传入基本类型时直接进行比较\n  if (!isObj(obj1) || !isObj(obj2)) {\n    return obj1 === obj2;\n  }\n  // 判断传入的是否为同一对象\n  if (obj1 === obj2) {\n    return true;\n  }\n  // 判断对象上的key的数量是否一致\n\t// Object.keys() 方法返回传入对象上所有键组成的数组\n  const obj1Keys = Object.keys(obj1);\n  const obj2Keys = Object.keys(obj2);\n  if (obj1Keys !== obj2Keys) {\n    return false;\n  }\n  // 递归比较对象上的键值是否相等\n  for (let key in obj1) {\n    const res = isEqual(obj1[key], obj2[key]);\n    if (!res) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n## for...in\n\n这里单独提一下`for...in`语句，因为这个语句是为了遍历对象属性而生的，需要注意的是该语句在遍历对象属性时，每一次遍历获取的是对象的键，而不是值。`for...in`语句同样也可以用于遍历数组，但是并不推荐。`for...in`不应该用于迭代一个关注索引顺序的 `Array`。\n\n## 方法\n\n对象中的方法分为实例方法与静态方法，其中方法非常多，常用的实例方法有`Object.prototype.hasOwnProperty()`、`Object.prototype.toString()`、`Object.prototype.valueOf()`等，常用的静态方法有`Object.defineProperty()`、`Object.assign()`、`Object.keys()`等，许多方法的使用都是建立在对对象有一定了解的基础之上，会在之后结合具体场景一个个慢慢提到，这里不详细描述。\n\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**MDN Web Docs(https://developer.mozilla.org/)**\n\n**lodash(https://lodash.com/)**\n\n","source":"_posts/js-again-primitive-type-object.md","raw":"---\ntitle: 再学 JS 之数据类型 —— object\ndate: 2022-05-06 19:46:33\ntags: \n  - 数据类型\ncategories: \n  - [前端, JavaScript]\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg\n---\n# object\n\n在JavaScript中，可以认为除了原始类型以外，一切皆为对象。像函数、数组等都是对象的子类型，只是表现形式很像其他语言中单独的类型。所以`typeof`在判断`object`类型的变量时只会返回`object`或`function`，无法做到精确地判断具体是某一子类型。判断具体是哪一子类型时一般会使用`instanceof`来判断，但当页面存在多个`iframe`的时候，它也会失灵。最稳妥的方法是使用`Object.prototype.toString.call(obj)`去判断，这里就不做过多地展开。同样地，由于涉及`object`可以延伸的内容非常的多，如`原型`、`原型链`、`this指向`、`扩展运算符`等，这里只对`object`作一些基础的介绍。\n\n## 创建对象\n\n创建一个对象有两种方式，一是通过构造函数来创建，二是通过字面量创建。\n\n```js\nconst obj1 = new Object(); // 通过构造函数创建\nconst obj2 = {}; // 通过字面量创建\n```\n\n在创建对象的时候可以向其中预置一些属性，也可以在创建后之后添加属性或对属性做出修改。\n\n属性是以键值对的形式存储在对象中，属性的值可以是任意的类型。注意要删除属性的时候需要用关键字`delete`。访问属性可以用`object.key`或是`object['key']`的形式。\n\n```js\nconst user = {\n\tname: 'Joe',\n  age: '20',\n\tintroduce: function() {\n\t\tconsole.log(`name: ${this.name}, age: ${this.age}`)\n\t}\n}\n\nuser.introduce() // name: Joe, age: 20\nuser.age = '19'\nuser.introduce() // name: Joe, age: 19\n\ndelete user.age\nuser.introduce() // name: Joe, age: undefined\n```\n\n## 引用类型与原始类型的区别\n\n在`JavaScript`中，只有原始类型与引用类型，而这两种类型最大的不同在于存储方式上的选择。就像谷歌开发的`V8`引擎在处理垃圾回收时会区别对待占用空间大小不同、存活时间长短不同的对象一样，`JavaScript`对此也作出了抉择。\n\n一般来说，原始值就是最简单的数据，占用的空间较小，使用的频率高；而引用值则是由多个值构成的对象，占用的空间较大，使用的频率相对较低。基于这样的特性通常我们也将原始类型称为简单类型，将引用类型称为复杂类型。\n\n原始类型的值会直接保存在栈内存中，访问原始类型变量的方式是按值访问，也就是说，我们访问到的就是存储在变量中实际的值。而访问引用类型的变量时我们实际上访问到的是对该对象的引用，而并非对象本身，即访问引用类型变量的方式是引用访问。\n\n这样设计的原因就是考虑到了原始类型使用频率高、占用内存空间小的特性，就算直接将值放在内存中也不会影响程序运行时的性能，而且访问起来更快。引用类型往往是由多个值构成，因为使用频率没原始类型那么高，同时占用内存较大，如果直接将值放在内存中会造成程序运行时性能下降。\n\n再深入一点，`JavaScript`中内存空间分为栈与堆，先不讨论栈与堆在数据结构上的特性，只需知道变量都是放在栈中，对于原始类型来说，存放的就是实际的值；对于引用类型来说，存放的是指向实际对象值的地址。\n\n```js\nlet a1 = 1\nlet a2 = true\nlet a3 = '#fff'\nlet a4 = [{x:100}]\nlet a5 = null\n```\n\n存储方式如下图所示\n\n![原始类型与引用类型.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d55eb02b-bd83-4430-8b75-ad5131d5f41c/原始类型与引用类型.png)\n\n## 浅拷贝与深拷贝\n\n使用赋值运算符（`=`）能够直接对变量进行拷贝，包括原始类型的变量与引用类型的变量，但需要注意的是，这里拷贝的是栈中的值。也就是说，在使用赋值运算符时，拷贝原始类型的变量，获取到的时原始类型实际的值；拷贝引用类型的值，获取到的是**指向引用类型实际值的地址**。\n\n对于原始类型来说，因为可以直接获取到实际的值，并不存在所谓的浅拷贝与深拷贝；对于引用类型来说，**浅拷贝**就是直接通过赋值运算符去拷贝引用地址，而不是真实的值；**深拷贝**指的才是完全拷贝了一份引用类型变量的值。\n\n### 浅拷贝\n\n由于通过浅拷贝获取到的是同一个引用地址，所以使用相等运算符（`==`）和严格相等运算符（`===`）来与拷贝前的变量比较时是相等的。\n\n```js\nlet a1 = {x:100}\nlet a2 = a1\na2 == a1 // true\na2 === a1 // true\n```\n\n同时，通过浅拷贝获取的变量在修改原来的对象时，修改的是存在堆中的实际值，而存在栈中的引用地址并没有改变。也就是说，浅拷贝前的变量与浅拷贝后的变量实际指向的对象是同一个，无论哪一个变量去修改对象，另一个变量也能感知到变化。\n\n```js\nlet obj1 = { x:100 }\nlet obj2 = obj1\nobj2.x = 'yahaha'\n\nobj1 == obj2 // true\nobj1 === obj2 // true\n\nobj1.x // 'yahaha'\n```\n\n### 深拷贝\n\n首先明确一点，深拷贝是在堆中另外开辟一块空间来存放拷贝对象的值，其引用地址不一样，是无法使用相等运算符与严格相等运算符来判断两个对象是否真正相等。\n\n深拷贝无法简单地使用赋值运算符来完成，这里讲一个简易的实现深拷贝的思路：\n\n1. 判断传入参数为原始类型还是引用类型，如果是原始类型直接返回；如果是引用类型则继续进行下一步。\n\n```js\n// 暂时忽略 typeof value === 'function' 的情况\nconst isObject = (value) => typeof value === 'object' && value !== null\n```\n\n2. 判断引用类型具体是哪一子类型，根据子类型的特性来采取不同的拷贝方式。\n\n```js\nlet result\n\n// 这里以数组和对象举例\n// 用 Object.prototype.toString.call(value) 可判断对象子类型\nconst isArray = (value) => Array.isArray(value)\nresult = isArray(value) ? [] : {}\n```\n\n3. 通过递归的方式来拷贝其对象属性。\n\n```js\n// 数组和对象都可以用下列方式来进行递归拷贝\nfor(let key in value) {\n\t// 确保属性来自 value 本身而不是原型链\n\t// Object.property.hasOwnProperty() 方法可判断传入的键是否来自对象实例本身\n\tif(value.hasOwnProperty(key)) {\n\t\t\t// 递归拷贝\n\t\t\tresult[key] = deepClone(value[key])\n\t}\n}\n```\n\n当然上述内容有很多不足，如没有考虑循环引用、每一种对象子类型、对象子类型是否可遍历等问题，光是这些细节就可以拿出来单独讲很久，这里只提供一个整体思路。完整的深拷贝学习可以参考`lodash`源码中`deepClone`部分。\n\n```js\nconst isObject = (value) => typeof value === 'object' && value !== null;\nconst isArray = (value) => Array.isArray(value);\n\nconst deepClone = (value) => {\n  if (!isObject(value)) {\n    return value;\n  }\n\n  let result = isArray(value) ? [] : {};\n\n  for (const key in value) {\n    if (value.hasOwnProperty(key)) {\n      result[key] = deepClone(value[key]);\n    }\n  }\n  return result;\n};\n```\n\n## 对象比较\n\n前面提到对象之间无法通过相等运算符或者严格相等运算符来进行比较。这里也提供一个大体的思路以供参考，同样地，完整的对象比较可以参考`lodash`源码的`eqDeep`部分。\n\n```js\nconst isObj = (obj) => typeof obj === 'object' && obj !== null;\nfunction isEqual(obj1, obj2) {\n  // 传入基本类型时直接进行比较\n  if (!isObj(obj1) || !isObj(obj2)) {\n    return obj1 === obj2;\n  }\n  // 判断传入的是否为同一对象\n  if (obj1 === obj2) {\n    return true;\n  }\n  // 判断对象上的key的数量是否一致\n\t// Object.keys() 方法返回传入对象上所有键组成的数组\n  const obj1Keys = Object.keys(obj1);\n  const obj2Keys = Object.keys(obj2);\n  if (obj1Keys !== obj2Keys) {\n    return false;\n  }\n  // 递归比较对象上的键值是否相等\n  for (let key in obj1) {\n    const res = isEqual(obj1[key], obj2[key]);\n    if (!res) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n## for...in\n\n这里单独提一下`for...in`语句，因为这个语句是为了遍历对象属性而生的，需要注意的是该语句在遍历对象属性时，每一次遍历获取的是对象的键，而不是值。`for...in`语句同样也可以用于遍历数组，但是并不推荐。`for...in`不应该用于迭代一个关注索引顺序的 `Array`。\n\n## 方法\n\n对象中的方法分为实例方法与静态方法，其中方法非常多，常用的实例方法有`Object.prototype.hasOwnProperty()`、`Object.prototype.toString()`、`Object.prototype.valueOf()`等，常用的静态方法有`Object.defineProperty()`、`Object.assign()`、`Object.keys()`等，许多方法的使用都是建立在对对象有一定了解的基础之上，会在之后结合具体场景一个个慢慢提到，这里不详细描述。\n\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**MDN Web Docs(https://developer.mozilla.org/)**\n\n**lodash(https://lodash.com/)**\n\n","slug":"js-again-primitive-type-object","published":1,"updated":"2022-05-29T13:27:56.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3re6un80009vuo91vds63uu","content":"<h1 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h1><p>在JavaScript中，可以认为除了原始类型以外，一切皆为对象。像函数、数组等都是对象的子类型，只是表现形式很像其他语言中单独的类型。所以<code>typeof</code>在判断<code>object</code>类型的变量时只会返回<code>object</code>或<code>function</code>，无法做到精确地判断具体是某一子类型。判断具体是哪一子类型时一般会使用<code>instanceof</code>来判断，但当页面存在多个<code>iframe</code>的时候，它也会失灵。最稳妥的方法是使用<code>Object.prototype.toString.call(obj)</code>去判断，这里就不做过多地展开。同样地，由于涉及<code>object</code>可以延伸的内容非常的多，如<code>原型</code>、<code>原型链</code>、<code>this指向</code>、<code>扩展运算符</code>等，这里只对<code>object</code>作一些基础的介绍。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><p>创建一个对象有两种方式，一是通过构造函数来创建，二是通过字面量创建。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 通过构造函数创建</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;; <span class=\"comment\">// 通过字面量创建</span></span><br></pre></td></tr></table></figure>\n\n<p>在创建对象的时候可以向其中预置一些属性，也可以在创建后之后添加属性或对属性做出修改。</p>\n<p>属性是以键值对的形式存储在对象中，属性的值可以是任意的类型。注意要删除属性的时候需要用关键字<code>delete</code>。访问属性可以用<code>object.key</code>或是<code>object[&#39;key&#39;]</code>的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Joe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">&#x27;20&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">introduce</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`name: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>, age: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.age&#125;</span>`</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">user.<span class=\"title function_\">introduce</span>() <span class=\"comment\">// name: Joe, age: 20</span></span><br><span class=\"line\">user.<span class=\"property\">age</span> = <span class=\"string\">&#x27;19&#x27;</span></span><br><span class=\"line\">user.<span class=\"title function_\">introduce</span>() <span class=\"comment\">// name: Joe, age: 19</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> user.<span class=\"property\">age</span></span><br><span class=\"line\">user.<span class=\"title function_\">introduce</span>() <span class=\"comment\">// name: Joe, age: undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引用类型与原始类型的区别\"><a href=\"#引用类型与原始类型的区别\" class=\"headerlink\" title=\"引用类型与原始类型的区别\"></a>引用类型与原始类型的区别</h2><p>在<code>JavaScript</code>中，只有原始类型与引用类型，而这两种类型最大的不同在于存储方式上的选择。就像谷歌开发的<code>V8</code>引擎在处理垃圾回收时会区别对待占用空间大小不同、存活时间长短不同的对象一样，<code>JavaScript</code>对此也作出了抉择。</p>\n<p>一般来说，原始值就是最简单的数据，占用的空间较小，使用的频率高；而引用值则是由多个值构成的对象，占用的空间较大，使用的频率相对较低。基于这样的特性通常我们也将原始类型称为简单类型，将引用类型称为复杂类型。</p>\n<p>原始类型的值会直接保存在栈内存中，访问原始类型变量的方式是按值访问，也就是说，我们访问到的就是存储在变量中实际的值。而访问引用类型的变量时我们实际上访问到的是对该对象的引用，而并非对象本身，即访问引用类型变量的方式是引用访问。</p>\n<p>这样设计的原因就是考虑到了原始类型使用频率高、占用内存空间小的特性，就算直接将值放在内存中也不会影响程序运行时的性能，而且访问起来更快。引用类型往往是由多个值构成，因为使用频率没原始类型那么高，同时占用内存较大，如果直接将值放在内存中会造成程序运行时性能下降。</p>\n<p>再深入一点，<code>JavaScript</code>中内存空间分为栈与堆，先不讨论栈与堆在数据结构上的特性，只需知道变量都是放在栈中，对于原始类型来说，存放的就是实际的值；对于引用类型来说，存放的是指向实际对象值的地址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a1 = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a3 = <span class=\"string\">&#x27;#fff&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a4 = [&#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125;]</span><br><span class=\"line\"><span class=\"keyword\">let</span> a5 = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<p>存储方式如下图所示</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d55eb02b-bd83-4430-8b75-ad5131d5f41c/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png\" alt=\"原始类型与引用类型.png\"></p>\n<h2 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h2><p>使用赋值运算符（<code>=</code>）能够直接对变量进行拷贝，包括原始类型的变量与引用类型的变量，但需要注意的是，这里拷贝的是栈中的值。也就是说，在使用赋值运算符时，拷贝原始类型的变量，获取到的时原始类型实际的值；拷贝引用类型的值，获取到的是<strong>指向引用类型实际值的地址</strong>。</p>\n<p>对于原始类型来说，因为可以直接获取到实际的值，并不存在所谓的浅拷贝与深拷贝；对于引用类型来说，<strong>浅拷贝</strong>就是直接通过赋值运算符去拷贝引用地址，而不是真实的值；<strong>深拷贝</strong>指的才是完全拷贝了一份引用类型变量的值。</p>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>由于通过浅拷贝获取到的是同一个引用地址，所以使用相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）来与拷贝前的变量比较时是相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a1 = &#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = a1</span><br><span class=\"line\">a2 == a1 <span class=\"comment\">// true</span></span><br><span class=\"line\">a2 === a1 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>同时，通过浅拷贝获取的变量在修改原来的对象时，修改的是存在堆中的实际值，而存在栈中的引用地址并没有改变。也就是说，浅拷贝前的变量与浅拷贝后的变量实际指向的对象是同一个，无论哪一个变量去修改对象，另一个变量也能感知到变化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123; <span class=\"attr\">x</span>:<span class=\"number\">100</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = obj1</span><br><span class=\"line\">obj2.<span class=\"property\">x</span> = <span class=\"string\">&#x27;yahaha&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj1 == obj2 <span class=\"comment\">// true</span></span><br><span class=\"line\">obj1 === obj2 <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj1.<span class=\"property\">x</span> <span class=\"comment\">// &#x27;yahaha&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>首先明确一点，深拷贝是在堆中另外开辟一块空间来存放拷贝对象的值，其引用地址不一样，是无法使用相等运算符与严格相等运算符来判断两个对象是否真正相等。</p>\n<p>深拷贝无法简单地使用赋值运算符来完成，这里讲一个简易的实现深拷贝的思路：</p>\n<ol>\n<li>判断传入参数为原始类型还是引用类型，如果是原始类型直接返回；如果是引用类型则继续进行下一步。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂时忽略 typeof value === &#x27;function&#x27; 的情况</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isObject</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value !== <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>判断引用类型具体是哪一子类型，根据子类型的特性来采取不同的拷贝方式。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里以数组和对象举例</span></span><br><span class=\"line\"><span class=\"comment\">// 用 Object.prototype.toString.call(value) 可判断对象子类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isArray</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)</span><br><span class=\"line\">result = <span class=\"title function_\">isArray</span>(value) ? [] : &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过递归的方式来拷贝其对象属性。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组和对象都可以用下列方式来进行递归拷贝</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 确保属性来自 value 本身而不是原型链</span></span><br><span class=\"line\">\t<span class=\"comment\">// Object.property.hasOwnProperty() 方法可判断传入的键是否来自对象实例本身</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(value.<span class=\"title function_\">hasOwnProperty</span>(key)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 递归拷贝</span></span><br><span class=\"line\">\t\t\tresult[key] = <span class=\"title function_\">deepClone</span>(value[key])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然上述内容有很多不足，如没有考虑循环引用、每一种对象子类型、对象子类型是否可遍历等问题，光是这些细节就可以拿出来单独讲很久，这里只提供一个整体思路。完整的深拷贝学习可以参考<code>lodash</code>源码中<code>deepClone</code>部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isObject</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value !== <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isArray</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">deepClone</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"title function_\">isArray</span>(value) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value.<span class=\"title function_\">hasOwnProperty</span>(key)) &#123;</span><br><span class=\"line\">      result[key] = <span class=\"title function_\">deepClone</span>(value[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象比较\"><a href=\"#对象比较\" class=\"headerlink\" title=\"对象比较\"></a>对象比较</h2><p>前面提到对象之间无法通过相等运算符或者严格相等运算符来进行比较。这里也提供一个大体的思路以供参考，同样地，完整的对象比较可以参考<code>lodash</code>源码的<code>eqDeep</code>部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isObj</span> = (<span class=\"params\">obj</span>) =&gt; <span class=\"keyword\">typeof</span> obj === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isEqual</span>(<span class=\"params\">obj1, obj2</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 传入基本类型时直接进行比较</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObj</span>(obj1) || !<span class=\"title function_\">isObj</span>(obj2)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj1 === obj2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断传入的是否为同一对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1 === obj2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断对象上的key的数量是否一致</span></span><br><span class=\"line\">\t<span class=\"comment\">// Object.keys() 方法返回传入对象上所有键组成的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj1Keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj2Keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj2);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1Keys !== obj2Keys) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 递归比较对象上的键值是否相等</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj1) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"title function_\">isEqual</span>(obj1[key], obj2[key]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h2><p>这里单独提一下<code>for...in</code>语句，因为这个语句是为了遍历对象属性而生的，需要注意的是该语句在遍历对象属性时，每一次遍历获取的是对象的键，而不是值。<code>for...in</code>语句同样也可以用于遍历数组，但是并不推荐。<code>for...in</code>不应该用于迭代一个关注索引顺序的 <code>Array</code>。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>对象中的方法分为实例方法与静态方法，其中方法非常多，常用的实例方法有<code>Object.prototype.hasOwnProperty()</code>、<code>Object.prototype.toString()</code>、<code>Object.prototype.valueOf()</code>等，常用的静态方法有<code>Object.defineProperty()</code>、<code>Object.assign()</code>、<code>Object.keys()</code>等，许多方法的使用都是建立在对对象有一定了解的基础之上，会在之后结合具体场景一个个慢慢提到，这里不详细描述。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong>MDN Web Docs(<a href=\"https://developer.mozilla.org/\">https://developer.mozilla.org/</a>)</strong></p>\n<p><strong>lodash(<a href=\"https://lodash.com/\">https://lodash.com/</a>)</strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h1><p>在JavaScript中，可以认为除了原始类型以外，一切皆为对象。像函数、数组等都是对象的子类型，只是表现形式很像其他语言中单独的类型。所以<code>typeof</code>在判断<code>object</code>类型的变量时只会返回<code>object</code>或<code>function</code>，无法做到精确地判断具体是某一子类型。判断具体是哪一子类型时一般会使用<code>instanceof</code>来判断，但当页面存在多个<code>iframe</code>的时候，它也会失灵。最稳妥的方法是使用<code>Object.prototype.toString.call(obj)</code>去判断，这里就不做过多地展开。同样地，由于涉及<code>object</code>可以延伸的内容非常的多，如<code>原型</code>、<code>原型链</code>、<code>this指向</code>、<code>扩展运算符</code>等，这里只对<code>object</code>作一些基础的介绍。</p>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><p>创建一个对象有两种方式，一是通过构造函数来创建，二是通过字面量创建。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 通过构造函数创建</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;; <span class=\"comment\">// 通过字面量创建</span></span><br></pre></td></tr></table></figure>\n\n<p>在创建对象的时候可以向其中预置一些属性，也可以在创建后之后添加属性或对属性做出修改。</p>\n<p>属性是以键值对的形式存储在对象中，属性的值可以是任意的类型。注意要删除属性的时候需要用关键字<code>delete</code>。访问属性可以用<code>object.key</code>或是<code>object[&#39;key&#39;]</code>的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Joe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"string\">&#x27;20&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">introduce</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`name: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.name&#125;</span>, age: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.age&#125;</span>`</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">user.<span class=\"title function_\">introduce</span>() <span class=\"comment\">// name: Joe, age: 20</span></span><br><span class=\"line\">user.<span class=\"property\">age</span> = <span class=\"string\">&#x27;19&#x27;</span></span><br><span class=\"line\">user.<span class=\"title function_\">introduce</span>() <span class=\"comment\">// name: Joe, age: 19</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> user.<span class=\"property\">age</span></span><br><span class=\"line\">user.<span class=\"title function_\">introduce</span>() <span class=\"comment\">// name: Joe, age: undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引用类型与原始类型的区别\"><a href=\"#引用类型与原始类型的区别\" class=\"headerlink\" title=\"引用类型与原始类型的区别\"></a>引用类型与原始类型的区别</h2><p>在<code>JavaScript</code>中，只有原始类型与引用类型，而这两种类型最大的不同在于存储方式上的选择。就像谷歌开发的<code>V8</code>引擎在处理垃圾回收时会区别对待占用空间大小不同、存活时间长短不同的对象一样，<code>JavaScript</code>对此也作出了抉择。</p>\n<p>一般来说，原始值就是最简单的数据，占用的空间较小，使用的频率高；而引用值则是由多个值构成的对象，占用的空间较大，使用的频率相对较低。基于这样的特性通常我们也将原始类型称为简单类型，将引用类型称为复杂类型。</p>\n<p>原始类型的值会直接保存在栈内存中，访问原始类型变量的方式是按值访问，也就是说，我们访问到的就是存储在变量中实际的值。而访问引用类型的变量时我们实际上访问到的是对该对象的引用，而并非对象本身，即访问引用类型变量的方式是引用访问。</p>\n<p>这样设计的原因就是考虑到了原始类型使用频率高、占用内存空间小的特性，就算直接将值放在内存中也不会影响程序运行时的性能，而且访问起来更快。引用类型往往是由多个值构成，因为使用频率没原始类型那么高，同时占用内存较大，如果直接将值放在内存中会造成程序运行时性能下降。</p>\n<p>再深入一点，<code>JavaScript</code>中内存空间分为栈与堆，先不讨论栈与堆在数据结构上的特性，只需知道变量都是放在栈中，对于原始类型来说，存放的就是实际的值；对于引用类型来说，存放的是指向实际对象值的地址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a1 = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a3 = <span class=\"string\">&#x27;#fff&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a4 = [&#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125;]</span><br><span class=\"line\"><span class=\"keyword\">let</span> a5 = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<p>存储方式如下图所示</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d55eb02b-bd83-4430-8b75-ad5131d5f41c/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png\" alt=\"原始类型与引用类型.png\"></p>\n<h2 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h2><p>使用赋值运算符（<code>=</code>）能够直接对变量进行拷贝，包括原始类型的变量与引用类型的变量，但需要注意的是，这里拷贝的是栈中的值。也就是说，在使用赋值运算符时，拷贝原始类型的变量，获取到的时原始类型实际的值；拷贝引用类型的值，获取到的是<strong>指向引用类型实际值的地址</strong>。</p>\n<p>对于原始类型来说，因为可以直接获取到实际的值，并不存在所谓的浅拷贝与深拷贝；对于引用类型来说，<strong>浅拷贝</strong>就是直接通过赋值运算符去拷贝引用地址，而不是真实的值；<strong>深拷贝</strong>指的才是完全拷贝了一份引用类型变量的值。</p>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>由于通过浅拷贝获取到的是同一个引用地址，所以使用相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）来与拷贝前的变量比较时是相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a1 = &#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a2 = a1</span><br><span class=\"line\">a2 == a1 <span class=\"comment\">// true</span></span><br><span class=\"line\">a2 === a1 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>同时，通过浅拷贝获取的变量在修改原来的对象时，修改的是存在堆中的实际值，而存在栈中的引用地址并没有改变。也就是说，浅拷贝前的变量与浅拷贝后的变量实际指向的对象是同一个，无论哪一个变量去修改对象，另一个变量也能感知到变化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123; <span class=\"attr\">x</span>:<span class=\"number\">100</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = obj1</span><br><span class=\"line\">obj2.<span class=\"property\">x</span> = <span class=\"string\">&#x27;yahaha&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj1 == obj2 <span class=\"comment\">// true</span></span><br><span class=\"line\">obj1 === obj2 <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj1.<span class=\"property\">x</span> <span class=\"comment\">// &#x27;yahaha&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>首先明确一点，深拷贝是在堆中另外开辟一块空间来存放拷贝对象的值，其引用地址不一样，是无法使用相等运算符与严格相等运算符来判断两个对象是否真正相等。</p>\n<p>深拷贝无法简单地使用赋值运算符来完成，这里讲一个简易的实现深拷贝的思路：</p>\n<ol>\n<li>判断传入参数为原始类型还是引用类型，如果是原始类型直接返回；如果是引用类型则继续进行下一步。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂时忽略 typeof value === &#x27;function&#x27; 的情况</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isObject</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value !== <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>判断引用类型具体是哪一子类型，根据子类型的特性来采取不同的拷贝方式。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里以数组和对象举例</span></span><br><span class=\"line\"><span class=\"comment\">// 用 Object.prototype.toString.call(value) 可判断对象子类型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isArray</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value)</span><br><span class=\"line\">result = <span class=\"title function_\">isArray</span>(value) ? [] : &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过递归的方式来拷贝其对象属性。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组和对象都可以用下列方式来进行递归拷贝</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 确保属性来自 value 本身而不是原型链</span></span><br><span class=\"line\">\t<span class=\"comment\">// Object.property.hasOwnProperty() 方法可判断传入的键是否来自对象实例本身</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(value.<span class=\"title function_\">hasOwnProperty</span>(key)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 递归拷贝</span></span><br><span class=\"line\">\t\t\tresult[key] = <span class=\"title function_\">deepClone</span>(value[key])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然上述内容有很多不足，如没有考虑循环引用、每一种对象子类型、对象子类型是否可遍历等问题，光是这些细节就可以拿出来单独讲很久，这里只提供一个整体思路。完整的深拷贝学习可以参考<code>lodash</code>源码中<code>deepClone</code>部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isObject</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; value !== <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isArray</span> = (<span class=\"params\">value</span>) =&gt; <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(value);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">deepClone</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObject</span>(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"title function_\">isArray</span>(value) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value.<span class=\"title function_\">hasOwnProperty</span>(key)) &#123;</span><br><span class=\"line\">      result[key] = <span class=\"title function_\">deepClone</span>(value[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象比较\"><a href=\"#对象比较\" class=\"headerlink\" title=\"对象比较\"></a>对象比较</h2><p>前面提到对象之间无法通过相等运算符或者严格相等运算符来进行比较。这里也提供一个大体的思路以供参考，同样地，完整的对象比较可以参考<code>lodash</code>源码的<code>eqDeep</code>部分。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">isObj</span> = (<span class=\"params\">obj</span>) =&gt; <span class=\"keyword\">typeof</span> obj === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isEqual</span>(<span class=\"params\">obj1, obj2</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 传入基本类型时直接进行比较</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"title function_\">isObj</span>(obj1) || !<span class=\"title function_\">isObj</span>(obj2)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj1 === obj2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断传入的是否为同一对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1 === obj2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断对象上的key的数量是否一致</span></span><br><span class=\"line\">\t<span class=\"comment\">// Object.keys() 方法返回传入对象上所有键组成的数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj1Keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj2Keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj2);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj1Keys !== obj2Keys) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 递归比较对象上的键值是否相等</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj1) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"title function_\">isEqual</span>(obj1[key], obj2[key]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h2><p>这里单独提一下<code>for...in</code>语句，因为这个语句是为了遍历对象属性而生的，需要注意的是该语句在遍历对象属性时，每一次遍历获取的是对象的键，而不是值。<code>for...in</code>语句同样也可以用于遍历数组，但是并不推荐。<code>for...in</code>不应该用于迭代一个关注索引顺序的 <code>Array</code>。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>对象中的方法分为实例方法与静态方法，其中方法非常多，常用的实例方法有<code>Object.prototype.hasOwnProperty()</code>、<code>Object.prototype.toString()</code>、<code>Object.prototype.valueOf()</code>等，常用的静态方法有<code>Object.defineProperty()</code>、<code>Object.assign()</code>、<code>Object.keys()</code>等，许多方法的使用都是建立在对对象有一定了解的基础之上，会在之后结合具体场景一个个慢慢提到，这里不详细描述。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong>MDN Web Docs(<a href=\"https://developer.mozilla.org/\">https://developer.mozilla.org/</a>)</strong></p>\n<p><strong>lodash(<a href=\"https://lodash.com/\">https://lodash.com/</a>)</strong></p>\n"},{"title":"再学 JS 之数据类型 —— string","date":"2022-05-05T11:20:53.000Z","updated":"2022-05-29T13:27:56.538Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# string\n\n在JavaScript中字符串必须被括号包裹，括号包括`''`、`\"\"`、````。其中````为ES6中引入的符号，又被称为模板字符串。\n\n```js\ntypeof 'hello' === 'string'\ntypeof \"true\" === 'string'\ntypeof '' === 'string'\ntypeof `aa` === 'string'\n```\n\n## 单引与双引\n\n单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符`\\n`来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如`\\\\`、`\\'`等。\n\n```js\nlet str = 'hello\n\t\tworld' // Uncaught SyntaxError: Invalid or unexpected token\nstr = '\\\\aa'\nconsole.log(str) // \\aa\n```\n\n在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。\n\n```js\nconst str1 = 'Love\\'s not Time\\'s fool, though rosy lips and cheeks' + \n\t\t\t\t\t\t 'within his bending sickle\\'s compass come;' + \n\t\t\t\t\t\t 'Love alters not with his brief hours and weeks,' +\n\t\t\t\t\t\t 'But bears it out even to the edge of doom.'\n\nconst str2 = 'In faith I do not love thee with mine eyes,\\\nFor they in thee a thousand errors note;'\n```\n\n## 模板字符串\n\n在ES6引入的模板字符串可以视作增强版的字符串，用` `` `包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以`${...}`嵌入JavaScript表达式或变量。\n\n```js\nconst name = 'Tim';\nlet str = `hello, ${name}`\nconsole.log(str) // hello, Tim\n\nconst template\n```\n\n## 不可变值\n\n需要注意的是，string属于原始类型，其值不可变。\n\n```js\nlet str = 'hello';\nconsole.log(str) // hello\n// 可以用str.length来访问字符串的长度\n// 用str[pos]的方式来获取第pos个字符\nstr[0] = 'aaaa' // 无效赋值\nconsole.log(str) // hello\n```\n\n## 常用方法\n\n### str.indexOf(subStr[, pos])\n\n该方法指的是从`str`的`pos`位置开始查找`subStr`，如果能够找到，则返回`subStr`第一次出现的位置；如果未能找到，则返回`-1`。其中第二个参数为可选参数，如果不写的话默认从`0`开始，如果`pos`小于`0`也会从`0`开始查找，大于`str.length`的话会直接返回`-1`。\n\n```js\nlet str = 'hello world'\nconsole.log(str.indexOf('world', 2)) // 6\nconsole.log(str.indexOf('a')) // -1\nconsole.log(str.indexOf('hello', 1)) // -1\nconsole.log(str.indexOf('h', 20)) // -1\n```\n\n另外存在一个现象，当`subStr`的值为`''`时，如果第二个参数`pos`的值在`0`到`str.length`的范围内时，返回值为`pos`，小于`0`返回`0`，大于`str.length`返回`str.length`。\n\n```js\nlet str = 'test'\nconsole.log(str.indexOf('', -2)) // 0\nconsole.log(str.indexOf('', 3)) // 3\nconsole.log(str.indexOf('', 8)) // 4\n```\n\n### str.lastIndexOf(substr[, pos])\n\n与`indexOf`方法类似，只不过该方法查找的是最后一次`substr`出现的位置，同时是从`pos`开始从后往前查找。\n\n```js\n// pos只限制待匹配字符串的开头\nconsole.log('ababab'.lastIndexOf('ab',2)) // 2\n```\n\n### str.charAt(pos)\n\n该方法会返回`str`中位置为`pos`的字符。如果`pos`的值超出了`0`到`str.length-1`的范围则会返回`''`。如果未传入`pos`的话，则默认`pos`为`0`。\n\n```js\nconsole.log('Snow Falling on Cedars'.charAt(5)) // F\n```\n\n### str.substring(start[, end])\n\n该方法在str中截取从`start`的位置到`end`的位置（不包含`end`）的字符。其中第二个参数为可选参数，未传入的话将截取从`start`到`str.length-1`的字符。\n\n如果`start`的值大于`end`，则截取的字符串为从`end`至`start`（不包含`start`）。\n\n其中任一参数的值小于`0`或大于`str.length`的话，会被当作`0`或者`str.length`处理。任一参数的值为`NaN`（包括隐式转换后为`NaN`）的话也会被当作`0`处理。\n\n```js\nlet str = 'The Snows of Kilimanjaro'\n\nconsole.log(str.substring(3,0)) // The\nconsole.log(str.substring({},3)) // The\nconsole.log(str.substring(-2,25)) // The Snows of Kilimanjaro\n```\n\n> MDN文档中提到`substr`方法在将来有可能被移除掉，因为`substring`方法功能类似，所以尽量使用`substring`方法去替代它。\n> \n\n### str.toUpperCase()\n\n### str.toLowerCase()\n\n这两个方法顾名思义，将字符串转换为大写/小写。\n\n```js\nlet str = 'abCdEfG'\nconsole.log(str.toUpperCase()) // ABCDEFG\nconsole.log(str.toLowerCase()) // abcdefg\n```\n\n### str.includes(substr[, pos])\n\n该方法是ES6新加的方法，用来判断`substr`是否包含在`str`中，是的话返回`true`，否则返回`false`。其中`pos`为可选参数，指的是开始查找的位置，未传入的话从`0`开始。\n\n```js\nlet str = 'Kagome To Inuyasha'\nconsole.log(str.includes('Kikyo')) // false\n```\n\n### str.startsWith(substr[, pos])\n\n### str.endsWith(substr[,pos])\n\n这两个也是ES6新加的方法，顾名思义，判断`str`是否以`substr`开头/结尾，是的话返回`true`，否则返回`false`。可选参数`includes`方法中的可选参数是同样的作用，但要注意在`endsWith`中查找的方式与`lastIndexOf`一致。\n\n```js\nlet str = 'We Made a Beautiful Bouquet'\nconsole.log(str.startsWith('We')) // true\nconsole.log(str.endsWith('auti', str.length-10)) // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/js-again-primitive-type-string.md","raw":"---\ntitle: 再学 JS 之数据类型 —— string\ndate: 2022-05-05 19:20:53\nupdated:\ntags: \n\t- 数据类型\ncategories: \n  - [前端, JavaScript]\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# string\n\n在JavaScript中字符串必须被括号包裹，括号包括`''`、`\"\"`、````。其中````为ES6中引入的符号，又被称为模板字符串。\n\n```js\ntypeof 'hello' === 'string'\ntypeof \"true\" === 'string'\ntypeof '' === 'string'\ntypeof `aa` === 'string'\n```\n\n## 单引与双引\n\n单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符`\\n`来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如`\\\\`、`\\'`等。\n\n```js\nlet str = 'hello\n\t\tworld' // Uncaught SyntaxError: Invalid or unexpected token\nstr = '\\\\aa'\nconsole.log(str) // \\aa\n```\n\n在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。\n\n```js\nconst str1 = 'Love\\'s not Time\\'s fool, though rosy lips and cheeks' + \n\t\t\t\t\t\t 'within his bending sickle\\'s compass come;' + \n\t\t\t\t\t\t 'Love alters not with his brief hours and weeks,' +\n\t\t\t\t\t\t 'But bears it out even to the edge of doom.'\n\nconst str2 = 'In faith I do not love thee with mine eyes,\\\nFor they in thee a thousand errors note;'\n```\n\n## 模板字符串\n\n在ES6引入的模板字符串可以视作增强版的字符串，用` `` `包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以`${...}`嵌入JavaScript表达式或变量。\n\n```js\nconst name = 'Tim';\nlet str = `hello, ${name}`\nconsole.log(str) // hello, Tim\n\nconst template\n```\n\n## 不可变值\n\n需要注意的是，string属于原始类型，其值不可变。\n\n```js\nlet str = 'hello';\nconsole.log(str) // hello\n// 可以用str.length来访问字符串的长度\n// 用str[pos]的方式来获取第pos个字符\nstr[0] = 'aaaa' // 无效赋值\nconsole.log(str) // hello\n```\n\n## 常用方法\n\n### str.indexOf(subStr[, pos])\n\n该方法指的是从`str`的`pos`位置开始查找`subStr`，如果能够找到，则返回`subStr`第一次出现的位置；如果未能找到，则返回`-1`。其中第二个参数为可选参数，如果不写的话默认从`0`开始，如果`pos`小于`0`也会从`0`开始查找，大于`str.length`的话会直接返回`-1`。\n\n```js\nlet str = 'hello world'\nconsole.log(str.indexOf('world', 2)) // 6\nconsole.log(str.indexOf('a')) // -1\nconsole.log(str.indexOf('hello', 1)) // -1\nconsole.log(str.indexOf('h', 20)) // -1\n```\n\n另外存在一个现象，当`subStr`的值为`''`时，如果第二个参数`pos`的值在`0`到`str.length`的范围内时，返回值为`pos`，小于`0`返回`0`，大于`str.length`返回`str.length`。\n\n```js\nlet str = 'test'\nconsole.log(str.indexOf('', -2)) // 0\nconsole.log(str.indexOf('', 3)) // 3\nconsole.log(str.indexOf('', 8)) // 4\n```\n\n### str.lastIndexOf(substr[, pos])\n\n与`indexOf`方法类似，只不过该方法查找的是最后一次`substr`出现的位置，同时是从`pos`开始从后往前查找。\n\n```js\n// pos只限制待匹配字符串的开头\nconsole.log('ababab'.lastIndexOf('ab',2)) // 2\n```\n\n### str.charAt(pos)\n\n该方法会返回`str`中位置为`pos`的字符。如果`pos`的值超出了`0`到`str.length-1`的范围则会返回`''`。如果未传入`pos`的话，则默认`pos`为`0`。\n\n```js\nconsole.log('Snow Falling on Cedars'.charAt(5)) // F\n```\n\n### str.substring(start[, end])\n\n该方法在str中截取从`start`的位置到`end`的位置（不包含`end`）的字符。其中第二个参数为可选参数，未传入的话将截取从`start`到`str.length-1`的字符。\n\n如果`start`的值大于`end`，则截取的字符串为从`end`至`start`（不包含`start`）。\n\n其中任一参数的值小于`0`或大于`str.length`的话，会被当作`0`或者`str.length`处理。任一参数的值为`NaN`（包括隐式转换后为`NaN`）的话也会被当作`0`处理。\n\n```js\nlet str = 'The Snows of Kilimanjaro'\n\nconsole.log(str.substring(3,0)) // The\nconsole.log(str.substring({},3)) // The\nconsole.log(str.substring(-2,25)) // The Snows of Kilimanjaro\n```\n\n> MDN文档中提到`substr`方法在将来有可能被移除掉，因为`substring`方法功能类似，所以尽量使用`substring`方法去替代它。\n> \n\n### str.toUpperCase()\n\n### str.toLowerCase()\n\n这两个方法顾名思义，将字符串转换为大写/小写。\n\n```js\nlet str = 'abCdEfG'\nconsole.log(str.toUpperCase()) // ABCDEFG\nconsole.log(str.toLowerCase()) // abcdefg\n```\n\n### str.includes(substr[, pos])\n\n该方法是ES6新加的方法，用来判断`substr`是否包含在`str`中，是的话返回`true`，否则返回`false`。其中`pos`为可选参数，指的是开始查找的位置，未传入的话从`0`开始。\n\n```js\nlet str = 'Kagome To Inuyasha'\nconsole.log(str.includes('Kikyo')) // false\n```\n\n### str.startsWith(substr[, pos])\n\n### str.endsWith(substr[,pos])\n\n这两个也是ES6新加的方法，顾名思义，判断`str`是否以`substr`开头/结尾，是的话返回`true`，否则返回`false`。可选参数`includes`方法中的可选参数是同样的作用，但要注意在`endsWith`中查找的方式与`lastIndexOf`一致。\n\n```js\nlet str = 'We Made a Beautiful Bouquet'\nconsole.log(str.startsWith('We')) // true\nconsole.log(str.endsWith('auti', str.length-10)) // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"js-again-primitive-type-string","published":1,"layout":"post","photos":[],"link":"","_id":"cl3re6una000dvuo9cnsjfgut","content":"<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>在JavaScript中字符串必须被括号包裹，括号包括<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>。其中</code>为ES6中引入的符号，又被称为模板字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;hello&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;true&quot;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">`aa`</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单引与双引\"><a href=\"#单引与双引\" class=\"headerlink\" title=\"单引与双引\"></a>单引与双引</h2><p>单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符<code>\\n</code>来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如<code>\\\\</code>、<code>\\&#39;</code>等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello</span></span><br><span class=\"line\"><span class=\"string\">\t\tworld&#x27;</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\">str = <span class=\"string\">&#x27;\\\\aa&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// \\aa</span></span><br></pre></td></tr></table></figure>\n\n<p>在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str1 = <span class=\"string\">&#x27;Love\\&#x27;s not Time\\&#x27;s fool, though rosy lips and cheeks&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;within his bending sickle\\&#x27;s compass come;&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;Love alters not with his brief hours and weeks,&#x27;</span> +</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;But bears it out even to the edge of doom.&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> str2 = <span class=\"string\">&#x27;In faith I do not love thee with mine eyes,\\</span></span><br><span class=\"line\"><span class=\"string\">For they in thee a thousand errors note;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>在ES6引入的模板字符串可以视作增强版的字符串，用<code>``</code>包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以<code>$&#123;...&#125;</code>嵌入JavaScript表达式或变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;Tim&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">`hello, <span class=\"subst\">$&#123;name&#125;</span>`</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello, Tim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> template</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不可变值\"><a href=\"#不可变值\" class=\"headerlink\" title=\"不可变值\"></a>不可变值</h2><p>需要注意的是，string属于原始类型，其值不可变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// 可以用str.length来访问字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 用str[pos]的方式来获取第pos个字符</span></span><br><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"comment\">// 无效赋值</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"str-indexOf-subStr-pos\"><a href=\"#str-indexOf-subStr-pos\" class=\"headerlink\" title=\"str.indexOf(subStr[, pos])\"></a>str.indexOf(subStr[, pos])</h3><p>该方法指的是从<code>str</code>的<code>pos</code>位置开始查找<code>subStr</code>，如果能够找到，则返回<code>subStr</code>第一次出现的位置；如果未能找到，则返回<code>-1</code>。其中第二个参数为可选参数，如果不写的话默认从<code>0</code>开始，如果<code>pos</code>小于<code>0</code>也会从<code>0</code>开始查找，大于<code>str.length</code>的话会直接返回<code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;world&#x27;</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;a&#x27;</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"number\">20</span>)) <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>另外存在一个现象，当<code>subStr</code>的值为<code>&#39;&#39;</code>时，如果第二个参数<code>pos</code>的值在<code>0</code>到<code>str.length</code>的范围内时，返回值为<code>pos</code>，小于<code>0</code>返回<code>0</code>，大于<code>str.length</code>返回<code>str.length</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;test&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, -<span class=\"number\">2</span>)) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>)) <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-lastIndexOf-substr-pos\"><a href=\"#str-lastIndexOf-substr-pos\" class=\"headerlink\" title=\"str.lastIndexOf(substr[, pos])\"></a>str.lastIndexOf(substr[, pos])</h3><p>与<code>indexOf</code>方法类似，只不过该方法查找的是最后一次<code>substr</code>出现的位置，同时是从<code>pos</code>开始从后往前查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pos只限制待匹配字符串的开头</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ababab&#x27;</span>.<span class=\"title function_\">lastIndexOf</span>(<span class=\"string\">&#x27;ab&#x27;</span>,<span class=\"number\">2</span>)) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-charAt-pos\"><a href=\"#str-charAt-pos\" class=\"headerlink\" title=\"str.charAt(pos)\"></a>str.charAt(pos)</h3><p>该方法会返回<code>str</code>中位置为<code>pos</code>的字符。如果<code>pos</code>的值超出了<code>0</code>到<code>str.length-1</code>的范围则会返回<code>&#39;&#39;</code>。如果未传入<code>pos</code>的话，则默认<code>pos</code>为<code>0</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Snow Falling on Cedars&#x27;</span>.<span class=\"title function_\">charAt</span>(<span class=\"number\">5</span>)) <span class=\"comment\">// F</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-substring-start-end\"><a href=\"#str-substring-start-end\" class=\"headerlink\" title=\"str.substring(start[, end])\"></a>str.substring(start[, end])</h3><p>该方法在str中截取从<code>start</code>的位置到<code>end</code>的位置（不包含<code>end</code>）的字符。其中第二个参数为可选参数，未传入的话将截取从<code>start</code>到<code>str.length-1</code>的字符。</p>\n<p>如果<code>start</code>的值大于<code>end</code>，则截取的字符串为从<code>end</code>至<code>start</code>（不包含<code>start</code>）。</p>\n<p>其中任一参数的值小于<code>0</code>或大于<code>str.length</code>的话，会被当作<code>0</code>或者<code>str.length</code>处理。任一参数的值为<code>NaN</code>（包括隐式转换后为<code>NaN</code>）的话也会被当作<code>0</code>处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;The Snows of Kilimanjaro&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(<span class=\"number\">3</span>,<span class=\"number\">0</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(&#123;&#125;,<span class=\"number\">3</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(-<span class=\"number\">2</span>,<span class=\"number\">25</span>)) <span class=\"comment\">// The Snows of Kilimanjaro</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MDN文档中提到<code>substr</code>方法在将来有可能被移除掉，因为<code>substring</code>方法功能类似，所以尽量使用<code>substring</code>方法去替代它。</p>\n</blockquote>\n<h3 id=\"str-toUpperCase\"><a href=\"#str-toUpperCase\" class=\"headerlink\" title=\"str.toUpperCase()\"></a>str.toUpperCase()</h3><h3 id=\"str-toLowerCase\"><a href=\"#str-toLowerCase\" class=\"headerlink\" title=\"str.toLowerCase()\"></a>str.toLowerCase()</h3><p>这两个方法顾名思义，将字符串转换为大写&#x2F;小写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abCdEfG&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toUpperCase</span>()) <span class=\"comment\">// ABCDEFG</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toLowerCase</span>()) <span class=\"comment\">// abcdefg</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-includes-substr-pos\"><a href=\"#str-includes-substr-pos\" class=\"headerlink\" title=\"str.includes(substr[, pos])\"></a>str.includes(substr[, pos])</h3><p>该方法是ES6新加的方法，用来判断<code>substr</code>是否包含在<code>str</code>中，是的话返回<code>true</code>，否则返回<code>false</code>。其中<code>pos</code>为可选参数，指的是开始查找的位置，未传入的话从<code>0</code>开始。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Kagome To Inuyasha&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">includes</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-startsWith-substr-pos\"><a href=\"#str-startsWith-substr-pos\" class=\"headerlink\" title=\"str.startsWith(substr[, pos])\"></a>str.startsWith(substr[, pos])</h3><h3 id=\"str-endsWith-substr-pos\"><a href=\"#str-endsWith-substr-pos\" class=\"headerlink\" title=\"str.endsWith(substr[,pos])\"></a>str.endsWith(substr[,pos])</h3><p>这两个也是ES6新加的方法，顾名思义，判断<code>str</code>是否以<code>substr</code>开头&#x2F;结尾，是的话返回<code>true</code>，否则返回<code>false</code>。可选参数<code>includes</code>方法中的可选参数是同样的作用，但要注意在<code>endsWith</code>中查找的方式与<code>lastIndexOf</code>一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;We Made a Beautiful Bouquet&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;We&#x27;</span>)) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">endsWith</span>(<span class=\"string\">&#x27;auti&#x27;</span>, str.<span class=\"property\">length</span>-<span class=\"number\">10</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>在JavaScript中字符串必须被括号包裹，括号包括<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>。其中</code>为ES6中引入的符号，又被称为模板字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;hello&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;true&quot;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">`aa`</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单引与双引\"><a href=\"#单引与双引\" class=\"headerlink\" title=\"单引与双引\"></a>单引与双引</h2><p>单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符<code>\\n</code>来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如<code>\\\\</code>、<code>\\&#39;</code>等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello</span></span><br><span class=\"line\"><span class=\"string\">\t\tworld&#x27;</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\">str = <span class=\"string\">&#x27;\\\\aa&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// \\aa</span></span><br></pre></td></tr></table></figure>\n\n<p>在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str1 = <span class=\"string\">&#x27;Love\\&#x27;s not Time\\&#x27;s fool, though rosy lips and cheeks&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;within his bending sickle\\&#x27;s compass come;&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;Love alters not with his brief hours and weeks,&#x27;</span> +</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;But bears it out even to the edge of doom.&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> str2 = <span class=\"string\">&#x27;In faith I do not love thee with mine eyes,\\</span></span><br><span class=\"line\"><span class=\"string\">For they in thee a thousand errors note;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>在ES6引入的模板字符串可以视作增强版的字符串，用<code>``</code>包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以<code>$&#123;...&#125;</code>嵌入JavaScript表达式或变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;Tim&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">`hello, <span class=\"subst\">$&#123;name&#125;</span>`</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello, Tim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> template</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不可变值\"><a href=\"#不可变值\" class=\"headerlink\" title=\"不可变值\"></a>不可变值</h2><p>需要注意的是，string属于原始类型，其值不可变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// 可以用str.length来访问字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 用str[pos]的方式来获取第pos个字符</span></span><br><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"comment\">// 无效赋值</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"str-indexOf-subStr-pos\"><a href=\"#str-indexOf-subStr-pos\" class=\"headerlink\" title=\"str.indexOf(subStr[, pos])\"></a>str.indexOf(subStr[, pos])</h3><p>该方法指的是从<code>str</code>的<code>pos</code>位置开始查找<code>subStr</code>，如果能够找到，则返回<code>subStr</code>第一次出现的位置；如果未能找到，则返回<code>-1</code>。其中第二个参数为可选参数，如果不写的话默认从<code>0</code>开始，如果<code>pos</code>小于<code>0</code>也会从<code>0</code>开始查找，大于<code>str.length</code>的话会直接返回<code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;world&#x27;</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;a&#x27;</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"number\">20</span>)) <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>另外存在一个现象，当<code>subStr</code>的值为<code>&#39;&#39;</code>时，如果第二个参数<code>pos</code>的值在<code>0</code>到<code>str.length</code>的范围内时，返回值为<code>pos</code>，小于<code>0</code>返回<code>0</code>，大于<code>str.length</code>返回<code>str.length</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;test&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, -<span class=\"number\">2</span>)) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>)) <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-lastIndexOf-substr-pos\"><a href=\"#str-lastIndexOf-substr-pos\" class=\"headerlink\" title=\"str.lastIndexOf(substr[, pos])\"></a>str.lastIndexOf(substr[, pos])</h3><p>与<code>indexOf</code>方法类似，只不过该方法查找的是最后一次<code>substr</code>出现的位置，同时是从<code>pos</code>开始从后往前查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pos只限制待匹配字符串的开头</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ababab&#x27;</span>.<span class=\"title function_\">lastIndexOf</span>(<span class=\"string\">&#x27;ab&#x27;</span>,<span class=\"number\">2</span>)) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-charAt-pos\"><a href=\"#str-charAt-pos\" class=\"headerlink\" title=\"str.charAt(pos)\"></a>str.charAt(pos)</h3><p>该方法会返回<code>str</code>中位置为<code>pos</code>的字符。如果<code>pos</code>的值超出了<code>0</code>到<code>str.length-1</code>的范围则会返回<code>&#39;&#39;</code>。如果未传入<code>pos</code>的话，则默认<code>pos</code>为<code>0</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Snow Falling on Cedars&#x27;</span>.<span class=\"title function_\">charAt</span>(<span class=\"number\">5</span>)) <span class=\"comment\">// F</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-substring-start-end\"><a href=\"#str-substring-start-end\" class=\"headerlink\" title=\"str.substring(start[, end])\"></a>str.substring(start[, end])</h3><p>该方法在str中截取从<code>start</code>的位置到<code>end</code>的位置（不包含<code>end</code>）的字符。其中第二个参数为可选参数，未传入的话将截取从<code>start</code>到<code>str.length-1</code>的字符。</p>\n<p>如果<code>start</code>的值大于<code>end</code>，则截取的字符串为从<code>end</code>至<code>start</code>（不包含<code>start</code>）。</p>\n<p>其中任一参数的值小于<code>0</code>或大于<code>str.length</code>的话，会被当作<code>0</code>或者<code>str.length</code>处理。任一参数的值为<code>NaN</code>（包括隐式转换后为<code>NaN</code>）的话也会被当作<code>0</code>处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;The Snows of Kilimanjaro&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(<span class=\"number\">3</span>,<span class=\"number\">0</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(&#123;&#125;,<span class=\"number\">3</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(-<span class=\"number\">2</span>,<span class=\"number\">25</span>)) <span class=\"comment\">// The Snows of Kilimanjaro</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MDN文档中提到<code>substr</code>方法在将来有可能被移除掉，因为<code>substring</code>方法功能类似，所以尽量使用<code>substring</code>方法去替代它。</p>\n</blockquote>\n<h3 id=\"str-toUpperCase\"><a href=\"#str-toUpperCase\" class=\"headerlink\" title=\"str.toUpperCase()\"></a>str.toUpperCase()</h3><h3 id=\"str-toLowerCase\"><a href=\"#str-toLowerCase\" class=\"headerlink\" title=\"str.toLowerCase()\"></a>str.toLowerCase()</h3><p>这两个方法顾名思义，将字符串转换为大写&#x2F;小写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abCdEfG&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toUpperCase</span>()) <span class=\"comment\">// ABCDEFG</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toLowerCase</span>()) <span class=\"comment\">// abcdefg</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-includes-substr-pos\"><a href=\"#str-includes-substr-pos\" class=\"headerlink\" title=\"str.includes(substr[, pos])\"></a>str.includes(substr[, pos])</h3><p>该方法是ES6新加的方法，用来判断<code>substr</code>是否包含在<code>str</code>中，是的话返回<code>true</code>，否则返回<code>false</code>。其中<code>pos</code>为可选参数，指的是开始查找的位置，未传入的话从<code>0</code>开始。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Kagome To Inuyasha&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">includes</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-startsWith-substr-pos\"><a href=\"#str-startsWith-substr-pos\" class=\"headerlink\" title=\"str.startsWith(substr[, pos])\"></a>str.startsWith(substr[, pos])</h3><h3 id=\"str-endsWith-substr-pos\"><a href=\"#str-endsWith-substr-pos\" class=\"headerlink\" title=\"str.endsWith(substr[,pos])\"></a>str.endsWith(substr[,pos])</h3><p>这两个也是ES6新加的方法，顾名思义，判断<code>str</code>是否以<code>substr</code>开头&#x2F;结尾，是的话返回<code>true</code>，否则返回<code>false</code>。可选参数<code>includes</code>方法中的可选参数是同样的作用，但要注意在<code>endsWith</code>中查找的方式与<code>lastIndexOf</code>一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;We Made a Beautiful Bouquet&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;We&#x27;</span>)) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">endsWith</span>(<span class=\"string\">&#x27;auti&#x27;</span>, str.<span class=\"property\">length</span>-<span class=\"number\">10</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学JS之类型转换","date":"2022-05-07T01:26:11.000Z","cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg","_content":"# 类型转换\n\nJavaScript中类型转换分为显式类型转换和隐式类型转换，顾名思义，显式类型转换指的是直接调用类型转换的方法来进行类型转换，如使用`Number()`、`parseInt()`、`parseFloat()`方法来将其他类型的值转换为`number`类型；隐式类型转换指虽然没有直接使用显示类型转换的方法来进行类型转换，但是根据JS中的规则会自动进行类型转换。从另一个角度来说，只要掌握了类型转换的规则，知道如何触发隐式类型转换，隐式类型转换也可以视作为显式类型转换。\n\n## 类型转换方法（显式类型转换）\n\n常见的类型转换方法有`Number()`、`String()`、`Boolean()`、`parseInt()`、`parseFloat()`、`toString()`。\n\n这些方法分别会尝试将传入的参数转换为`number`、`string`、`boolean`类型的值。\n\n每个方法都有自己的转换规则，其中大部分规则也会应用到隐式类型转换上，少部分方法的转换会有一些差异，如`parseInt()`方法解析字符串`123ads`时会得到结果`123`，而`Number()`方法会得到`NaN`。\n\n## 类型转换规则\n\n### 对象-原始值转换\n\nJS中进行对象转换为原始值时会根据所处的情况即上下文进行推断需要转换为什么类型的原始值，`hint`指的就是推断的结果。\n\n`hint`一共有三种值，分别是`\"string\"`、`\"number\"`、`\"default\"`。当JS无法确定推断上下文情况时会采用`\"default\"`来处理。\n\n```js\nlet obj = {x:100}\n\n// hint 为 \"string\"\nalert(obj)\n\n// hint 为 \"number\"\nNumber(obj)\n\n// hint 为 \"default\"\nobj == '100'\n```\n\n`Symbol.toPrimitive`是一个JS中内置的`Symbol`值，它可以作为对象中的一个默认函数属性存在，当一个对象转换为对应的原始值时，会将`hint`作为参数传入并调用此函数（如果该函数存在的话）。\n\n```js\nconst obj = {\n  [Symbol.toPrimitive](hint) {\n\t\tconsole.log(hint)\n    if (hint === \"number\") {\n      return 47;\n    }\n    if (hint === \"string\") {\n      return \"hi\";\n    }\n    return true;\n  }\n};\n\nalert(obj) // string\n+obj // number\nobj == '47' // default\n```\n\n当`Symbol.toPrimitive`不存在时，JS会寻找对象上的`toString()`方法和`valueOf()`方法来进行转换，方法的调用优先级会根据`hint`的值来判断：\n\n- `\"string\"`，优先使用`toString()`方法，如果该方法返回的值不是基本值的话，则使用`valueOf()`方法。\n- `\"number\" || \"default\"`，优先使用`valueOf()`方法，如果该方法返回的值不是原始值，则再使用`toString()`方法。\n\n对象默认的`toString()`方法会返回`\"[object Object]\"`，而`valueOf()`方法返回对象本身，但JavaScript的许多内置对象都重写了`valueOf()`方法，以实现更适合自身的功能需要。具体可[点击这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)参考MDN文档。\n\n总结一下，对象转换到原始值主要分为三步：\n\n1. 推断`hint`的值。\n2. 如果对象上存在`Symbol.toPrimitive`，则调用该函数处理转换。\n3. 如果对象上不存在`Symbol.toPrimitive`，则根据`hint`的值来调用`toString()`或`valueOf()`方法来处理转换。\n\n从之前提到的方法可以看出类型转换最终的结果是`number`、`string`、`boolean`这三种类型之一。知道了对象是如何转换为原始值之后，下面就开始讲解其他类型是如何转换为这三种类型的。\n\n### 转换为 number\n\n**boolean**\n\n- true → 1\n- false → 0\n\n**undefined**\n\n- undefined → NaN\n\n**null**\n\n- null → 0\n\n**symbol**\n\n- 转换不了，会抛出异常`Uncaught TypeError: Cannot convert a Symbol value to a number`\n\n**bigInt**\n\n- 字面量形式定义 → 去掉后面的`n`，如`10n → 10`\n- BigInt(value) → value（默认`value`能够转换为数值）\n\n**string**\n\n- 数字字符的字符串\n    - 十进制、带符号的十进制 → 十进制（注意转换时会忽略数值前的0，如Number(`\"0047\"`)会返回`47`）\n    - 浮点值格式 → 浮点值\n    - 十六进制 → 十进制\n- 空字符串 → 0\n- 以上规则不能解析时 → NaN（注意与方法`parseInt`、`parseFloat`的区别）\n\n**object（可参考对象-原始值转换）**\n\n1. 推断`hint`为`\"number\"`。\n2. 如存在`Symbol.toPrimitive`，则调用该函数处理转换。\n3. 如不存在，调用`valueOf()`方法，如果该方法返回的值为原始值的话，则转换结束。\n4. 如`valueOf()`方法的返回值不是原始值的话，继续调用`toString()`方法，如果该方法能成功转换为`string`类型的值，则根据`string → number`的规则再进行转换。\n5. 如果仍未得到原始值，则抛出`TypeError`异常。\n\n### 转换为 string\n\n**number**\n\n- value → 'value'\n\n**boolean**\n\n- true → 'true'\n- false → 'false'\n\n**undefined**\n\n- undefined → 'undefined'\n\n**null**\n\n- null → 'null'\n\n**symbol**\n\n- Symbol(value) → 'Symbol(value)'，如`String(Symbol.iterator)`的返回值为`'Symbol(Symbol.iterator)'`\n- Symbol.for(value)→'Symbol(value)'，如`String(Symbol.for('12'))`的返回值为`'Symbol.for('12')'`\n\n**bigInt**\n\n- 字面量形式定义 → 去掉后面的`n`，再转换为字符串，如`10n → '10'`\n- BigInt(value) → 'value'（默认`value`能够转换为数值）\n\n**object（可参考对象-原始值转换）**\n\n1. 推断`hint`为`\"string\"`。\n2. 如存在`Symbol.toPrimitive`，则调用该函数处理转换。\n3. 如不存在，调用`toString()`方法，如果该方法返回的值为原始值的话，则转换结束。\n4. 如`toString()`方法的返回值不是原始值的话，继续调用`valueOf()`方法，如果该方法能成功转换为原始类型的值，则根据前面的规则再进行转换。\n5. 如果仍未得到原始值，则抛出`TypeError`异常。\n\n### 转换为 boolean\n\n**number**\n\n- 非零数值 → true\n- 0、NaN → false\n\n**string**\n\n- 非空字符串 → true\n- 空字符串'' → false\n\n**undefined**\n\n- undefined → false\n\n**null**\n\n- null → false\n\n**symbol**\n\n- Symbol(value) → true\n- Symbol.for(value) → true\n\n**bigInt**\n\n- 字面量形式定义，去掉后面的`n`然后按 number → boolean 的规则转换\n- BigInt(value)，value → number → boolean\n\n**object**\n\n- 任意对象 → true\n\n## 触发隐式类型转换\n\n在了解了类型转换的规则后，就能清楚地知道显式类型转换的结果，但有时候JS会自动地触发类型转换，这一机制被称为隐式类型转换。一方面它让代码变得晦涩难懂；另一方面，它也能让代码变得更加简洁。\n\n```js\n// 显式类型转换\nString('1')\n// 隐式类型转换\n1+''\n```\n\n### 触发转换为 number\n\n**一元运算符 +**\n\n```js\n+'1' // 1\n+'hello' // NaN\n+null // 0\n+undefined // NaN\n+{} // NaN\n```\n\n**二元运算符 + - * / % += -=（使用 + 运算符时操作数中不存在字符串）**\n\n```js\n// 注意这里的 {} 并不是一个空对象 而是一个代码块\n{} + true // 1\n\n// Uncaught TypeError: Cannot mix BigInt and other types, \n// use explicit conversions\n10n + 10\n\n// 0 除以任何数都得 0 的规则被打破！\n// 与 NaN 的运算结果都会是 NaN\nnull % undefined // NaN\n'' * +{} // NaN\n\n'3.1512' - '0.1' // 3.0511999999999997 （注意这里产生了精度丢失-_—|）\n```\n\n当`+`的其中一个操作数是字符串或对象（转换为原始值时得到字符串）时，将会执行字符串拼接。\n\n```js\n/**\n * 特殊情况，无法转换为number\n * 推断 hint 为 'default'\n * 数组转换为原始值\n * 首先调用valueOf方法，返回数组本身\n * 再调用toString方法\n * 数组的toString被重写，效果相当于调用join(',')\n * 最后再进行字符串拼接\n */\n[1, 2] + [3, 4] // '1,23,4'\n\n/**\n * {} 视为 代码块\n * 原式等同于 +[]\n * 按照一元运算符 + 的规则来\n * 推断 hint 为 'number'\n * 首先调用valueOf方法，返回数组本身\n * 再调用toString方法 返回''\n * '' 转换为 0\n */\n{} + [] // 0\n\n// 这里的 {} 是一个空对象\n[] + {} // '[object Object]' \n```\n\n**比较运算符（> < <= >=）**\n\n```js\n(true > false) // true\n\n// 注意 NaN 的特殊性\n(1 < NaN) // false\n(1 > NaN) // false\n(NaN <= NaN) // false\n```\n\n在比较中也存在被称为”抽象关系比较“的特殊情况，其中又分为比较双方都是字符串和存在`object`类型两种情况，如果是第二种情况，需要先将对象转换为原始值，如果结果中出现非字符串，就强制将比较双方转换为数字来比较。\n\n```js\n// 同样地，根据语法规则， {} 被视为代码块\n({} > []) // Uncaught SyntaxError: Unexpected token '>'\n\n/**\n * 先根据对象 -> 原始值规则进行转换\n * [] 转换为 ''\n * {} 转换为 '[object Object]'\n * 比较双方都是字符串的话按字母顺序来比较\n */\n([] < {}) // true\n```\n\n此外，还需注意`<=` `>=`的处理方式\n\n```js\nlet a = { x: 42 }\nlet b = { y: 43 }\n(a<b) // false\n(a>b) // false\n\n// a>=b 被处理为 b<a 然后反转结果\n(a>=b) // true\n// a<=b 被处理为 b>a 然后反转结果\n(a<=b) //true**逻辑运算符 ！**\n```\n\n### 触发转换为 string\n\n**二元运算符 +（运算元中存在字符串时）**\n\n```js\n1 + '0' // '10'\n+{} + 'true' // 'NaNtrue'\n\ntrue + {} // 'true[object Object]'\n\n```\n\n### 触发转换为 boolean\n\n会触发布尔值隐式转换的情况有以下几种：\n\n- if 语句中的条件判断表达式\n- for 语句中的条件判断表达式\n- while 语句中的条件判断表达式\n- 三元表达式（问号表达式）中的条件判断表达式\n- ||（或）、&&（与）、!（非）\n\n这里有一个小技巧，使用逻辑运算符`!`可以触发布尔值隐式转换并不准确，因为它还额外做了取反的工作，但是使用`!!`取两次反，就能实现`Boolean()`方法的功能，同时在写法上要比`Boolean()`简洁。\n\n```js\nBoolean(1) === !!1 // true\n```\n\n逻辑运算符`||`和`&&`，会将左边的操作数作为条件判断表达式来触发布尔值隐式类型转换。换句话说，`||`和`&&`运算符的返回值不一定是布尔值，而是两个操作数中的其中一个，故它们也被称为选择器运算符。\n\n```js\nundefined && null // undefined\n1 && 2 // 2\n\n0 || 1 // 1\n'' || NaN // NaN\n```\n\n对于`&&`运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回该操作数；如果结果为真，直接返回右边的操作数。\n\n```js\na && b\n// 可以按以下表达式去理解，但两个表达式并不完全相等\na ? b : a\n```\n\n对于`||`运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回右边的操作数；如果结果为真，直接返回该操作数。\n\n```js\na || b\n// 可以按以下表达式去理解，但两个表达式并不完全相等\na ? a : b\n```\n\n在ES5时经常用到这两个运算符来实现一些功能，如使用`||`来实现类似默认参数的功能，使用`&&`来实现类似可选链操作符`?.`的功能。\n\n```js\n// ES5 实现默认参数\nfunction debounce(fn, delay) {\n  delay = delay || 200;\n  let timer = null;\n  return function () {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n      timer = null;\n    }, delay);\n  };\n}\n\n// ES6 做法\nfunction debounce(fn, delay = 200) {\n  let timer = null;\n  return function () {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n      timer = null;\n    }, delay);\n  };\n}\n\nlet data = {\n\tname: 'Joe'\n}\n\n// ES5\nlet name = data && data.name // Joe\n// ES6\nname = data?.name // Joe\n```\n\n## 宽松相等 ==\n\n### 宽松相等 == 与严格相等 ===\n\n在JS中存在宽松相等`==`和严格相等`===`两种等于运算符，它们的区别在于`==`在相等比较过程中当比较双方类型不一致时会先进行类型转换之后再判断；而`===`不会，类型不一致的话直接返回`false`。为了语意清晰，一般会更加推荐使用`===`而不是`==`，但还是有必要了解使用`==`时会发生什么。\n\n> `!=`为宽松不相等，`!==`为严格不相登。\n> \n\n```js\n47 == '0x2f' // true\n47 === '0x2f' // false\n```\n\n### == 的隐式类型转换规则\n\n比较双方类型不一致时，关于`==`的类型转换规则如下：\n\n- 比较双方存在布尔值时，会尝试将布尔值转换为数字再进行比较\n- 比较双方其中一个为字符串一个为数字时，会尝试将字符串转换为数字再进行比较。\n- 比较双方存在一个为原始值，一个为对象时，会先将对象转换为原始值后再进行比较。\n\n注意关于`==`也存在特殊情况，`null`与`undefined`在宽松比较时可以视为相等，这两种类型在遇到其他类型时一律返回`false`（这种情况下使用`==`要比`===`好一些）。\n\n```js\nnull == undefined // true\nnull == null // true\nundefined == undefined // true\n'0' == null // false\n0 == undefined // false\n```\n\n### 一些让人头大的宽松比较\n\n`[] == ![]`\n\n看到以上比较可以自己先思考结果，以下给出转换过程\n\n```js\n/**\n * [] 为对象子类型 \n * ![] 会进行布尔值隐式转换\n *  根据规则 任意对象转换为布尔值都是true\n *  最后再取反 所以 ![] 的结果为 false \n * 根据 == 的转换规则\n * ![] 先转换为 false 再转换为数字 0\n * [] 需要转换为原始值\n *  valueOf方法返回本身 不是原始值\n *  调用toString方法 返回 ''\n *  '' 转换为 0\n *  故最后进行的比较为 0 == 0\n */\n[] == ![] // true\n\n// 类似地\n[47] == 47 // true\n[null] == '' // true\n'ops' == ['ops'] // true\n```\n\n`'true' == true`\n\n同样地，可以自己先思考，以下给出转换过程\n\n```js\n/**\n * 比较双方为字符串与布尔值\n *  布尔值转换为数字\n *    true 转换为 1\n *  字符串转换为数字\n *    'true' 转换为 NaN\n * 最后进行的比较是 NaN == 1\n */\n'true' == true // false\n```\n\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[MDN Web Docs](https://developer.mozilla.org/)**","source":"_posts/js-again-type-conversion.md","raw":"---\ntitle: 再学JS之类型转换\ndate: 2022-05-07 09:26:11\ntags: \n  - 类型转换\ncategories: \n  - [前端, JavaScript]\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg\n---\n# 类型转换\n\nJavaScript中类型转换分为显式类型转换和隐式类型转换，顾名思义，显式类型转换指的是直接调用类型转换的方法来进行类型转换，如使用`Number()`、`parseInt()`、`parseFloat()`方法来将其他类型的值转换为`number`类型；隐式类型转换指虽然没有直接使用显示类型转换的方法来进行类型转换，但是根据JS中的规则会自动进行类型转换。从另一个角度来说，只要掌握了类型转换的规则，知道如何触发隐式类型转换，隐式类型转换也可以视作为显式类型转换。\n\n## 类型转换方法（显式类型转换）\n\n常见的类型转换方法有`Number()`、`String()`、`Boolean()`、`parseInt()`、`parseFloat()`、`toString()`。\n\n这些方法分别会尝试将传入的参数转换为`number`、`string`、`boolean`类型的值。\n\n每个方法都有自己的转换规则，其中大部分规则也会应用到隐式类型转换上，少部分方法的转换会有一些差异，如`parseInt()`方法解析字符串`123ads`时会得到结果`123`，而`Number()`方法会得到`NaN`。\n\n## 类型转换规则\n\n### 对象-原始值转换\n\nJS中进行对象转换为原始值时会根据所处的情况即上下文进行推断需要转换为什么类型的原始值，`hint`指的就是推断的结果。\n\n`hint`一共有三种值，分别是`\"string\"`、`\"number\"`、`\"default\"`。当JS无法确定推断上下文情况时会采用`\"default\"`来处理。\n\n```js\nlet obj = {x:100}\n\n// hint 为 \"string\"\nalert(obj)\n\n// hint 为 \"number\"\nNumber(obj)\n\n// hint 为 \"default\"\nobj == '100'\n```\n\n`Symbol.toPrimitive`是一个JS中内置的`Symbol`值，它可以作为对象中的一个默认函数属性存在，当一个对象转换为对应的原始值时，会将`hint`作为参数传入并调用此函数（如果该函数存在的话）。\n\n```js\nconst obj = {\n  [Symbol.toPrimitive](hint) {\n\t\tconsole.log(hint)\n    if (hint === \"number\") {\n      return 47;\n    }\n    if (hint === \"string\") {\n      return \"hi\";\n    }\n    return true;\n  }\n};\n\nalert(obj) // string\n+obj // number\nobj == '47' // default\n```\n\n当`Symbol.toPrimitive`不存在时，JS会寻找对象上的`toString()`方法和`valueOf()`方法来进行转换，方法的调用优先级会根据`hint`的值来判断：\n\n- `\"string\"`，优先使用`toString()`方法，如果该方法返回的值不是基本值的话，则使用`valueOf()`方法。\n- `\"number\" || \"default\"`，优先使用`valueOf()`方法，如果该方法返回的值不是原始值，则再使用`toString()`方法。\n\n对象默认的`toString()`方法会返回`\"[object Object]\"`，而`valueOf()`方法返回对象本身，但JavaScript的许多内置对象都重写了`valueOf()`方法，以实现更适合自身的功能需要。具体可[点击这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)参考MDN文档。\n\n总结一下，对象转换到原始值主要分为三步：\n\n1. 推断`hint`的值。\n2. 如果对象上存在`Symbol.toPrimitive`，则调用该函数处理转换。\n3. 如果对象上不存在`Symbol.toPrimitive`，则根据`hint`的值来调用`toString()`或`valueOf()`方法来处理转换。\n\n从之前提到的方法可以看出类型转换最终的结果是`number`、`string`、`boolean`这三种类型之一。知道了对象是如何转换为原始值之后，下面就开始讲解其他类型是如何转换为这三种类型的。\n\n### 转换为 number\n\n**boolean**\n\n- true → 1\n- false → 0\n\n**undefined**\n\n- undefined → NaN\n\n**null**\n\n- null → 0\n\n**symbol**\n\n- 转换不了，会抛出异常`Uncaught TypeError: Cannot convert a Symbol value to a number`\n\n**bigInt**\n\n- 字面量形式定义 → 去掉后面的`n`，如`10n → 10`\n- BigInt(value) → value（默认`value`能够转换为数值）\n\n**string**\n\n- 数字字符的字符串\n    - 十进制、带符号的十进制 → 十进制（注意转换时会忽略数值前的0，如Number(`\"0047\"`)会返回`47`）\n    - 浮点值格式 → 浮点值\n    - 十六进制 → 十进制\n- 空字符串 → 0\n- 以上规则不能解析时 → NaN（注意与方法`parseInt`、`parseFloat`的区别）\n\n**object（可参考对象-原始值转换）**\n\n1. 推断`hint`为`\"number\"`。\n2. 如存在`Symbol.toPrimitive`，则调用该函数处理转换。\n3. 如不存在，调用`valueOf()`方法，如果该方法返回的值为原始值的话，则转换结束。\n4. 如`valueOf()`方法的返回值不是原始值的话，继续调用`toString()`方法，如果该方法能成功转换为`string`类型的值，则根据`string → number`的规则再进行转换。\n5. 如果仍未得到原始值，则抛出`TypeError`异常。\n\n### 转换为 string\n\n**number**\n\n- value → 'value'\n\n**boolean**\n\n- true → 'true'\n- false → 'false'\n\n**undefined**\n\n- undefined → 'undefined'\n\n**null**\n\n- null → 'null'\n\n**symbol**\n\n- Symbol(value) → 'Symbol(value)'，如`String(Symbol.iterator)`的返回值为`'Symbol(Symbol.iterator)'`\n- Symbol.for(value)→'Symbol(value)'，如`String(Symbol.for('12'))`的返回值为`'Symbol.for('12')'`\n\n**bigInt**\n\n- 字面量形式定义 → 去掉后面的`n`，再转换为字符串，如`10n → '10'`\n- BigInt(value) → 'value'（默认`value`能够转换为数值）\n\n**object（可参考对象-原始值转换）**\n\n1. 推断`hint`为`\"string\"`。\n2. 如存在`Symbol.toPrimitive`，则调用该函数处理转换。\n3. 如不存在，调用`toString()`方法，如果该方法返回的值为原始值的话，则转换结束。\n4. 如`toString()`方法的返回值不是原始值的话，继续调用`valueOf()`方法，如果该方法能成功转换为原始类型的值，则根据前面的规则再进行转换。\n5. 如果仍未得到原始值，则抛出`TypeError`异常。\n\n### 转换为 boolean\n\n**number**\n\n- 非零数值 → true\n- 0、NaN → false\n\n**string**\n\n- 非空字符串 → true\n- 空字符串'' → false\n\n**undefined**\n\n- undefined → false\n\n**null**\n\n- null → false\n\n**symbol**\n\n- Symbol(value) → true\n- Symbol.for(value) → true\n\n**bigInt**\n\n- 字面量形式定义，去掉后面的`n`然后按 number → boolean 的规则转换\n- BigInt(value)，value → number → boolean\n\n**object**\n\n- 任意对象 → true\n\n## 触发隐式类型转换\n\n在了解了类型转换的规则后，就能清楚地知道显式类型转换的结果，但有时候JS会自动地触发类型转换，这一机制被称为隐式类型转换。一方面它让代码变得晦涩难懂；另一方面，它也能让代码变得更加简洁。\n\n```js\n// 显式类型转换\nString('1')\n// 隐式类型转换\n1+''\n```\n\n### 触发转换为 number\n\n**一元运算符 +**\n\n```js\n+'1' // 1\n+'hello' // NaN\n+null // 0\n+undefined // NaN\n+{} // NaN\n```\n\n**二元运算符 + - * / % += -=（使用 + 运算符时操作数中不存在字符串）**\n\n```js\n// 注意这里的 {} 并不是一个空对象 而是一个代码块\n{} + true // 1\n\n// Uncaught TypeError: Cannot mix BigInt and other types, \n// use explicit conversions\n10n + 10\n\n// 0 除以任何数都得 0 的规则被打破！\n// 与 NaN 的运算结果都会是 NaN\nnull % undefined // NaN\n'' * +{} // NaN\n\n'3.1512' - '0.1' // 3.0511999999999997 （注意这里产生了精度丢失-_—|）\n```\n\n当`+`的其中一个操作数是字符串或对象（转换为原始值时得到字符串）时，将会执行字符串拼接。\n\n```js\n/**\n * 特殊情况，无法转换为number\n * 推断 hint 为 'default'\n * 数组转换为原始值\n * 首先调用valueOf方法，返回数组本身\n * 再调用toString方法\n * 数组的toString被重写，效果相当于调用join(',')\n * 最后再进行字符串拼接\n */\n[1, 2] + [3, 4] // '1,23,4'\n\n/**\n * {} 视为 代码块\n * 原式等同于 +[]\n * 按照一元运算符 + 的规则来\n * 推断 hint 为 'number'\n * 首先调用valueOf方法，返回数组本身\n * 再调用toString方法 返回''\n * '' 转换为 0\n */\n{} + [] // 0\n\n// 这里的 {} 是一个空对象\n[] + {} // '[object Object]' \n```\n\n**比较运算符（> < <= >=）**\n\n```js\n(true > false) // true\n\n// 注意 NaN 的特殊性\n(1 < NaN) // false\n(1 > NaN) // false\n(NaN <= NaN) // false\n```\n\n在比较中也存在被称为”抽象关系比较“的特殊情况，其中又分为比较双方都是字符串和存在`object`类型两种情况，如果是第二种情况，需要先将对象转换为原始值，如果结果中出现非字符串，就强制将比较双方转换为数字来比较。\n\n```js\n// 同样地，根据语法规则， {} 被视为代码块\n({} > []) // Uncaught SyntaxError: Unexpected token '>'\n\n/**\n * 先根据对象 -> 原始值规则进行转换\n * [] 转换为 ''\n * {} 转换为 '[object Object]'\n * 比较双方都是字符串的话按字母顺序来比较\n */\n([] < {}) // true\n```\n\n此外，还需注意`<=` `>=`的处理方式\n\n```js\nlet a = { x: 42 }\nlet b = { y: 43 }\n(a<b) // false\n(a>b) // false\n\n// a>=b 被处理为 b<a 然后反转结果\n(a>=b) // true\n// a<=b 被处理为 b>a 然后反转结果\n(a<=b) //true**逻辑运算符 ！**\n```\n\n### 触发转换为 string\n\n**二元运算符 +（运算元中存在字符串时）**\n\n```js\n1 + '0' // '10'\n+{} + 'true' // 'NaNtrue'\n\ntrue + {} // 'true[object Object]'\n\n```\n\n### 触发转换为 boolean\n\n会触发布尔值隐式转换的情况有以下几种：\n\n- if 语句中的条件判断表达式\n- for 语句中的条件判断表达式\n- while 语句中的条件判断表达式\n- 三元表达式（问号表达式）中的条件判断表达式\n- ||（或）、&&（与）、!（非）\n\n这里有一个小技巧，使用逻辑运算符`!`可以触发布尔值隐式转换并不准确，因为它还额外做了取反的工作，但是使用`!!`取两次反，就能实现`Boolean()`方法的功能，同时在写法上要比`Boolean()`简洁。\n\n```js\nBoolean(1) === !!1 // true\n```\n\n逻辑运算符`||`和`&&`，会将左边的操作数作为条件判断表达式来触发布尔值隐式类型转换。换句话说，`||`和`&&`运算符的返回值不一定是布尔值，而是两个操作数中的其中一个，故它们也被称为选择器运算符。\n\n```js\nundefined && null // undefined\n1 && 2 // 2\n\n0 || 1 // 1\n'' || NaN // NaN\n```\n\n对于`&&`运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回该操作数；如果结果为真，直接返回右边的操作数。\n\n```js\na && b\n// 可以按以下表达式去理解，但两个表达式并不完全相等\na ? b : a\n```\n\n对于`||`运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回右边的操作数；如果结果为真，直接返回该操作数。\n\n```js\na || b\n// 可以按以下表达式去理解，但两个表达式并不完全相等\na ? a : b\n```\n\n在ES5时经常用到这两个运算符来实现一些功能，如使用`||`来实现类似默认参数的功能，使用`&&`来实现类似可选链操作符`?.`的功能。\n\n```js\n// ES5 实现默认参数\nfunction debounce(fn, delay) {\n  delay = delay || 200;\n  let timer = null;\n  return function () {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n      timer = null;\n    }, delay);\n  };\n}\n\n// ES6 做法\nfunction debounce(fn, delay = 200) {\n  let timer = null;\n  return function () {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n      timer = null;\n    }, delay);\n  };\n}\n\nlet data = {\n\tname: 'Joe'\n}\n\n// ES5\nlet name = data && data.name // Joe\n// ES6\nname = data?.name // Joe\n```\n\n## 宽松相等 ==\n\n### 宽松相等 == 与严格相等 ===\n\n在JS中存在宽松相等`==`和严格相等`===`两种等于运算符，它们的区别在于`==`在相等比较过程中当比较双方类型不一致时会先进行类型转换之后再判断；而`===`不会，类型不一致的话直接返回`false`。为了语意清晰，一般会更加推荐使用`===`而不是`==`，但还是有必要了解使用`==`时会发生什么。\n\n> `!=`为宽松不相等，`!==`为严格不相登。\n> \n\n```js\n47 == '0x2f' // true\n47 === '0x2f' // false\n```\n\n### == 的隐式类型转换规则\n\n比较双方类型不一致时，关于`==`的类型转换规则如下：\n\n- 比较双方存在布尔值时，会尝试将布尔值转换为数字再进行比较\n- 比较双方其中一个为字符串一个为数字时，会尝试将字符串转换为数字再进行比较。\n- 比较双方存在一个为原始值，一个为对象时，会先将对象转换为原始值后再进行比较。\n\n注意关于`==`也存在特殊情况，`null`与`undefined`在宽松比较时可以视为相等，这两种类型在遇到其他类型时一律返回`false`（这种情况下使用`==`要比`===`好一些）。\n\n```js\nnull == undefined // true\nnull == null // true\nundefined == undefined // true\n'0' == null // false\n0 == undefined // false\n```\n\n### 一些让人头大的宽松比较\n\n`[] == ![]`\n\n看到以上比较可以自己先思考结果，以下给出转换过程\n\n```js\n/**\n * [] 为对象子类型 \n * ![] 会进行布尔值隐式转换\n *  根据规则 任意对象转换为布尔值都是true\n *  最后再取反 所以 ![] 的结果为 false \n * 根据 == 的转换规则\n * ![] 先转换为 false 再转换为数字 0\n * [] 需要转换为原始值\n *  valueOf方法返回本身 不是原始值\n *  调用toString方法 返回 ''\n *  '' 转换为 0\n *  故最后进行的比较为 0 == 0\n */\n[] == ![] // true\n\n// 类似地\n[47] == 47 // true\n[null] == '' // true\n'ops' == ['ops'] // true\n```\n\n`'true' == true`\n\n同样地，可以自己先思考，以下给出转换过程\n\n```js\n/**\n * 比较双方为字符串与布尔值\n *  布尔值转换为数字\n *    true 转换为 1\n *  字符串转换为数字\n *    'true' 转换为 NaN\n * 最后进行的比较是 NaN == 1\n */\n'true' == true // false\n```\n\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[MDN Web Docs](https://developer.mozilla.org/)**","slug":"js-again-type-conversion","published":1,"updated":"2022-05-29T13:27:56.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3re6una000fvuo94eyvdjba","content":"<h1 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h1><p>JavaScript中类型转换分为显式类型转换和隐式类型转换，顾名思义，显式类型转换指的是直接调用类型转换的方法来进行类型转换，如使用<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>方法来将其他类型的值转换为<code>number</code>类型；隐式类型转换指虽然没有直接使用显示类型转换的方法来进行类型转换，但是根据JS中的规则会自动进行类型转换。从另一个角度来说，只要掌握了类型转换的规则，知道如何触发隐式类型转换，隐式类型转换也可以视作为显式类型转换。</p>\n<h2 id=\"类型转换方法（显式类型转换）\"><a href=\"#类型转换方法（显式类型转换）\" class=\"headerlink\" title=\"类型转换方法（显式类型转换）\"></a>类型转换方法（显式类型转换）</h2><p>常见的类型转换方法有<code>Number()</code>、<code>String()</code>、<code>Boolean()</code>、<code>parseInt()</code>、<code>parseFloat()</code>、<code>toString()</code>。</p>\n<p>这些方法分别会尝试将传入的参数转换为<code>number</code>、<code>string</code>、<code>boolean</code>类型的值。</p>\n<p>每个方法都有自己的转换规则，其中大部分规则也会应用到隐式类型转换上，少部分方法的转换会有一些差异，如<code>parseInt()</code>方法解析字符串<code>123ads</code>时会得到结果<code>123</code>，而<code>Number()</code>方法会得到<code>NaN</code>。</p>\n<h2 id=\"类型转换规则\"><a href=\"#类型转换规则\" class=\"headerlink\" title=\"类型转换规则\"></a>类型转换规则</h2><h3 id=\"对象-原始值转换\"><a href=\"#对象-原始值转换\" class=\"headerlink\" title=\"对象-原始值转换\"></a>对象-原始值转换</h3><p>JS中进行对象转换为原始值时会根据所处的情况即上下文进行推断需要转换为什么类型的原始值，<code>hint</code>指的就是推断的结果。</p>\n<p><code>hint</code>一共有三种值，分别是<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;default&quot;</code>。当JS无法确定推断上下文情况时会采用<code>&quot;default&quot;</code>来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hint 为 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hint 为 &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hint 为 &quot;default&quot;</span></span><br><span class=\"line\">obj == <span class=\"string\">&#x27;100&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol.toPrimitive</code>是一个JS中内置的<code>Symbol</code>值，它可以作为对象中的一个默认函数属性存在，当一个对象转换为对应的原始值时，会将<code>hint</code>作为参数传入并调用此函数（如果该函数存在的话）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">toPrimitive</span>](hint) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(hint)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">47</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hi&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(obj) <span class=\"comment\">// string</span></span><br><span class=\"line\">+obj <span class=\"comment\">// number</span></span><br><span class=\"line\">obj == <span class=\"string\">&#x27;47&#x27;</span> <span class=\"comment\">// default</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>Symbol.toPrimitive</code>不存在时，JS会寻找对象上的<code>toString()</code>方法和<code>valueOf()</code>方法来进行转换，方法的调用优先级会根据<code>hint</code>的值来判断：</p>\n<ul>\n<li><code>&quot;string&quot;</code>，优先使用<code>toString()</code>方法，如果该方法返回的值不是基本值的话，则使用<code>valueOf()</code>方法。</li>\n<li><code>&quot;number&quot; || &quot;default&quot;</code>，优先使用<code>valueOf()</code>方法，如果该方法返回的值不是原始值，则再使用<code>toString()</code>方法。</li>\n</ul>\n<p>对象默认的<code>toString()</code>方法会返回<code>&quot;[object Object]&quot;</code>，而<code>valueOf()</code>方法返回对象本身，但JavaScript的许多内置对象都重写了<code>valueOf()</code>方法，以实现更适合自身的功能需要。具体可<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">点击这里</a>参考MDN文档。</p>\n<p>总结一下，对象转换到原始值主要分为三步：</p>\n<ol>\n<li>推断<code>hint</code>的值。</li>\n<li>如果对象上存在<code>Symbol.toPrimitive</code>，则调用该函数处理转换。</li>\n<li>如果对象上不存在<code>Symbol.toPrimitive</code>，则根据<code>hint</code>的值来调用<code>toString()</code>或<code>valueOf()</code>方法来处理转换。</li>\n</ol>\n<p>从之前提到的方法可以看出类型转换最终的结果是<code>number</code>、<code>string</code>、<code>boolean</code>这三种类型之一。知道了对象是如何转换为原始值之后，下面就开始讲解其他类型是如何转换为这三种类型的。</p>\n<h3 id=\"转换为-number\"><a href=\"#转换为-number\" class=\"headerlink\" title=\"转换为 number\"></a>转换为 number</h3><p><strong>boolean</strong></p>\n<ul>\n<li>true → 1</li>\n<li>false → 0</li>\n</ul>\n<p><strong>undefined</strong></p>\n<ul>\n<li>undefined → NaN</li>\n</ul>\n<p><strong>null</strong></p>\n<ul>\n<li>null → 0</li>\n</ul>\n<p><strong>symbol</strong></p>\n<ul>\n<li>转换不了，会抛出异常<code>Uncaught TypeError: Cannot convert a Symbol value to a number</code></li>\n</ul>\n<p><strong>bigInt</strong></p>\n<ul>\n<li>字面量形式定义 → 去掉后面的<code>n</code>，如<code>10n → 10</code></li>\n<li>BigInt(value) → value（默认<code>value</code>能够转换为数值）</li>\n</ul>\n<p><strong>string</strong></p>\n<ul>\n<li>数字字符的字符串<ul>\n<li>十进制、带符号的十进制 → 十进制（注意转换时会忽略数值前的0，如Number(<code>&quot;0047&quot;</code>)会返回<code>47</code>）</li>\n<li>浮点值格式 → 浮点值</li>\n<li>十六进制 → 十进制</li>\n</ul>\n</li>\n<li>空字符串 → 0</li>\n<li>以上规则不能解析时 → NaN（注意与方法<code>parseInt</code>、<code>parseFloat</code>的区别）</li>\n</ul>\n<p><strong>object（可参考对象-原始值转换）</strong></p>\n<ol>\n<li>推断<code>hint</code>为<code>&quot;number&quot;</code>。</li>\n<li>如存在<code>Symbol.toPrimitive</code>，则调用该函数处理转换。</li>\n<li>如不存在，调用<code>valueOf()</code>方法，如果该方法返回的值为原始值的话，则转换结束。</li>\n<li>如<code>valueOf()</code>方法的返回值不是原始值的话，继续调用<code>toString()</code>方法，如果该方法能成功转换为<code>string</code>类型的值，则根据<code>string → number</code>的规则再进行转换。</li>\n<li>如果仍未得到原始值，则抛出<code>TypeError</code>异常。</li>\n</ol>\n<h3 id=\"转换为-string\"><a href=\"#转换为-string\" class=\"headerlink\" title=\"转换为 string\"></a>转换为 string</h3><p><strong>number</strong></p>\n<ul>\n<li>value → ‘value’</li>\n</ul>\n<p><strong>boolean</strong></p>\n<ul>\n<li>true → ‘true’</li>\n<li>false → ‘false’</li>\n</ul>\n<p><strong>undefined</strong></p>\n<ul>\n<li>undefined → ‘undefined’</li>\n</ul>\n<p><strong>null</strong></p>\n<ul>\n<li>null → ‘null’</li>\n</ul>\n<p><strong>symbol</strong></p>\n<ul>\n<li>Symbol(value) → ‘Symbol(value)’，如<code>String(Symbol.iterator)</code>的返回值为<code>&#39;Symbol(Symbol.iterator)&#39;</code></li>\n<li>Symbol.for(value)→’Symbol(value)’，如<code>String(Symbol.for(&#39;12&#39;))</code>的返回值为<code>&#39;Symbol.for(&#39;12&#39;)&#39;</code></li>\n</ul>\n<p><strong>bigInt</strong></p>\n<ul>\n<li>字面量形式定义 → 去掉后面的<code>n</code>，再转换为字符串，如<code>10n → &#39;10&#39;</code></li>\n<li>BigInt(value) → ‘value’（默认<code>value</code>能够转换为数值）</li>\n</ul>\n<p><strong>object（可参考对象-原始值转换）</strong></p>\n<ol>\n<li>推断<code>hint</code>为<code>&quot;string&quot;</code>。</li>\n<li>如存在<code>Symbol.toPrimitive</code>，则调用该函数处理转换。</li>\n<li>如不存在，调用<code>toString()</code>方法，如果该方法返回的值为原始值的话，则转换结束。</li>\n<li>如<code>toString()</code>方法的返回值不是原始值的话，继续调用<code>valueOf()</code>方法，如果该方法能成功转换为原始类型的值，则根据前面的规则再进行转换。</li>\n<li>如果仍未得到原始值，则抛出<code>TypeError</code>异常。</li>\n</ol>\n<h3 id=\"转换为-boolean\"><a href=\"#转换为-boolean\" class=\"headerlink\" title=\"转换为 boolean\"></a>转换为 boolean</h3><p><strong>number</strong></p>\n<ul>\n<li>非零数值 → true</li>\n<li>0、NaN → false</li>\n</ul>\n<p><strong>string</strong></p>\n<ul>\n<li>非空字符串 → true</li>\n<li>空字符串’’ → false</li>\n</ul>\n<p><strong>undefined</strong></p>\n<ul>\n<li>undefined → false</li>\n</ul>\n<p><strong>null</strong></p>\n<ul>\n<li>null → false</li>\n</ul>\n<p><strong>symbol</strong></p>\n<ul>\n<li>Symbol(value) → true</li>\n<li>Symbol.for(value) → true</li>\n</ul>\n<p><strong>bigInt</strong></p>\n<ul>\n<li>字面量形式定义，去掉后面的<code>n</code>然后按 number → boolean 的规则转换</li>\n<li>BigInt(value)，value → number → boolean</li>\n</ul>\n<p><strong>object</strong></p>\n<ul>\n<li>任意对象 → true</li>\n</ul>\n<h2 id=\"触发隐式类型转换\"><a href=\"#触发隐式类型转换\" class=\"headerlink\" title=\"触发隐式类型转换\"></a>触发隐式类型转换</h2><p>在了解了类型转换的规则后，就能清楚地知道显式类型转换的结果，但有时候JS会自动地触发类型转换，这一机制被称为隐式类型转换。一方面它让代码变得晦涩难懂；另一方面，它也能让代码变得更加简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显式类型转换</span></span><br><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 隐式类型转换</span></span><br><span class=\"line\"><span class=\"number\">1</span>+<span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"触发转换为-number\"><a href=\"#触发转换为-number\" class=\"headerlink\" title=\"触发转换为 number\"></a>触发转换为 number</h3><p><strong>一元运算符 +</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">+<span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">+<span class=\"string\">&#x27;hello&#x27;</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+<span class=\"literal\">null</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">+<span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+&#123;&#125; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二元运算符 + - * &#x2F; % +&#x3D; -&#x3D;（使用 + 运算符时操作数中不存在字符串）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意这里的 &#123;&#125; 并不是一个空对象 而是一个代码块</span></span><br><span class=\"line\">&#123;&#125; + <span class=\"literal\">true</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Cannot mix BigInt and other types, </span></span><br><span class=\"line\"><span class=\"comment\">// use explicit conversions</span></span><br><span class=\"line\"><span class=\"number\">10n</span> + <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0 除以任何数都得 0 的规则被打破！</span></span><br><span class=\"line\"><span class=\"comment\">// 与 NaN 的运算结果都会是 NaN</span></span><br><span class=\"line\"><span class=\"literal\">null</span> % <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> * +&#123;&#125; <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;3.1512&#x27;</span> - <span class=\"string\">&#x27;0.1&#x27;</span> <span class=\"comment\">// 3.0511999999999997 （注意这里产生了精度丢失-_—|）</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>+</code>的其中一个操作数是字符串或对象（转换为原始值时得到字符串）时，将会执行字符串拼接。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 特殊情况，无法转换为number</span></span><br><span class=\"line\"><span class=\"comment\"> * 推断 hint 为 &#x27;default&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组转换为原始值</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先调用valueOf方法，返回数组本身</span></span><br><span class=\"line\"><span class=\"comment\"> * 再调用toString方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组的toString被重写，效果相当于调用join(&#x27;,&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后再进行字符串拼接</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>] + [<span class=\"number\">3</span>, <span class=\"number\">4</span>] <span class=\"comment\">// &#x27;1,23,4&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;&#125; 视为 代码块</span></span><br><span class=\"line\"><span class=\"comment\"> * 原式等同于 +[]</span></span><br><span class=\"line\"><span class=\"comment\"> * 按照一元运算符 + 的规则来</span></span><br><span class=\"line\"><span class=\"comment\"> * 推断 hint 为 &#x27;number&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先调用valueOf方法，返回数组本身</span></span><br><span class=\"line\"><span class=\"comment\"> * 再调用toString方法 返回&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#x27;&#x27; 转换为 0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&#123;&#125; + [] <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的 &#123;&#125; 是一个空对象</span></span><br><span class=\"line\">[] + &#123;&#125; <span class=\"comment\">// &#x27;[object Object]&#x27; </span></span><br></pre></td></tr></table></figure>\n\n<p><strong>比较运算符（&gt; &lt; &lt;&#x3D; &gt;&#x3D;）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"literal\">true</span> &gt; <span class=\"literal\">false</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意 NaN 的特殊性</span></span><br><span class=\"line\">(<span class=\"number\">1</span> &lt; <span class=\"title class_\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">(<span class=\"number\">1</span> &gt; <span class=\"title class_\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">(<span class=\"title class_\">NaN</span> &lt;= <span class=\"title class_\">NaN</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>在比较中也存在被称为”抽象关系比较“的特殊情况，其中又分为比较双方都是字符串和存在<code>object</code>类型两种情况，如果是第二种情况，需要先将对象转换为原始值，如果结果中出现非字符串，就强制将比较双方转换为数字来比较。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同样地，根据语法规则， &#123;&#125; 被视为代码块</span></span><br><span class=\"line\">(&#123;&#125; &gt; []) <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;&gt;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 先根据对象 -&gt; 原始值规则进行转换</span></span><br><span class=\"line\"><span class=\"comment\"> * [] 转换为 &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;&#125; 转换为 &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较双方都是字符串的话按字母顺序来比较</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">([] &lt; &#123;&#125;) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，还需注意<code>&lt;=</code> <code>&gt;=</code>的处理方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123; <span class=\"attr\">x</span>: <span class=\"number\">42</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = &#123; <span class=\"attr\">y</span>: <span class=\"number\">43</span> &#125;</span><br><span class=\"line\">(a&lt;b) <span class=\"comment\">// false</span></span><br><span class=\"line\">(a&gt;b) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a&gt;=b 被处理为 b&lt;a 然后反转结果</span></span><br><span class=\"line\">(a&gt;=b) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// a&lt;=b 被处理为 b&gt;a 然后反转结果</span></span><br><span class=\"line\">(a&lt;=b) <span class=\"comment\">//true**逻辑运算符 ！**</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"触发转换为-string\"><a href=\"#触发转换为-string\" class=\"headerlink\" title=\"触发转换为 string\"></a>触发转换为 string</h3><p><strong>二元运算符 +（运算元中存在字符串时）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;0&#x27;</span> <span class=\"comment\">// &#x27;10&#x27;</span></span><br><span class=\"line\">+&#123;&#125; + <span class=\"string\">&#x27;true&#x27;</span> <span class=\"comment\">// &#x27;NaNtrue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span> + &#123;&#125; <span class=\"comment\">// &#x27;true[object Object]&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"触发转换为-boolean\"><a href=\"#触发转换为-boolean\" class=\"headerlink\" title=\"触发转换为 boolean\"></a>触发转换为 boolean</h3><p>会触发布尔值隐式转换的情况有以下几种：</p>\n<ul>\n<li>if 语句中的条件判断表达式</li>\n<li>for 语句中的条件判断表达式</li>\n<li>while 语句中的条件判断表达式</li>\n<li>三元表达式（问号表达式）中的条件判断表达式</li>\n<li>||（或）、&amp;&amp;（与）、!（非）</li>\n</ul>\n<p>这里有一个小技巧，使用逻辑运算符<code>!</code>可以触发布尔值隐式转换并不准确，因为它还额外做了取反的工作，但是使用<code>!!</code>取两次反，就能实现<code>Boolean()</code>方法的功能，同时在写法上要比<code>Boolean()</code>简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"number\">1</span>) === !!<span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>逻辑运算符<code>||</code>和<code>&amp;&amp;</code>，会将左边的操作数作为条件判断表达式来触发布尔值隐式类型转换。换句话说，<code>||</code>和<code>&amp;&amp;</code>运算符的返回值不一定是布尔值，而是两个操作数中的其中一个，故它们也被称为选择器运算符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> &amp;&amp; <span class=\"literal\">null</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"number\">1</span> &amp;&amp; <span class=\"number\">2</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> || <span class=\"number\">1</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> || <span class=\"title class_\">NaN</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>对于<code>&amp;&amp;</code>运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回该操作数；如果结果为真，直接返回右边的操作数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a &amp;&amp; b</span><br><span class=\"line\"><span class=\"comment\">// 可以按以下表达式去理解，但两个表达式并不完全相等</span></span><br><span class=\"line\">a ? b : a</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>||</code>运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回右边的操作数；如果结果为真，直接返回该操作数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a || b</span><br><span class=\"line\"><span class=\"comment\">// 可以按以下表达式去理解，但两个表达式并不完全相等</span></span><br><span class=\"line\">a ? a : b</span><br></pre></td></tr></table></figure>\n\n<p>在ES5时经常用到这两个运算符来实现一些功能，如使用<code>||</code>来实现类似默认参数的功能，使用<code>&amp;&amp;</code>来实现类似可选链操作符<code>?.</code>的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 实现默认参数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, delay</span>) &#123;</span><br><span class=\"line\">  delay = delay || <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">      timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 做法</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, delay = <span class=\"number\">200</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">      timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Joe&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = data &amp;&amp; data.<span class=\"property\">name</span> <span class=\"comment\">// Joe</span></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\">name = data?.<span class=\"property\">name</span> <span class=\"comment\">// Joe</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"宽松相等-x3D-x3D\"><a href=\"#宽松相等-x3D-x3D\" class=\"headerlink\" title=\"宽松相等 &#x3D;&#x3D;\"></a>宽松相等 &#x3D;&#x3D;</h2><h3 id=\"宽松相等-x3D-x3D-与严格相等-x3D-x3D-x3D\"><a href=\"#宽松相等-x3D-x3D-与严格相等-x3D-x3D-x3D\" class=\"headerlink\" title=\"宽松相等 &#x3D;&#x3D; 与严格相等 &#x3D;&#x3D;&#x3D;\"></a>宽松相等 &#x3D;&#x3D; 与严格相等 &#x3D;&#x3D;&#x3D;</h3><p>在JS中存在宽松相等<code>==</code>和严格相等<code>===</code>两种等于运算符，它们的区别在于<code>==</code>在相等比较过程中当比较双方类型不一致时会先进行类型转换之后再判断；而<code>===</code>不会，类型不一致的话直接返回<code>false</code>。为了语意清晰，一般会更加推荐使用<code>===</code>而不是<code>==</code>，但还是有必要了解使用<code>==</code>时会发生什么。</p>\n<blockquote>\n<p><code>!=</code>为宽松不相等，<code>!==</code>为严格不相登。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">47</span> == <span class=\"string\">&#x27;0x2f&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">47</span> === <span class=\"string\">&#x27;0x2f&#x27;</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x3D-x3D-的隐式类型转换规则\"><a href=\"#x3D-x3D-的隐式类型转换规则\" class=\"headerlink\" title=\"&#x3D;&#x3D; 的隐式类型转换规则\"></a>&#x3D;&#x3D; 的隐式类型转换规则</h3><p>比较双方类型不一致时，关于<code>==</code>的类型转换规则如下：</p>\n<ul>\n<li>比较双方存在布尔值时，会尝试将布尔值转换为数字再进行比较</li>\n<li>比较双方其中一个为字符串一个为数字时，会尝试将字符串转换为数字再进行比较。</li>\n<li>比较双方存在一个为原始值，一个为对象时，会先将对象转换为原始值后再进行比较。</li>\n</ul>\n<p>注意关于<code>==</code>也存在特殊情况，<code>null</code>与<code>undefined</code>在宽松比较时可以视为相等，这两种类型在遇到其他类型时一律返回<code>false</code>（这种情况下使用<code>==</code>要比<code>===</code>好一些）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&#x27;0&#x27;</span> == <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些让人头大的宽松比较\"><a href=\"#一些让人头大的宽松比较\" class=\"headerlink\" title=\"一些让人头大的宽松比较\"></a>一些让人头大的宽松比较</h3><p><code>[] == ![]</code></p>\n<p>看到以上比较可以自己先思考结果，以下给出转换过程</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * [] 为对象子类型 </span></span><br><span class=\"line\"><span class=\"comment\"> * ![] 会进行布尔值隐式转换</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据规则 任意对象转换为布尔值都是true</span></span><br><span class=\"line\"><span class=\"comment\"> *  最后再取反 所以 ![] 的结果为 false </span></span><br><span class=\"line\"><span class=\"comment\"> * 根据 == 的转换规则</span></span><br><span class=\"line\"><span class=\"comment\"> * ![] 先转换为 false 再转换为数字 0</span></span><br><span class=\"line\"><span class=\"comment\"> * [] 需要转换为原始值</span></span><br><span class=\"line\"><span class=\"comment\"> *  valueOf方法返回本身 不是原始值</span></span><br><span class=\"line\"><span class=\"comment\"> *  调用toString方法 返回 &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#x27;&#x27; 转换为 0</span></span><br><span class=\"line\"><span class=\"comment\"> *  故最后进行的比较为 0 == 0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类似地</span></span><br><span class=\"line\">[<span class=\"number\">47</span>] == <span class=\"number\">47</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"literal\">null</span>] == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&#x27;ops&#x27;</span> == [<span class=\"string\">&#x27;ops&#x27;</span>] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>&#39;true&#39; == true</code></p>\n<p>同样地，可以自己先思考，以下给出转换过程</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较双方为字符串与布尔值</span></span><br><span class=\"line\"><span class=\"comment\"> *  布尔值转换为数字</span></span><br><span class=\"line\"><span class=\"comment\"> *    true 转换为 1</span></span><br><span class=\"line\"><span class=\"comment\"> *  字符串转换为数字</span></span><br><span class=\"line\"><span class=\"comment\"> *    &#x27;true&#x27; 转换为 NaN</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后进行的比较是 NaN == 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"string\">&#x27;true&#x27;</span> == <span class=\"literal\">true</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/\">MDN Web Docs</a></strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h1><p>JavaScript中类型转换分为显式类型转换和隐式类型转换，顾名思义，显式类型转换指的是直接调用类型转换的方法来进行类型转换，如使用<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>方法来将其他类型的值转换为<code>number</code>类型；隐式类型转换指虽然没有直接使用显示类型转换的方法来进行类型转换，但是根据JS中的规则会自动进行类型转换。从另一个角度来说，只要掌握了类型转换的规则，知道如何触发隐式类型转换，隐式类型转换也可以视作为显式类型转换。</p>\n<h2 id=\"类型转换方法（显式类型转换）\"><a href=\"#类型转换方法（显式类型转换）\" class=\"headerlink\" title=\"类型转换方法（显式类型转换）\"></a>类型转换方法（显式类型转换）</h2><p>常见的类型转换方法有<code>Number()</code>、<code>String()</code>、<code>Boolean()</code>、<code>parseInt()</code>、<code>parseFloat()</code>、<code>toString()</code>。</p>\n<p>这些方法分别会尝试将传入的参数转换为<code>number</code>、<code>string</code>、<code>boolean</code>类型的值。</p>\n<p>每个方法都有自己的转换规则，其中大部分规则也会应用到隐式类型转换上，少部分方法的转换会有一些差异，如<code>parseInt()</code>方法解析字符串<code>123ads</code>时会得到结果<code>123</code>，而<code>Number()</code>方法会得到<code>NaN</code>。</p>\n<h2 id=\"类型转换规则\"><a href=\"#类型转换规则\" class=\"headerlink\" title=\"类型转换规则\"></a>类型转换规则</h2><h3 id=\"对象-原始值转换\"><a href=\"#对象-原始值转换\" class=\"headerlink\" title=\"对象-原始值转换\"></a>对象-原始值转换</h3><p>JS中进行对象转换为原始值时会根据所处的情况即上下文进行推断需要转换为什么类型的原始值，<code>hint</code>指的就是推断的结果。</p>\n<p><code>hint</code>一共有三种值，分别是<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;default&quot;</code>。当JS无法确定推断上下文情况时会采用<code>&quot;default&quot;</code>来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hint 为 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hint 为 &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hint 为 &quot;default&quot;</span></span><br><span class=\"line\">obj == <span class=\"string\">&#x27;100&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol.toPrimitive</code>是一个JS中内置的<code>Symbol</code>值，它可以作为对象中的一个默认函数属性存在，当一个对象转换为对应的原始值时，会将<code>hint</code>作为参数传入并调用此函数（如果该函数存在的话）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">toPrimitive</span>](hint) &#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(hint)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">47</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hint === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;hi&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(obj) <span class=\"comment\">// string</span></span><br><span class=\"line\">+obj <span class=\"comment\">// number</span></span><br><span class=\"line\">obj == <span class=\"string\">&#x27;47&#x27;</span> <span class=\"comment\">// default</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>Symbol.toPrimitive</code>不存在时，JS会寻找对象上的<code>toString()</code>方法和<code>valueOf()</code>方法来进行转换，方法的调用优先级会根据<code>hint</code>的值来判断：</p>\n<ul>\n<li><code>&quot;string&quot;</code>，优先使用<code>toString()</code>方法，如果该方法返回的值不是基本值的话，则使用<code>valueOf()</code>方法。</li>\n<li><code>&quot;number&quot; || &quot;default&quot;</code>，优先使用<code>valueOf()</code>方法，如果该方法返回的值不是原始值，则再使用<code>toString()</code>方法。</li>\n</ul>\n<p>对象默认的<code>toString()</code>方法会返回<code>&quot;[object Object]&quot;</code>，而<code>valueOf()</code>方法返回对象本身，但JavaScript的许多内置对象都重写了<code>valueOf()</code>方法，以实现更适合自身的功能需要。具体可<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">点击这里</a>参考MDN文档。</p>\n<p>总结一下，对象转换到原始值主要分为三步：</p>\n<ol>\n<li>推断<code>hint</code>的值。</li>\n<li>如果对象上存在<code>Symbol.toPrimitive</code>，则调用该函数处理转换。</li>\n<li>如果对象上不存在<code>Symbol.toPrimitive</code>，则根据<code>hint</code>的值来调用<code>toString()</code>或<code>valueOf()</code>方法来处理转换。</li>\n</ol>\n<p>从之前提到的方法可以看出类型转换最终的结果是<code>number</code>、<code>string</code>、<code>boolean</code>这三种类型之一。知道了对象是如何转换为原始值之后，下面就开始讲解其他类型是如何转换为这三种类型的。</p>\n<h3 id=\"转换为-number\"><a href=\"#转换为-number\" class=\"headerlink\" title=\"转换为 number\"></a>转换为 number</h3><p><strong>boolean</strong></p>\n<ul>\n<li>true → 1</li>\n<li>false → 0</li>\n</ul>\n<p><strong>undefined</strong></p>\n<ul>\n<li>undefined → NaN</li>\n</ul>\n<p><strong>null</strong></p>\n<ul>\n<li>null → 0</li>\n</ul>\n<p><strong>symbol</strong></p>\n<ul>\n<li>转换不了，会抛出异常<code>Uncaught TypeError: Cannot convert a Symbol value to a number</code></li>\n</ul>\n<p><strong>bigInt</strong></p>\n<ul>\n<li>字面量形式定义 → 去掉后面的<code>n</code>，如<code>10n → 10</code></li>\n<li>BigInt(value) → value（默认<code>value</code>能够转换为数值）</li>\n</ul>\n<p><strong>string</strong></p>\n<ul>\n<li>数字字符的字符串<ul>\n<li>十进制、带符号的十进制 → 十进制（注意转换时会忽略数值前的0，如Number(<code>&quot;0047&quot;</code>)会返回<code>47</code>）</li>\n<li>浮点值格式 → 浮点值</li>\n<li>十六进制 → 十进制</li>\n</ul>\n</li>\n<li>空字符串 → 0</li>\n<li>以上规则不能解析时 → NaN（注意与方法<code>parseInt</code>、<code>parseFloat</code>的区别）</li>\n</ul>\n<p><strong>object（可参考对象-原始值转换）</strong></p>\n<ol>\n<li>推断<code>hint</code>为<code>&quot;number&quot;</code>。</li>\n<li>如存在<code>Symbol.toPrimitive</code>，则调用该函数处理转换。</li>\n<li>如不存在，调用<code>valueOf()</code>方法，如果该方法返回的值为原始值的话，则转换结束。</li>\n<li>如<code>valueOf()</code>方法的返回值不是原始值的话，继续调用<code>toString()</code>方法，如果该方法能成功转换为<code>string</code>类型的值，则根据<code>string → number</code>的规则再进行转换。</li>\n<li>如果仍未得到原始值，则抛出<code>TypeError</code>异常。</li>\n</ol>\n<h3 id=\"转换为-string\"><a href=\"#转换为-string\" class=\"headerlink\" title=\"转换为 string\"></a>转换为 string</h3><p><strong>number</strong></p>\n<ul>\n<li>value → ‘value’</li>\n</ul>\n<p><strong>boolean</strong></p>\n<ul>\n<li>true → ‘true’</li>\n<li>false → ‘false’</li>\n</ul>\n<p><strong>undefined</strong></p>\n<ul>\n<li>undefined → ‘undefined’</li>\n</ul>\n<p><strong>null</strong></p>\n<ul>\n<li>null → ‘null’</li>\n</ul>\n<p><strong>symbol</strong></p>\n<ul>\n<li>Symbol(value) → ‘Symbol(value)’，如<code>String(Symbol.iterator)</code>的返回值为<code>&#39;Symbol(Symbol.iterator)&#39;</code></li>\n<li>Symbol.for(value)→’Symbol(value)’，如<code>String(Symbol.for(&#39;12&#39;))</code>的返回值为<code>&#39;Symbol.for(&#39;12&#39;)&#39;</code></li>\n</ul>\n<p><strong>bigInt</strong></p>\n<ul>\n<li>字面量形式定义 → 去掉后面的<code>n</code>，再转换为字符串，如<code>10n → &#39;10&#39;</code></li>\n<li>BigInt(value) → ‘value’（默认<code>value</code>能够转换为数值）</li>\n</ul>\n<p><strong>object（可参考对象-原始值转换）</strong></p>\n<ol>\n<li>推断<code>hint</code>为<code>&quot;string&quot;</code>。</li>\n<li>如存在<code>Symbol.toPrimitive</code>，则调用该函数处理转换。</li>\n<li>如不存在，调用<code>toString()</code>方法，如果该方法返回的值为原始值的话，则转换结束。</li>\n<li>如<code>toString()</code>方法的返回值不是原始值的话，继续调用<code>valueOf()</code>方法，如果该方法能成功转换为原始类型的值，则根据前面的规则再进行转换。</li>\n<li>如果仍未得到原始值，则抛出<code>TypeError</code>异常。</li>\n</ol>\n<h3 id=\"转换为-boolean\"><a href=\"#转换为-boolean\" class=\"headerlink\" title=\"转换为 boolean\"></a>转换为 boolean</h3><p><strong>number</strong></p>\n<ul>\n<li>非零数值 → true</li>\n<li>0、NaN → false</li>\n</ul>\n<p><strong>string</strong></p>\n<ul>\n<li>非空字符串 → true</li>\n<li>空字符串’’ → false</li>\n</ul>\n<p><strong>undefined</strong></p>\n<ul>\n<li>undefined → false</li>\n</ul>\n<p><strong>null</strong></p>\n<ul>\n<li>null → false</li>\n</ul>\n<p><strong>symbol</strong></p>\n<ul>\n<li>Symbol(value) → true</li>\n<li>Symbol.for(value) → true</li>\n</ul>\n<p><strong>bigInt</strong></p>\n<ul>\n<li>字面量形式定义，去掉后面的<code>n</code>然后按 number → boolean 的规则转换</li>\n<li>BigInt(value)，value → number → boolean</li>\n</ul>\n<p><strong>object</strong></p>\n<ul>\n<li>任意对象 → true</li>\n</ul>\n<h2 id=\"触发隐式类型转换\"><a href=\"#触发隐式类型转换\" class=\"headerlink\" title=\"触发隐式类型转换\"></a>触发隐式类型转换</h2><p>在了解了类型转换的规则后，就能清楚地知道显式类型转换的结果，但有时候JS会自动地触发类型转换，这一机制被称为隐式类型转换。一方面它让代码变得晦涩难懂；另一方面，它也能让代码变得更加简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显式类型转换</span></span><br><span class=\"line\"><span class=\"title class_\">String</span>(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 隐式类型转换</span></span><br><span class=\"line\"><span class=\"number\">1</span>+<span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"触发转换为-number\"><a href=\"#触发转换为-number\" class=\"headerlink\" title=\"触发转换为 number\"></a>触发转换为 number</h3><p><strong>一元运算符 +</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">+<span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">+<span class=\"string\">&#x27;hello&#x27;</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+<span class=\"literal\">null</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\">+<span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+&#123;&#125; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>二元运算符 + - * &#x2F; % +&#x3D; -&#x3D;（使用 + 运算符时操作数中不存在字符串）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意这里的 &#123;&#125; 并不是一个空对象 而是一个代码块</span></span><br><span class=\"line\">&#123;&#125; + <span class=\"literal\">true</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Cannot mix BigInt and other types, </span></span><br><span class=\"line\"><span class=\"comment\">// use explicit conversions</span></span><br><span class=\"line\"><span class=\"number\">10n</span> + <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 0 除以任何数都得 0 的规则被打破！</span></span><br><span class=\"line\"><span class=\"comment\">// 与 NaN 的运算结果都会是 NaN</span></span><br><span class=\"line\"><span class=\"literal\">null</span> % <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> * +&#123;&#125; <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;3.1512&#x27;</span> - <span class=\"string\">&#x27;0.1&#x27;</span> <span class=\"comment\">// 3.0511999999999997 （注意这里产生了精度丢失-_—|）</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>+</code>的其中一个操作数是字符串或对象（转换为原始值时得到字符串）时，将会执行字符串拼接。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 特殊情况，无法转换为number</span></span><br><span class=\"line\"><span class=\"comment\"> * 推断 hint 为 &#x27;default&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组转换为原始值</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先调用valueOf方法，返回数组本身</span></span><br><span class=\"line\"><span class=\"comment\"> * 再调用toString方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 数组的toString被重写，效果相当于调用join(&#x27;,&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后再进行字符串拼接</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>] + [<span class=\"number\">3</span>, <span class=\"number\">4</span>] <span class=\"comment\">// &#x27;1,23,4&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;&#125; 视为 代码块</span></span><br><span class=\"line\"><span class=\"comment\"> * 原式等同于 +[]</span></span><br><span class=\"line\"><span class=\"comment\"> * 按照一元运算符 + 的规则来</span></span><br><span class=\"line\"><span class=\"comment\"> * 推断 hint 为 &#x27;number&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * 首先调用valueOf方法，返回数组本身</span></span><br><span class=\"line\"><span class=\"comment\"> * 再调用toString方法 返回&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#x27;&#x27; 转换为 0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&#123;&#125; + [] <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的 &#123;&#125; 是一个空对象</span></span><br><span class=\"line\">[] + &#123;&#125; <span class=\"comment\">// &#x27;[object Object]&#x27; </span></span><br></pre></td></tr></table></figure>\n\n<p><strong>比较运算符（&gt; &lt; &lt;&#x3D; &gt;&#x3D;）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"literal\">true</span> &gt; <span class=\"literal\">false</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意 NaN 的特殊性</span></span><br><span class=\"line\">(<span class=\"number\">1</span> &lt; <span class=\"title class_\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">(<span class=\"number\">1</span> &gt; <span class=\"title class_\">NaN</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">(<span class=\"title class_\">NaN</span> &lt;= <span class=\"title class_\">NaN</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>在比较中也存在被称为”抽象关系比较“的特殊情况，其中又分为比较双方都是字符串和存在<code>object</code>类型两种情况，如果是第二种情况，需要先将对象转换为原始值，如果结果中出现非字符串，就强制将比较双方转换为数字来比较。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同样地，根据语法规则， &#123;&#125; 被视为代码块</span></span><br><span class=\"line\">(&#123;&#125; &gt; []) <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;&gt;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 先根据对象 -&gt; 原始值规则进行转换</span></span><br><span class=\"line\"><span class=\"comment\"> * [] 转换为 &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;&#125; 转换为 &#x27;[object Object]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较双方都是字符串的话按字母顺序来比较</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">([] &lt; &#123;&#125;) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，还需注意<code>&lt;=</code> <code>&gt;=</code>的处理方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123; <span class=\"attr\">x</span>: <span class=\"number\">42</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = &#123; <span class=\"attr\">y</span>: <span class=\"number\">43</span> &#125;</span><br><span class=\"line\">(a&lt;b) <span class=\"comment\">// false</span></span><br><span class=\"line\">(a&gt;b) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a&gt;=b 被处理为 b&lt;a 然后反转结果</span></span><br><span class=\"line\">(a&gt;=b) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// a&lt;=b 被处理为 b&gt;a 然后反转结果</span></span><br><span class=\"line\">(a&lt;=b) <span class=\"comment\">//true**逻辑运算符 ！**</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"触发转换为-string\"><a href=\"#触发转换为-string\" class=\"headerlink\" title=\"触发转换为 string\"></a>触发转换为 string</h3><p><strong>二元运算符 +（运算元中存在字符串时）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">&#x27;0&#x27;</span> <span class=\"comment\">// &#x27;10&#x27;</span></span><br><span class=\"line\">+&#123;&#125; + <span class=\"string\">&#x27;true&#x27;</span> <span class=\"comment\">// &#x27;NaNtrue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span> + &#123;&#125; <span class=\"comment\">// &#x27;true[object Object]&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"触发转换为-boolean\"><a href=\"#触发转换为-boolean\" class=\"headerlink\" title=\"触发转换为 boolean\"></a>触发转换为 boolean</h3><p>会触发布尔值隐式转换的情况有以下几种：</p>\n<ul>\n<li>if 语句中的条件判断表达式</li>\n<li>for 语句中的条件判断表达式</li>\n<li>while 语句中的条件判断表达式</li>\n<li>三元表达式（问号表达式）中的条件判断表达式</li>\n<li>||（或）、&amp;&amp;（与）、!（非）</li>\n</ul>\n<p>这里有一个小技巧，使用逻辑运算符<code>!</code>可以触发布尔值隐式转换并不准确，因为它还额外做了取反的工作，但是使用<code>!!</code>取两次反，就能实现<code>Boolean()</code>方法的功能，同时在写法上要比<code>Boolean()</code>简洁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"number\">1</span>) === !!<span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>逻辑运算符<code>||</code>和<code>&amp;&amp;</code>，会将左边的操作数作为条件判断表达式来触发布尔值隐式类型转换。换句话说，<code>||</code>和<code>&amp;&amp;</code>运算符的返回值不一定是布尔值，而是两个操作数中的其中一个，故它们也被称为选择器运算符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span> &amp;&amp; <span class=\"literal\">null</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"number\">1</span> &amp;&amp; <span class=\"number\">2</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> || <span class=\"number\">1</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span> || <span class=\"title class_\">NaN</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>对于<code>&amp;&amp;</code>运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回该操作数；如果结果为真，直接返回右边的操作数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a &amp;&amp; b</span><br><span class=\"line\"><span class=\"comment\">// 可以按以下表达式去理解，但两个表达式并不完全相等</span></span><br><span class=\"line\">a ? b : a</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>||</code>运算符来说，先对左边的操作数进行布尔值隐式转换，如果结果为假，则返回右边的操作数；如果结果为真，直接返回该操作数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a || b</span><br><span class=\"line\"><span class=\"comment\">// 可以按以下表达式去理解，但两个表达式并不完全相等</span></span><br><span class=\"line\">a ? a : b</span><br></pre></td></tr></table></figure>\n\n<p>在ES5时经常用到这两个运算符来实现一些功能，如使用<code>||</code>来实现类似默认参数的功能，使用<code>&amp;&amp;</code>来实现类似可选链操作符<code>?.</code>的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 实现默认参数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, delay</span>) &#123;</span><br><span class=\"line\">  delay = delay || <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">      timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 做法</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, delay = <span class=\"number\">200</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">      timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Joe&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = data &amp;&amp; data.<span class=\"property\">name</span> <span class=\"comment\">// Joe</span></span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\">name = data?.<span class=\"property\">name</span> <span class=\"comment\">// Joe</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"宽松相等-x3D-x3D\"><a href=\"#宽松相等-x3D-x3D\" class=\"headerlink\" title=\"宽松相等 &#x3D;&#x3D;\"></a>宽松相等 &#x3D;&#x3D;</h2><h3 id=\"宽松相等-x3D-x3D-与严格相等-x3D-x3D-x3D\"><a href=\"#宽松相等-x3D-x3D-与严格相等-x3D-x3D-x3D\" class=\"headerlink\" title=\"宽松相等 &#x3D;&#x3D; 与严格相等 &#x3D;&#x3D;&#x3D;\"></a>宽松相等 &#x3D;&#x3D; 与严格相等 &#x3D;&#x3D;&#x3D;</h3><p>在JS中存在宽松相等<code>==</code>和严格相等<code>===</code>两种等于运算符，它们的区别在于<code>==</code>在相等比较过程中当比较双方类型不一致时会先进行类型转换之后再判断；而<code>===</code>不会，类型不一致的话直接返回<code>false</code>。为了语意清晰，一般会更加推荐使用<code>===</code>而不是<code>==</code>，但还是有必要了解使用<code>==</code>时会发生什么。</p>\n<blockquote>\n<p><code>!=</code>为宽松不相等，<code>!==</code>为严格不相登。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">47</span> == <span class=\"string\">&#x27;0x2f&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">47</span> === <span class=\"string\">&#x27;0x2f&#x27;</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x3D-x3D-的隐式类型转换规则\"><a href=\"#x3D-x3D-的隐式类型转换规则\" class=\"headerlink\" title=\"&#x3D;&#x3D; 的隐式类型转换规则\"></a>&#x3D;&#x3D; 的隐式类型转换规则</h3><p>比较双方类型不一致时，关于<code>==</code>的类型转换规则如下：</p>\n<ul>\n<li>比较双方存在布尔值时，会尝试将布尔值转换为数字再进行比较</li>\n<li>比较双方其中一个为字符串一个为数字时，会尝试将字符串转换为数字再进行比较。</li>\n<li>比较双方存在一个为原始值，一个为对象时，会先将对象转换为原始值后再进行比较。</li>\n</ul>\n<p>注意关于<code>==</code>也存在特殊情况，<code>null</code>与<code>undefined</code>在宽松比较时可以视为相等，这两种类型在遇到其他类型时一律返回<code>false</code>（这种情况下使用<code>==</code>要比<code>===</code>好一些）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&#x27;0&#x27;</span> == <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些让人头大的宽松比较\"><a href=\"#一些让人头大的宽松比较\" class=\"headerlink\" title=\"一些让人头大的宽松比较\"></a>一些让人头大的宽松比较</h3><p><code>[] == ![]</code></p>\n<p>看到以上比较可以自己先思考结果，以下给出转换过程</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * [] 为对象子类型 </span></span><br><span class=\"line\"><span class=\"comment\"> * ![] 会进行布尔值隐式转换</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据规则 任意对象转换为布尔值都是true</span></span><br><span class=\"line\"><span class=\"comment\"> *  最后再取反 所以 ![] 的结果为 false </span></span><br><span class=\"line\"><span class=\"comment\"> * 根据 == 的转换规则</span></span><br><span class=\"line\"><span class=\"comment\"> * ![] 先转换为 false 再转换为数字 0</span></span><br><span class=\"line\"><span class=\"comment\"> * [] 需要转换为原始值</span></span><br><span class=\"line\"><span class=\"comment\"> *  valueOf方法返回本身 不是原始值</span></span><br><span class=\"line\"><span class=\"comment\"> *  调用toString方法 返回 &#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#x27;&#x27; 转换为 0</span></span><br><span class=\"line\"><span class=\"comment\"> *  故最后进行的比较为 0 == 0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类似地</span></span><br><span class=\"line\">[<span class=\"number\">47</span>] == <span class=\"number\">47</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"literal\">null</span>] == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&#x27;ops&#x27;</span> == [<span class=\"string\">&#x27;ops&#x27;</span>] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>&#39;true&#39; == true</code></p>\n<p>同样地，可以自己先思考，以下给出转换过程</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较双方为字符串与布尔值</span></span><br><span class=\"line\"><span class=\"comment\"> *  布尔值转换为数字</span></span><br><span class=\"line\"><span class=\"comment\"> *    true 转换为 1</span></span><br><span class=\"line\"><span class=\"comment\"> *  字符串转换为数字</span></span><br><span class=\"line\"><span class=\"comment\"> *    &#x27;true&#x27; 转换为 NaN</span></span><br><span class=\"line\"><span class=\"comment\"> * 最后进行的比较是 NaN == 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"string\">&#x27;true&#x27;</span> == <span class=\"literal\">true</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之变量","date":"2022-05-05T06:02:00.000Z","updated":"2022-05-29T13:27:56.538Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# 作用域简述\n\n提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。\n\nJavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块`{...}`。在这里先粗略地知道这三个概念就可以了。\n\n# JS变量\n\n\n在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。\n\n一共有三个关键字用于声明变量：`var`、`let`、`const`。其中`let`、`const`为ES6时新增的关键字，只能在ES6之后的版本使用。\n\n从另一个角度来说，使用`function`、`import`、`class`关键字也可以声明变量，但这里不会提及。\n\n需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为`window`。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。\n\n```js\nif(true) {\n\ta = 10\n}\n\n// 浏览器环境下\nthis === window // true\nconsole.log(this.a) // 10\n```\n\n需要定义多个变量时可以使用`,`号分隔每个变量。\n\n```js\nvar str1 = 'c++', str2 = 'java', str3 = 'c#'\n```\n\n# 变量命名\n\nJavaScript 的变量命名有两个限制：\n\n1. 变量名仅包含字母，数字，符号 `$`\n 和 `_`。\n2. 首字符必须非数字。\n\n> 除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如`async`仍可以用来命名，不能用来命名的关键字可以参考[保留关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97)，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。\n> \n\n```js\nconst 1m = 2 // Uncaught SyntaxError: Invalid or unexpected token\nvar t-an; // Uncaught SyntaxError: Unexpected token '-'\n\nlet 这是一个变量名 = 22 // 合法，但不推荐\n```\n\n现在主流的命名方式是[小驼峰](https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。\n\n常量用作别名时，命名时通常会将单词大写，单词与单词之间使用`_`链接。\n\n```js\nlet currentYear = 2022\nconst COMPANY_NAME = 'it is too looooooooooooooong to remember'\n```\n\n# var 关键字\n\n在声明未赋值的情况下变量会保存一个特殊值`undefined`。\n\n```js\nvar msg // 声明\nconsole.log(msg) // undefined\n```\n\n可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。\n\n```js\nvar msg = 100 // 声明变量并进行赋值\nmsg = 'Hi' \n```\n\n重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。\n\n```js\nvar test = true // 声明并赋值\nvar test = false // 无效的重复声明\nconsole.log(test) // false\n```\n\n通过var声明的全局变量也会挂到全局对象上去。\n\n```js\nvar aaa = 'aaa'\n\n// 浏览器环境下\nwindow.aaa === 'aaa' // true\n```\n\n## 作用范围\n\n由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有`var`，因此通过关键字`var`声明的变量的有效作用范围为函数作用域。\n\n在函数作用域中使用`var`关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。\n\n```js\nfunction fn1 () {\n\tvar n = 100 // 函数作用域中定义的局部变量\n}\nfn1();\nconsole.log(n) // Uncaught ReferenceError: msg is not defined\n```\n\n## 变量提升\n\n变量提升指的是会将变量的声明提升到当前作用域的顶部。用`var`关键字定义的变量就存在变量提升，注意**提升的只是变量的声明，并不是赋值**。\n\n```js\nconsole.log(age) // undefined\nvar age = 99\n\nfunction test() {\n\t// 变量提升，变量a先被赋值为1，再被赋值为0\n\ta = 1;\n\tvar a = 0;\n\tconsole.log(a) // 0\n}\n```\n\n## 模仿块级作用域\n\n由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为`(function(){...})()`，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。\n\n```js\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n})()\n\n// 以下的写法也可以\n+function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}()\n\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}())\n\n```\n\n# let 关键字\n\n## 作用范围\n\n这里主要讲一下`let`与`var`的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用`var`关键字声明的变量在块级作用域之外仍能够访问。\n\n```js\n{\n\tlet a = 1\n\tvar b = 2\n}\n\nconsole.log(a) // Uncaught ReferenceError: a is not defined\nconsole.log(b) // 2\n\nfor(var i = 0; i < 5; i++) {\n  // 不受块级作用域约束，迭代变量渗透到循环体外部\n\t// 相当于重复声明i, 并对其赋值\n\t// 输出5个5\n\tsetTimeout(()=>{\n\t\tconsole.log(i)\n\t})\n}\n\nfor(let j = 0; j < 5; j++) {\n\t// 受到块级作用域的约束\n\t// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值\n\t// 输出 0 1 2 3 4\n\tsetTimeout(()=>{\n\t\tconsole.log(j)\n\t})\n}\n```\n\n同时使用`let`关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。\n\n```js\nvar time;\nlet time; // Uncaught SyntaxError: Identifier 'time' has already been declared\n\nlet age;\nvar age; // Uncaught SyntaxError: Identifier 'age' has already been declared\n\nlet name = 'Joe'\nif(true) {\n\tlet name = 'Roselyn'\n\tconsole.log(name) // Roselyn\n}\nconsole.log(name) // Joe\n\n```\n\n当使用`let`关键字在全局作用域声明变量时也不会污染全局对象。\n\n```js\nlet a = 10;\n// 浏览器环境下\nthis.a // undefined\n```\n\n## 暂时性死区（temporal dead zone，简称 TDZ）\n\n使用`let`声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在`let`变量声明之前的部分被称为暂时性死区，在暂时性死区中引用`let`变量会报引用错误。\n\n```js\nconsole.log(temp) // Uncaught ReferenceError: temp is not defined\n\nlet temp = 'Hi'\n```\n\n使用`typeof`访问暂时性死区中的let变量也会报错。\n\n```js\ntypeof a // 'undefined'\ntypeof b // 'undefined'\ntypeof c // Uncaught ReferenceError: c is not defined\n\nvar b\nlet c\n```\n\n# const 关键字\n\n与`let`相似，`const`的作用范围是块级作用域，也存在暂时性死区。使用`const`关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。\n\n```js\nconst a = 2\n// 即使是相等的值也不行\na = 2 // Uncaught TypeError: Assignment to constant variable\n\nconst b // Uncaught SyntaxError: Missing initializer in const declaration\n```\n\n不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于**原始类型**来说，变量指向的那个内存地址所保存的就是对应的值，而**引用类型**变量指向的内存地址，保存的是指向实际数据的地址，`const`只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。\n\n```js\nconst person = {}\n// 向对象中添加属性\nperson.age = 24\nperson.name = 'ikura'\n\n// 尝试改变指向的地址\nperson = {} // Uncaught TypeError: Assignment to constant variable\n```\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/js-again-varible.md","raw":"---\ntitle: 再学 JS 之变量\ndate: 2022-05-05 14:02:00\nupdated:\ntags: \n  - 变量\ncategories: \n  - [前端, JavaScript]\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/js-again.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# 作用域简述\n\n提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。\n\nJavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块`{...}`。在这里先粗略地知道这三个概念就可以了。\n\n# JS变量\n\n\n在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。\n\n一共有三个关键字用于声明变量：`var`、`let`、`const`。其中`let`、`const`为ES6时新增的关键字，只能在ES6之后的版本使用。\n\n从另一个角度来说，使用`function`、`import`、`class`关键字也可以声明变量，但这里不会提及。\n\n需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为`window`。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。\n\n```js\nif(true) {\n\ta = 10\n}\n\n// 浏览器环境下\nthis === window // true\nconsole.log(this.a) // 10\n```\n\n需要定义多个变量时可以使用`,`号分隔每个变量。\n\n```js\nvar str1 = 'c++', str2 = 'java', str3 = 'c#'\n```\n\n# 变量命名\n\nJavaScript 的变量命名有两个限制：\n\n1. 变量名仅包含字母，数字，符号 `$`\n 和 `_`。\n2. 首字符必须非数字。\n\n> 除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如`async`仍可以用来命名，不能用来命名的关键字可以参考[保留关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97)，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。\n> \n\n```js\nconst 1m = 2 // Uncaught SyntaxError: Invalid or unexpected token\nvar t-an; // Uncaught SyntaxError: Unexpected token '-'\n\nlet 这是一个变量名 = 22 // 合法，但不推荐\n```\n\n现在主流的命名方式是[小驼峰](https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。\n\n常量用作别名时，命名时通常会将单词大写，单词与单词之间使用`_`链接。\n\n```js\nlet currentYear = 2022\nconst COMPANY_NAME = 'it is too looooooooooooooong to remember'\n```\n\n# var 关键字\n\n在声明未赋值的情况下变量会保存一个特殊值`undefined`。\n\n```js\nvar msg // 声明\nconsole.log(msg) // undefined\n```\n\n可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。\n\n```js\nvar msg = 100 // 声明变量并进行赋值\nmsg = 'Hi' \n```\n\n重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。\n\n```js\nvar test = true // 声明并赋值\nvar test = false // 无效的重复声明\nconsole.log(test) // false\n```\n\n通过var声明的全局变量也会挂到全局对象上去。\n\n```js\nvar aaa = 'aaa'\n\n// 浏览器环境下\nwindow.aaa === 'aaa' // true\n```\n\n## 作用范围\n\n由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有`var`，因此通过关键字`var`声明的变量的有效作用范围为函数作用域。\n\n在函数作用域中使用`var`关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。\n\n```js\nfunction fn1 () {\n\tvar n = 100 // 函数作用域中定义的局部变量\n}\nfn1();\nconsole.log(n) // Uncaught ReferenceError: msg is not defined\n```\n\n## 变量提升\n\n变量提升指的是会将变量的声明提升到当前作用域的顶部。用`var`关键字定义的变量就存在变量提升，注意**提升的只是变量的声明，并不是赋值**。\n\n```js\nconsole.log(age) // undefined\nvar age = 99\n\nfunction test() {\n\t// 变量提升，变量a先被赋值为1，再被赋值为0\n\ta = 1;\n\tvar a = 0;\n\tconsole.log(a) // 0\n}\n```\n\n## 模仿块级作用域\n\n由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为`(function(){...})()`，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。\n\n```js\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n})()\n\n// 以下的写法也可以\n+function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}()\n\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}())\n\n```\n\n# let 关键字\n\n## 作用范围\n\n这里主要讲一下`let`与`var`的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用`var`关键字声明的变量在块级作用域之外仍能够访问。\n\n```js\n{\n\tlet a = 1\n\tvar b = 2\n}\n\nconsole.log(a) // Uncaught ReferenceError: a is not defined\nconsole.log(b) // 2\n\nfor(var i = 0; i < 5; i++) {\n  // 不受块级作用域约束，迭代变量渗透到循环体外部\n\t// 相当于重复声明i, 并对其赋值\n\t// 输出5个5\n\tsetTimeout(()=>{\n\t\tconsole.log(i)\n\t})\n}\n\nfor(let j = 0; j < 5; j++) {\n\t// 受到块级作用域的约束\n\t// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值\n\t// 输出 0 1 2 3 4\n\tsetTimeout(()=>{\n\t\tconsole.log(j)\n\t})\n}\n```\n\n同时使用`let`关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。\n\n```js\nvar time;\nlet time; // Uncaught SyntaxError: Identifier 'time' has already been declared\n\nlet age;\nvar age; // Uncaught SyntaxError: Identifier 'age' has already been declared\n\nlet name = 'Joe'\nif(true) {\n\tlet name = 'Roselyn'\n\tconsole.log(name) // Roselyn\n}\nconsole.log(name) // Joe\n\n```\n\n当使用`let`关键字在全局作用域声明变量时也不会污染全局对象。\n\n```js\nlet a = 10;\n// 浏览器环境下\nthis.a // undefined\n```\n\n## 暂时性死区（temporal dead zone，简称 TDZ）\n\n使用`let`声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在`let`变量声明之前的部分被称为暂时性死区，在暂时性死区中引用`let`变量会报引用错误。\n\n```js\nconsole.log(temp) // Uncaught ReferenceError: temp is not defined\n\nlet temp = 'Hi'\n```\n\n使用`typeof`访问暂时性死区中的let变量也会报错。\n\n```js\ntypeof a // 'undefined'\ntypeof b // 'undefined'\ntypeof c // Uncaught ReferenceError: c is not defined\n\nvar b\nlet c\n```\n\n# const 关键字\n\n与`let`相似，`const`的作用范围是块级作用域，也存在暂时性死区。使用`const`关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。\n\n```js\nconst a = 2\n// 即使是相等的值也不行\na = 2 // Uncaught TypeError: Assignment to constant variable\n\nconst b // Uncaught SyntaxError: Missing initializer in const declaration\n```\n\n不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于**原始类型**来说，变量指向的那个内存地址所保存的就是对应的值，而**引用类型**变量指向的内存地址，保存的是指向实际数据的地址，`const`只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。\n\n```js\nconst person = {}\n// 向对象中添加属性\nperson.age = 24\nperson.name = 'ikura'\n\n// 尝试改变指向的地址\nperson = {} // Uncaught TypeError: Assignment to constant variable\n```\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"js-again-varible","published":1,"layout":"post","photos":[],"link":"","_id":"cl3re6unb000jvuo9dil81blt","content":"<h1 id=\"作用域简述\"><a href=\"#作用域简述\" class=\"headerlink\" title=\"作用域简述\"></a>作用域简述</h1><p>提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。</p>\n<p>JavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块<code>&#123;...&#125;</code>。在这里先粗略地知道这三个概念就可以了。</p>\n<h1 id=\"JS变量\"><a href=\"#JS变量\" class=\"headerlink\" title=\"JS变量\"></a>JS变量</h1><p>在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。</p>\n<p>一共有三个关键字用于声明变量：<code>var</code>、<code>let</code>、<code>const</code>。其中<code>let</code>、<code>const</code>为ES6时新增的关键字，只能在ES6之后的版本使用。</p>\n<p>从另一个角度来说，使用<code>function</code>、<code>import</code>、<code>class</code>关键字也可以声明变量，但这里不会提及。</p>\n<p>需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为<code>window</code>。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\ta = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span> === <span class=\"variable language_\">window</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>需要定义多个变量时可以使用<code>,</code>号分隔每个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">&#x27;c++&#x27;</span>, str2 = <span class=\"string\">&#x27;java&#x27;</span>, str3 = <span class=\"string\">&#x27;c#&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h1><p>JavaScript 的变量命名有两个限制：</p>\n<ol>\n<li>变量名仅包含字母，数字，符号 <code>$</code><br> 和 <code>_</code>。</li>\n<li>首字符必须非数字。</li>\n</ol>\n<blockquote>\n<p>除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如<code>async</code>仍可以用来命名，不能用来命名的关键字可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97\">保留关键字</a>，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> 1m = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> t-an; <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;-&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> 这是一个变量名 = <span class=\"number\">22</span> <span class=\"comment\">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>\n\n<p>现在主流的命名方式是<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB\">小驼峰</a>式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。</p>\n<p>常量用作别名时，命名时通常会将单词大写，单词与单词之间使用<code>_</code>链接。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentYear = <span class=\"number\">2022</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">COMPANY_NAME</span> = <span class=\"string\">&#x27;it is too looooooooooooooong to remember&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"var-关键字\"><a href=\"#var-关键字\" class=\"headerlink\" title=\"var 关键字\"></a>var 关键字</h1><p>在声明未赋值的情况下变量会保存一个特殊值<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"number\">100</span> <span class=\"comment\">// 声明变量并进行赋值</span></span><br><span class=\"line\">msg = <span class=\"string\">&#x27;Hi&#x27;</span> </span><br></pre></td></tr></table></figure>\n\n<p>重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">true</span> <span class=\"comment\">// 声明并赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">false</span> <span class=\"comment\">// 无效的重复声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>通过var声明的全局变量也会挂到全局对象上去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aaa = <span class=\"string\">&#x27;aaa&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">aaa</span> === <span class=\"string\">&#x27;aaa&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有<code>var</code>，因此通过关键字<code>var</code>声明的变量的有效作用范围为函数作用域。</p>\n<p>在函数作用域中使用<code>var</code>关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span> () &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> n = <span class=\"number\">100</span> <span class=\"comment\">// 函数作用域中定义的局部变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n) <span class=\"comment\">// Uncaught ReferenceError: msg is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><p>变量提升指的是会将变量的声明提升到当前作用域的顶部。用<code>var</code>关键字定义的变量就存在变量提升，注意<strong>提升的只是变量的声明，并不是赋值</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 变量提升，变量a先被赋值为1，再被赋值为0</span></span><br><span class=\"line\">\ta = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为<code>(function()&#123;...&#125;)()</code>，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下的写法也可以</span></span><br><span class=\"line\">+<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"let-关键字\"><a href=\"#let-关键字\" class=\"headerlink\" title=\"let 关键字\"></a>let 关键字</h1><h2 id=\"作用范围-1\"><a href=\"#作用范围-1\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>这里主要讲一下<code>let</code>与<code>var</code>的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用<code>var</code>关键字声明的变量在块级作用域之外仍能够访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不受块级作用域约束，迭代变量渗透到循环体外部</span></span><br><span class=\"line\">\t<span class=\"comment\">// 相当于重复声明i, 并对其赋值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出5个5</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 受到块级作用域的约束</span></span><br><span class=\"line\">\t<span class=\"comment\">// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出 0 1 2 3 4</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时使用<code>let</code>关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time;</span><br><span class=\"line\"><span class=\"keyword\">let</span> time; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;time&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Joe&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Roselyn&#x27;</span></span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Roselyn</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Joe</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当使用<code>let</code>关键字在全局作用域声明变量时也不会污染全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">a</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"暂时性死区（temporal-dead-zone，简称-TDZ）\"><a href=\"#暂时性死区（temporal-dead-zone，简称-TDZ）\" class=\"headerlink\" title=\"暂时性死区（temporal dead zone，简称 TDZ）\"></a>暂时性死区（temporal dead zone，简称 TDZ）</h2><p>使用<code>let</code>声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在<code>let</code>变量声明之前的部分被称为暂时性死区，在暂时性死区中引用<code>let</code>变量会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp) <span class=\"comment\">// Uncaught ReferenceError: temp is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> temp = <span class=\"string\">&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>typeof</code>访问暂时性死区中的let变量也会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c <span class=\"comment\">// Uncaught ReferenceError: c is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b</span><br><span class=\"line\"><span class=\"keyword\">let</span> c</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h1><p>与<code>let</code>相似，<code>const</code>的作用范围是块级作用域，也存在暂时性死区。使用<code>const</code>关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 即使是相等的值也不行</span></span><br><span class=\"line\">a = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b <span class=\"comment\">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>\n\n<p>不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于<strong>原始类型</strong>来说，变量指向的那个内存地址所保存的就是对应的值，而<strong>引用类型</strong>变量指向的内存地址，保存的是指向实际数据的地址，<code>const</code>只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 向对象中添加属性</span></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">24</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;ikura&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试改变指向的地址</span></span><br><span class=\"line\">person = &#123;&#125; <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"作用域简述\"><a href=\"#作用域简述\" class=\"headerlink\" title=\"作用域简述\"></a>作用域简述</h1><p>提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。</p>\n<p>JavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块<code>&#123;...&#125;</code>。在这里先粗略地知道这三个概念就可以了。</p>\n<h1 id=\"JS变量\"><a href=\"#JS变量\" class=\"headerlink\" title=\"JS变量\"></a>JS变量</h1><p>在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。</p>\n<p>一共有三个关键字用于声明变量：<code>var</code>、<code>let</code>、<code>const</code>。其中<code>let</code>、<code>const</code>为ES6时新增的关键字，只能在ES6之后的版本使用。</p>\n<p>从另一个角度来说，使用<code>function</code>、<code>import</code>、<code>class</code>关键字也可以声明变量，但这里不会提及。</p>\n<p>需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为<code>window</code>。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\ta = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span> === <span class=\"variable language_\">window</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>需要定义多个变量时可以使用<code>,</code>号分隔每个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">&#x27;c++&#x27;</span>, str2 = <span class=\"string\">&#x27;java&#x27;</span>, str3 = <span class=\"string\">&#x27;c#&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h1><p>JavaScript 的变量命名有两个限制：</p>\n<ol>\n<li>变量名仅包含字母，数字，符号 <code>$</code><br> 和 <code>_</code>。</li>\n<li>首字符必须非数字。</li>\n</ol>\n<blockquote>\n<p>除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如<code>async</code>仍可以用来命名，不能用来命名的关键字可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97\">保留关键字</a>，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> 1m = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> t-an; <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;-&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> 这是一个变量名 = <span class=\"number\">22</span> <span class=\"comment\">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>\n\n<p>现在主流的命名方式是<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB\">小驼峰</a>式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。</p>\n<p>常量用作别名时，命名时通常会将单词大写，单词与单词之间使用<code>_</code>链接。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentYear = <span class=\"number\">2022</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">COMPANY_NAME</span> = <span class=\"string\">&#x27;it is too looooooooooooooong to remember&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"var-关键字\"><a href=\"#var-关键字\" class=\"headerlink\" title=\"var 关键字\"></a>var 关键字</h1><p>在声明未赋值的情况下变量会保存一个特殊值<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"number\">100</span> <span class=\"comment\">// 声明变量并进行赋值</span></span><br><span class=\"line\">msg = <span class=\"string\">&#x27;Hi&#x27;</span> </span><br></pre></td></tr></table></figure>\n\n<p>重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">true</span> <span class=\"comment\">// 声明并赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">false</span> <span class=\"comment\">// 无效的重复声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>通过var声明的全局变量也会挂到全局对象上去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aaa = <span class=\"string\">&#x27;aaa&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">aaa</span> === <span class=\"string\">&#x27;aaa&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有<code>var</code>，因此通过关键字<code>var</code>声明的变量的有效作用范围为函数作用域。</p>\n<p>在函数作用域中使用<code>var</code>关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span> () &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> n = <span class=\"number\">100</span> <span class=\"comment\">// 函数作用域中定义的局部变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n) <span class=\"comment\">// Uncaught ReferenceError: msg is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><p>变量提升指的是会将变量的声明提升到当前作用域的顶部。用<code>var</code>关键字定义的变量就存在变量提升，注意<strong>提升的只是变量的声明，并不是赋值</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 变量提升，变量a先被赋值为1，再被赋值为0</span></span><br><span class=\"line\">\ta = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为<code>(function()&#123;...&#125;)()</code>，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下的写法也可以</span></span><br><span class=\"line\">+<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"let-关键字\"><a href=\"#let-关键字\" class=\"headerlink\" title=\"let 关键字\"></a>let 关键字</h1><h2 id=\"作用范围-1\"><a href=\"#作用范围-1\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>这里主要讲一下<code>let</code>与<code>var</code>的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用<code>var</code>关键字声明的变量在块级作用域之外仍能够访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不受块级作用域约束，迭代变量渗透到循环体外部</span></span><br><span class=\"line\">\t<span class=\"comment\">// 相当于重复声明i, 并对其赋值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出5个5</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 受到块级作用域的约束</span></span><br><span class=\"line\">\t<span class=\"comment\">// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出 0 1 2 3 4</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时使用<code>let</code>关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time;</span><br><span class=\"line\"><span class=\"keyword\">let</span> time; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;time&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Joe&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Roselyn&#x27;</span></span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Roselyn</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Joe</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当使用<code>let</code>关键字在全局作用域声明变量时也不会污染全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">a</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"暂时性死区（temporal-dead-zone，简称-TDZ）\"><a href=\"#暂时性死区（temporal-dead-zone，简称-TDZ）\" class=\"headerlink\" title=\"暂时性死区（temporal dead zone，简称 TDZ）\"></a>暂时性死区（temporal dead zone，简称 TDZ）</h2><p>使用<code>let</code>声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在<code>let</code>变量声明之前的部分被称为暂时性死区，在暂时性死区中引用<code>let</code>变量会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp) <span class=\"comment\">// Uncaught ReferenceError: temp is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> temp = <span class=\"string\">&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>typeof</code>访问暂时性死区中的let变量也会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c <span class=\"comment\">// Uncaught ReferenceError: c is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b</span><br><span class=\"line\"><span class=\"keyword\">let</span> c</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h1><p>与<code>let</code>相似，<code>const</code>的作用范围是块级作用域，也存在暂时性死区。使用<code>const</code>关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 即使是相等的值也不行</span></span><br><span class=\"line\">a = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b <span class=\"comment\">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>\n\n<p>不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于<strong>原始类型</strong>来说，变量指向的那个内存地址所保存的就是对应的值，而<strong>引用类型</strong>变量指向的内存地址，保存的是指向实际数据的地址，<code>const</code>只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 向对象中添加属性</span></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">24</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;ikura&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试改变指向的地址</span></span><br><span class=\"line\">person = &#123;&#125; <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"初见 RxJS","date":"2022-05-06T07:10:16.000Z","updated":"2022-05-29T13:27:56.539Z","keywords":null,"description":null,"top_img":null,"cover":"https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/rxjs-first-sight.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# 初识 RxJS\n\n# 写在前面\n\n刚入职了新公司，负责维护一个原来使用`Angular`构建的项目，奈何自己一直使用的是`React`。不过既来之，则安之。顺便插一句，熟悉`Vue`的朋友应该会觉得很亲切，其中很多语法如`v-if`、`v-bind`，与`Angualr`中的`ngIf`、`ngFor`的用法都如出一辙。\n\n看了两周左右的`Angular`，说一下第一印象，`Angular`确实是一个非常齐全的框架，它不像`Vue`跟`React`需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在`Angular`中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。\n其中`RxJS`就是`Anuglar`提供的异步编程方案。\n\n`RxJS`官网描述自己是`Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）`，也可以把`RxJS`当做处理异步行为的`Lodash`库`（Think of RxJS as Lodash for events）`。`RxJS`是编程范式函数式编程(`Functional Programming`)与响应式编程(`Reactive Programming`)的结合，换句话说，`RxJS`是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了`J.H. Blog`的`30天精通RxJS`系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。\n\n\n# 什么是Observable\n## Observer Pattern\n\n观察者模式在程序设计中并不少见，如`DOM`操作中的通过给`DOM`元素绑定相应的事件去监听该`DOM`元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的`Redux`的实现，其都是以观察者模式的思想为核心。\n\n```js\n// redux 的简单实现\nexport const createStore = (reducer) => {\n  // 公共状态\n  let currentState = {};\n  // 监听者队列\n  let listeners = [];\n  // getter\n  function getState() {\n    return currentState;\n  }\n  // setter\n  function dispatch(action) {\n    currentState = reducer(currentState, action);\n\t\t// 当dispatch触发，即状态更新时通知listeners\n    listeners.forEach((fn) => fn());\n  }\n  // 添加监听事件\n  function subscribe(fn) {\n    listeners.push(fn);\n  }\n  // 初始化store数据\n  dispatch({ type: \"@@REDUX_INIT\" });\n  return { getState, dispatch, subscribe };\n};\n```\n\n## Iterator Pattern\n\n`iterator`（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如`Array`、`Map`、`Set`、`String`等JS中内置的数据结构都实现了该接口。实现`iterator`接口的方法是为其添加`Symbol.iterator`属性，其中包含`next`方法，该方法返回的迭代器对象包含两个属性：`value`和`done`。`done`指的是遍历是否结束，`value`为下一次迭代的值，`done`为`true`时`value`一般为`undefined`。\n\n```js\nconst iterableExample = {\n\t[Symbol.iterator]: function() {\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: 'Sunday',\n\t\t\t\t\tdone: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst arr = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\nconst iterator = arr[Symbol.iterator]()\niterator.next() // {value: 'Monday', done: false}\niterator.next() // {value: 'Tuesday', done: false}\niterator.next() // {value: 'Wednesday', done: false}\n```\n\n迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了`iterator`与`iterable`的概念。\n\n## Observable\n\n`Observable`结合了`Observer`与`Iterator`的思想，像`Observe`与`Iterator`一样以流的形式包装数据，同时能够以`Observe`的方式通知更新，以`Iterator`的方式去处理数据。这样说起来可能有点抽象，但是结合`Observable`实例就能很好地理解。\n\n# 创建 Observable\n\n创建`Observable`实例的基本方法,使用`Observable`构造函数来创建一个`Observable`实例对象，其中可以传入一个回调函数,接收一个`subscriber`，用来指定该如何处理数据。需要注意的是，`Observable`作为被观察的对象，需要使用`subscribe`方法来通知`subscriber`去对`Observable`作出处理。\n\n```js\nimport { Observable } from 'rxjs';\n\nlet observalbe1 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  subscriber.next('Nana');\n});\n\n// 使用subscrible方法来订阅Observable\nobservalbe1.subscribe(console.log);\n// Suda\n// Nana\n\n// 处理非同步行为\nlet observalbe2 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  setTimeout(() => {\n    subscriber.next('Kasumi');\n  }, 1000);\n  subscriber.next('Nana');\n});\n\nobservalbe2.subscribe(console.log);\n// Suda\n// Nana\n// Kasumi\n\n```\n\n订阅`Observable`的被称为观察者，观察者具有三种行为（方法）来处理`Observable`的数据：\n\n- `next`：当Observable发送新的值，即调用其中的next方法时，观察者的`next`方法就会被调用。\n- `complete`：在`Observable`中完成遍历即调用其中的`complete`方法时，观察者的`complete`方法会被调用，在此之后的`next`方法不会执行。\n- `error`：在`Observable`中出现错误时，观察者的`error`方法会被调用。\n\n```js\nlet observable3 = new Observable((subscriber) => {\n  subscriber.next('Inuyasha');\n  subscriber.next('Kikyo');\n  subscriber.complete();\n  subscriber.next('Kagome');\n});\n\n// 与Promise类似的处理方法\nlet observer = {\n  next: function (value) {\n    console.log(value);\n  },\n  error: function (error) {\n    console.log(error);\n  },\n  complete: function () {\n    console.log('complete');\n  },\n};\n\nobservable3.subscribe(observer);\n// Inuyasha\n// Kikyo\n// complete\n```\n\n需要注意的是，只传入一个函数时会被默认指定为`next`的回调函数。\n\n# 创建 Observable 实例的常用方法\n\n## of\n\n> `of<T>(...args: (SchedulerLike | T)[]): Observable<T>`\n> \n\n需要注意其参数与方法`Function.prototype.call`类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。\n\n![of.png](https://rxjs.dev/assets/images/marble-diagrams/of.png)\n\n```js\nimport { of } from 'rxjs';\n\nconst source = of(1, 2, 3);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## from\n\n> `from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>`\n> \n\n该方法弥补了`of`方法不能直接传入数组等数据结构等缺陷，参数为`Array`、`类数组对象`、`Promise`、`可迭代对象`或`类 Observable 对象`\n\n```js\nimport { from } from 'rxjs';\n\nconst source = from([1, 2, 3]);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## interval\n\n> `interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n这个方法能够实现JS中`setInterval`的功能，需要注意第一个参数是以`ms`为单位的时间间隔。\n\n![图片来自rxjs官网](https://rxjs.dev/assets/images/marble-diagrams/interval.png)\n\n```js\nimport { interval } from 'rxjs';\n\nconst numbers = interval(2000);\n// 以2秒的间隔从0开始在控制台输出数字\nnumbers.subscribe((n) => console.log(n));\n```\n\n## Timer\n\n> `timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n该方法与`Interval`类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。\n\n```js\nimport { timer } from 'rxjs';\n\n// 只传一个参数表示指需要调用一次\nconst source1 = timer(1000);\nsource1.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 0\n// complete\n\n// 第一次调用后会每隔1秒调用1次\nconst source2 = timer(2000, 1000);\nsource2.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 2秒之后开始输出 0 1 2 3 4 ...\n\n```\n\n## EMPTY, NEVER\n\n这两个`Observable`常量分别用来替代在以前版本的`empty`方法与`never`方法，前者会直接`complete`，后者不会被执行。\n\n```js\nimport { EMPTY, NEVER } from 'rxjs';\n\nEMPTY.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// complete\n\n// 不会被执行\nNEVER.subscribe(() => console.log('never be called'));\n```\n\n## throwError\n\n> `throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never>`\n> \n\n该方法会直接抛出异常，与`Promise.reject`方法类似。\n\n```js\nimport { throwError } from 'rxjs';\n\nthrowError(() => console.log('Ops!')).subscribe();\n```\n\n## **Subscription**\n\n在对`Observable`进行`subscribe`之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟`setTimeout`、`setInterval`等方法一样，需要我们在使用完后手动进行释放。\n\n```js\nimport { interval } from 'rxjs';\n\nconst source = interval(1000);\nconst subscriptipn = source.subscribe();\n\n// 使用完后手动释放\nsubscriptipn.unsubscribe();\n```\n\n# 参考资料\n\n**[30天精通RxJS](https://blog.jerry-hong.com/series/rxjs)**\n\n**[RxJS官方文档](https://rxjs.dev/)**\n\n**ECMAScript 6 入门**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/rxjs-first-sight.md","raw":"---\ntitle: 初见 RxJS\ndate: 2022-05-06 15:10:16\nupdated:\ntags: \n  - RxJS\ncategories: \n  - [前端, RxJS]\nkeywords:\ndescription:\ntop_img:\ncover: https://fastly.jsdelivr.net/gh/ltanfr/blog-hexo-butterfly@gh-pages/img/rxjs-first-sight.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n\n---\n# 初识 RxJS\n\n# 写在前面\n\n刚入职了新公司，负责维护一个原来使用`Angular`构建的项目，奈何自己一直使用的是`React`。不过既来之，则安之。顺便插一句，熟悉`Vue`的朋友应该会觉得很亲切，其中很多语法如`v-if`、`v-bind`，与`Angualr`中的`ngIf`、`ngFor`的用法都如出一辙。\n\n看了两周左右的`Angular`，说一下第一印象，`Angular`确实是一个非常齐全的框架，它不像`Vue`跟`React`需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在`Angular`中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。\n其中`RxJS`就是`Anuglar`提供的异步编程方案。\n\n`RxJS`官网描述自己是`Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）`，也可以把`RxJS`当做处理异步行为的`Lodash`库`（Think of RxJS as Lodash for events）`。`RxJS`是编程范式函数式编程(`Functional Programming`)与响应式编程(`Reactive Programming`)的结合，换句话说，`RxJS`是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了`J.H. Blog`的`30天精通RxJS`系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。\n\n\n# 什么是Observable\n## Observer Pattern\n\n观察者模式在程序设计中并不少见，如`DOM`操作中的通过给`DOM`元素绑定相应的事件去监听该`DOM`元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的`Redux`的实现，其都是以观察者模式的思想为核心。\n\n```js\n// redux 的简单实现\nexport const createStore = (reducer) => {\n  // 公共状态\n  let currentState = {};\n  // 监听者队列\n  let listeners = [];\n  // getter\n  function getState() {\n    return currentState;\n  }\n  // setter\n  function dispatch(action) {\n    currentState = reducer(currentState, action);\n\t\t// 当dispatch触发，即状态更新时通知listeners\n    listeners.forEach((fn) => fn());\n  }\n  // 添加监听事件\n  function subscribe(fn) {\n    listeners.push(fn);\n  }\n  // 初始化store数据\n  dispatch({ type: \"@@REDUX_INIT\" });\n  return { getState, dispatch, subscribe };\n};\n```\n\n## Iterator Pattern\n\n`iterator`（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如`Array`、`Map`、`Set`、`String`等JS中内置的数据结构都实现了该接口。实现`iterator`接口的方法是为其添加`Symbol.iterator`属性，其中包含`next`方法，该方法返回的迭代器对象包含两个属性：`value`和`done`。`done`指的是遍历是否结束，`value`为下一次迭代的值，`done`为`true`时`value`一般为`undefined`。\n\n```js\nconst iterableExample = {\n\t[Symbol.iterator]: function() {\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: 'Sunday',\n\t\t\t\t\tdone: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst arr = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\nconst iterator = arr[Symbol.iterator]()\niterator.next() // {value: 'Monday', done: false}\niterator.next() // {value: 'Tuesday', done: false}\niterator.next() // {value: 'Wednesday', done: false}\n```\n\n迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了`iterator`与`iterable`的概念。\n\n## Observable\n\n`Observable`结合了`Observer`与`Iterator`的思想，像`Observe`与`Iterator`一样以流的形式包装数据，同时能够以`Observe`的方式通知更新，以`Iterator`的方式去处理数据。这样说起来可能有点抽象，但是结合`Observable`实例就能很好地理解。\n\n# 创建 Observable\n\n创建`Observable`实例的基本方法,使用`Observable`构造函数来创建一个`Observable`实例对象，其中可以传入一个回调函数,接收一个`subscriber`，用来指定该如何处理数据。需要注意的是，`Observable`作为被观察的对象，需要使用`subscribe`方法来通知`subscriber`去对`Observable`作出处理。\n\n```js\nimport { Observable } from 'rxjs';\n\nlet observalbe1 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  subscriber.next('Nana');\n});\n\n// 使用subscrible方法来订阅Observable\nobservalbe1.subscribe(console.log);\n// Suda\n// Nana\n\n// 处理非同步行为\nlet observalbe2 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  setTimeout(() => {\n    subscriber.next('Kasumi');\n  }, 1000);\n  subscriber.next('Nana');\n});\n\nobservalbe2.subscribe(console.log);\n// Suda\n// Nana\n// Kasumi\n\n```\n\n订阅`Observable`的被称为观察者，观察者具有三种行为（方法）来处理`Observable`的数据：\n\n- `next`：当Observable发送新的值，即调用其中的next方法时，观察者的`next`方法就会被调用。\n- `complete`：在`Observable`中完成遍历即调用其中的`complete`方法时，观察者的`complete`方法会被调用，在此之后的`next`方法不会执行。\n- `error`：在`Observable`中出现错误时，观察者的`error`方法会被调用。\n\n```js\nlet observable3 = new Observable((subscriber) => {\n  subscriber.next('Inuyasha');\n  subscriber.next('Kikyo');\n  subscriber.complete();\n  subscriber.next('Kagome');\n});\n\n// 与Promise类似的处理方法\nlet observer = {\n  next: function (value) {\n    console.log(value);\n  },\n  error: function (error) {\n    console.log(error);\n  },\n  complete: function () {\n    console.log('complete');\n  },\n};\n\nobservable3.subscribe(observer);\n// Inuyasha\n// Kikyo\n// complete\n```\n\n需要注意的是，只传入一个函数时会被默认指定为`next`的回调函数。\n\n# 创建 Observable 实例的常用方法\n\n## of\n\n> `of<T>(...args: (SchedulerLike | T)[]): Observable<T>`\n> \n\n需要注意其参数与方法`Function.prototype.call`类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。\n\n![of.png](https://rxjs.dev/assets/images/marble-diagrams/of.png)\n\n```js\nimport { of } from 'rxjs';\n\nconst source = of(1, 2, 3);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## from\n\n> `from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>`\n> \n\n该方法弥补了`of`方法不能直接传入数组等数据结构等缺陷，参数为`Array`、`类数组对象`、`Promise`、`可迭代对象`或`类 Observable 对象`\n\n```js\nimport { from } from 'rxjs';\n\nconst source = from([1, 2, 3]);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## interval\n\n> `interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n这个方法能够实现JS中`setInterval`的功能，需要注意第一个参数是以`ms`为单位的时间间隔。\n\n![图片来自rxjs官网](https://rxjs.dev/assets/images/marble-diagrams/interval.png)\n\n```js\nimport { interval } from 'rxjs';\n\nconst numbers = interval(2000);\n// 以2秒的间隔从0开始在控制台输出数字\nnumbers.subscribe((n) => console.log(n));\n```\n\n## Timer\n\n> `timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n该方法与`Interval`类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。\n\n```js\nimport { timer } from 'rxjs';\n\n// 只传一个参数表示指需要调用一次\nconst source1 = timer(1000);\nsource1.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 0\n// complete\n\n// 第一次调用后会每隔1秒调用1次\nconst source2 = timer(2000, 1000);\nsource2.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 2秒之后开始输出 0 1 2 3 4 ...\n\n```\n\n## EMPTY, NEVER\n\n这两个`Observable`常量分别用来替代在以前版本的`empty`方法与`never`方法，前者会直接`complete`，后者不会被执行。\n\n```js\nimport { EMPTY, NEVER } from 'rxjs';\n\nEMPTY.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// complete\n\n// 不会被执行\nNEVER.subscribe(() => console.log('never be called'));\n```\n\n## throwError\n\n> `throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never>`\n> \n\n该方法会直接抛出异常，与`Promise.reject`方法类似。\n\n```js\nimport { throwError } from 'rxjs';\n\nthrowError(() => console.log('Ops!')).subscribe();\n```\n\n## **Subscription**\n\n在对`Observable`进行`subscribe`之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟`setTimeout`、`setInterval`等方法一样，需要我们在使用完后手动进行释放。\n\n```js\nimport { interval } from 'rxjs';\n\nconst source = interval(1000);\nconst subscriptipn = source.subscribe();\n\n// 使用完后手动释放\nsubscriptipn.unsubscribe();\n```\n\n# 参考资料\n\n**[30天精通RxJS](https://blog.jerry-hong.com/series/rxjs)**\n\n**[RxJS官方文档](https://rxjs.dev/)**\n\n**ECMAScript 6 入门**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"rxjs-first-sight","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cl3re6une001hvuo9f6ry4ai8","content":"<h1 id=\"初识-RxJS\"><a href=\"#初识-RxJS\" class=\"headerlink\" title=\"初识 RxJS\"></a>初识 RxJS</h1><h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>刚入职了新公司，负责维护一个原来使用<code>Angular</code>构建的项目，奈何自己一直使用的是<code>React</code>。不过既来之，则安之。顺便插一句，熟悉<code>Vue</code>的朋友应该会觉得很亲切，其中很多语法如<code>v-if</code>、<code>v-bind</code>，与<code>Angualr</code>中的<code>ngIf</code>、<code>ngFor</code>的用法都如出一辙。</p>\n<p>看了两周左右的<code>Angular</code>，说一下第一印象，<code>Angular</code>确实是一个非常齐全的框架，它不像<code>Vue</code>跟<code>React</code>需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在<code>Angular</code>中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。<br>其中<code>RxJS</code>就是<code>Anuglar</code>提供的异步编程方案。</p>\n<p><code>RxJS</code>官网描述自己是<code>Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）</code>，也可以把<code>RxJS</code>当做处理异步行为的<code>Lodash</code>库<code>（Think of RxJS as Lodash for events）</code>。<code>RxJS</code>是编程范式函数式编程(<code>Functional Programming</code>)与响应式编程(<code>Reactive Programming</code>)的结合，换句话说，<code>RxJS</code>是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了<code>J.H. Blog</code>的<code>30天精通RxJS</code>系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。</p>\n<h1 id=\"什么是Observable\"><a href=\"#什么是Observable\" class=\"headerlink\" title=\"什么是Observable\"></a>什么是Observable</h1><h2 id=\"Observer-Pattern\"><a href=\"#Observer-Pattern\" class=\"headerlink\" title=\"Observer Pattern\"></a>Observer Pattern</h2><p>观察者模式在程序设计中并不少见，如<code>DOM</code>操作中的通过给<code>DOM</code>元素绑定相应的事件去监听该<code>DOM</code>元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的<code>Redux</code>的实现，其都是以观察者模式的思想为核心。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux 的简单实现</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createStore</span> = (<span class=\"params\">reducer</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 公共状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 监听者队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> listeners = [];</span><br><span class=\"line\">  <span class=\"comment\">// getter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">getState</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// setter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dispatch</span>(<span class=\"params\">action</span>) &#123;</span><br><span class=\"line\">    currentState = <span class=\"title function_\">reducer</span>(currentState, action);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当dispatch触发，即状态更新时通知listeners</span></span><br><span class=\"line\">    listeners.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> <span class=\"title function_\">fn</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加监听事件</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">subscribe</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    listeners.<span class=\"title function_\">push</span>(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化store数据</span></span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;@@REDUX_INIT&quot;</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Iterator-Pattern\"><a href=\"#Iterator-Pattern\" class=\"headerlink\" title=\"Iterator Pattern\"></a>Iterator Pattern</h2><p><code>iterator</code>（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>等JS中内置的数据结构都实现了该接口。实现<code>iterator</code>接口的方法是为其添加<code>Symbol.iterator</code>属性，其中包含<code>next</code>方法，该方法返回的迭代器对象包含两个属性：<code>value</code>和<code>done</code>。<code>done</code>指的是遍历是否结束，<code>value</code>为下一次迭代的值，<code>done</code>为<code>true</code>时<code>value</code>一般为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iterableExample = &#123;</span><br><span class=\"line\">\t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">next</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">value</span>: <span class=\"string\">&#x27;Sunday&#x27;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">done</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">&#x27;Monday&#x27;</span>, <span class=\"string\">&#x27;Tuesday&#x27;</span>, <span class=\"string\">&#x27;Wednesday&#x27;</span>, <span class=\"string\">&#x27;Thursday&#x27;</span>, <span class=\"string\">&#x27;Friday&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> iterator = arr[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]()</span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Monday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Tuesday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Wednesday&#x27;, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了<code>iterator</code>与<code>iterable</code>的概念。</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p><code>Observable</code>结合了<code>Observer</code>与<code>Iterator</code>的思想，像<code>Observe</code>与<code>Iterator</code>一样以流的形式包装数据，同时能够以<code>Observe</code>的方式通知更新，以<code>Iterator</code>的方式去处理数据。这样说起来可能有点抽象，但是结合<code>Observable</code>实例就能很好地理解。</p>\n<h1 id=\"创建-Observable\"><a href=\"#创建-Observable\" class=\"headerlink\" title=\"创建 Observable\"></a>创建 Observable</h1><p>创建<code>Observable</code>实例的基本方法,使用<code>Observable</code>构造函数来创建一个<code>Observable</code>实例对象，其中可以传入一个回调函数,接收一个<code>subscriber</code>，用来指定该如何处理数据。需要注意的是，<code>Observable</code>作为被观察的对象，需要使用<code>subscribe</code>方法来通知<code>subscriber</code>去对<code>Observable</code>作出处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用subscrible方法来订阅Observable</span></span><br><span class=\"line\">observalbe1.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理非同步行为</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kasumi&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observalbe2.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"><span class=\"comment\">// Kasumi</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>订阅<code>Observable</code>的被称为观察者，观察者具有三种行为（方法）来处理<code>Observable</code>的数据：</p>\n<ul>\n<li><code>next</code>：当Observable发送新的值，即调用其中的next方法时，观察者的<code>next</code>方法就会被调用。</li>\n<li><code>complete</code>：在<code>Observable</code>中完成遍历即调用其中的<code>complete</code>方法时，观察者的<code>complete</code>方法会被调用，在此之后的<code>next</code>方法不会执行。</li>\n<li><code>error</code>：在<code>Observable</code>中出现错误时，观察者的<code>error</code>方法会被调用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> observable3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Inuyasha&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">complete</span>();</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kagome&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与Promise类似的处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = &#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">observable3.<span class=\"title function_\">subscribe</span>(observer);</span><br><span class=\"line\"><span class=\"comment\">// Inuyasha</span></span><br><span class=\"line\"><span class=\"comment\">// Kikyo</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，只传入一个函数时会被默认指定为<code>next</code>的回调函数。</p>\n<h1 id=\"创建-Observable-实例的常用方法\"><a href=\"#创建-Observable-实例的常用方法\" class=\"headerlink\" title=\"创建 Observable 实例的常用方法\"></a>创建 Observable 实例的常用方法</h1><h2 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h2><blockquote>\n<p><code>of&lt;T&gt;(...args: (SchedulerLike | T)[]): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>需要注意其参数与方法<code>Function.prototype.call</code>类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。</p>\n<p><img src=\"https://rxjs.dev/assets/images/marble-diagrams/of.png\" alt=\"of.png\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">of</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"from\"><a href=\"#from\" class=\"headerlink\" title=\"from\"></a>from</h2><blockquote>\n<p><code>from&lt;T&gt;(input: ObservableInput&lt;T&gt;, scheduler?: SchedulerLike): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>该方法弥补了<code>of</code>方法不能直接传入数组等数据结构等缺陷，参数为<code>Array</code>、<code>类数组对象</code>、<code>Promise</code>、<code>可迭代对象</code>或<code>类 Observable 对象</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">from</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"interval\"><a href=\"#interval\" class=\"headerlink\" title=\"interval\"></a>interval</h2><blockquote>\n<p><code>interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>这个方法能够实现JS中<code>setInterval</code>的功能，需要注意第一个参数是以<code>ms</code>为单位的时间间隔。</p>\n<p><img src=\"https://rxjs.dev/assets/images/marble-diagrams/interval.png\" alt=\"图片来自rxjs官网\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = <span class=\"title function_\">interval</span>(<span class=\"number\">2000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 以2秒的间隔从0开始在控制台输出数字</span></span><br><span class=\"line\">numbers.<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h2><blockquote>\n<p><code>timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>该方法与<code>Interval</code>类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; timer &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只传一个参数表示指需要调用一次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = <span class=\"title function_\">timer</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">source1.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一次调用后会每隔1秒调用1次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = <span class=\"title function_\">timer</span>(<span class=\"number\">2000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">source2.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 2秒之后开始输出 0 1 2 3 4 ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EMPTY-NEVER\"><a href=\"#EMPTY-NEVER\" class=\"headerlink\" title=\"EMPTY, NEVER\"></a>EMPTY, NEVER</h2><p>这两个<code>Observable</code>常量分别用来替代在以前版本的<code>empty</code>方法与<code>never</code>方法，前者会直接<code>complete</code>，后者不会被执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"variable constant_\">EMPTY</span>, <span class=\"variable constant_\">NEVER</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">EMPTY</span>.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不会被执行</span></span><br><span class=\"line\"><span class=\"variable constant_\">NEVER</span>.<span class=\"title function_\">subscribe</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;never be called&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"throwError\"><a href=\"#throwError\" class=\"headerlink\" title=\"throwError\"></a>throwError</h2><blockquote>\n<p><code>throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable&lt;never&gt;</code></p>\n</blockquote>\n<p>该方法会直接抛出异常，与<code>Promise.reject</code>方法类似。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; throwError &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">throwError</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Ops!&#x27;</span>)).<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a><strong>Subscription</strong></h2><p>在对<code>Observable</code>进行<code>subscribe</code>之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟<code>setTimeout</code>、<code>setInterval</code>等方法一样，需要我们在使用完后手动进行释放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">interval</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> subscriptipn = source.<span class=\"title function_\">subscribe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用完后手动释放</span></span><br><span class=\"line\">subscriptipn.<span class=\"title function_\">unsubscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong><a href=\"https://blog.jerry-hong.com/series/rxjs\">30天精通RxJS</a></strong></p>\n<p><strong><a href=\"https://rxjs.dev/\">RxJS官方文档</a></strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{"bangumis":{"wantWatch":[],"watching":[{"title":"间谍过家家","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a9497ed9b2ad8fd3b77289734769f81bd3948d75.png","totalCount":"未完结","id":28237119,"follow":"822.3 万","view":"1.3 亿","danmaku":"63.1 万","coin":"110.1 万","score":9.8,"des":"每个人都有不可告人的一面。\n\n这是一个世界各国均暗地里进行激烈情报战的时代。奥斯塔尼亚（Ostania）与维斯达利斯（Westalis）的冷战状态已经持续数十年。\n\n<黄昏>是维斯达利斯情报局奥斯塔尼..."},{"title":"四月是你的谎言","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/f5128c939b24909c7cb75bab51be0ee0c4d1b33a.jpg","totalCount":"全22话","id":1699,"follow":"548.5 万","view":"1.7 亿","danmaku":"479.0 万","coin":"124.8 万","score":9.8,"des":"从小接受母亲严格的钢琴训练，并在各种音乐比赛上获胜的“神童”——有马公生，11岁那年因为母亲去世，他从此变得听不见钢琴的声音，因而放弃了弹奏钢琴。\n国中三年级时，在青梅竹马椿的引见下，公生认识了与他同..."}],"watched":[{"title":"浪客剑心","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/84ea1b714f6e49e2c6640260d7bc4daaf550d4a5.jpg","totalCount":"全94话","id":2303,"follow":"69.8 万","view":"1947.6 万","danmaku":"16.0 万","coin":"5.4 万","score":9.8,"des":"故事发生在维新政府建立之后的幕末时代。在一个小村庄里，生活着一位个性正直的少女神谷薰。村里有个名叫比留间五兵卫的男人，自称“拔刀斋”而到处作恶，阿薰为阻止五兵卫手持竹刀与之拼命，但却不是他的对手。五兵..."},{"title":"猫和老鼠（1975）","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/image/71c5ec79a7137a08558865463a0649e6b8a4bbd3.jpg","totalCount":"全16话","id":28235531,"follow":"247.1 万","view":"367.5 万","danmaku":4949,"coin":7960,"score":9.8,"des":"汤姆和杰瑞（现在戴了红色的领结）在世界各地参加体育比赛，他们互相恶作剧的同时也会一起帮助他人解决困难。在这个系列里，汤姆和杰瑞成为好朋友。..."},{"title":"奇巧出租车","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/efc163075e089edb94873d56debbfaf913ac1b60.png","totalCount":"全13话","id":28233927,"follow":"73.0 万","view":"1150.2 万","danmaku":"9.6 万","coin":"12.8 万","score":9.9,"des":"平凡的出租车司机・小户川。\n没有亲戚，也不想与人扯上关系，有点古怪且寡言的司机。\n兴趣是在睡前听落语以及工作时听收音机。\n目前，唯一有联络的是医生朋友・刚力以及高中同级生・柿花。\n\n本该载着各式各样的..."},{"title":"夏目友人帐","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/99c549494d9425f6455bd45a151f4d26397d6151.png","totalCount":"全13话","id":1660,"follow":"321.3 万","view":"4893.3 万","danmaku":"278.1 万","coin":"15.1 万","score":9.8,"des":"夏目贵志生来拥有强大的灵力，能感知平常人所无法接触的妖怪神明的存在。因父母双亡，他多年间辗转于互相推卸责任的亲戚之间，又受到同龄人的欺负，未曾与任何人深交，造成性格一定程度上的孤僻。夏目本性和善，对于..."},{"title":"夏目友人帐 第五季 特别篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/db07fbd76802adb295c89b0c64207f913980720a.jpg","totalCount":"全2话","id":8512,"follow":"53.9 万","view":"567.1 万","danmaku":"4.5 万","coin":"2.8 万","score":9.8,"des":"猫咪老师兴高采烈地出门参加奇怪的宴会。在意宴会情况紧随其后的的夏目在抵达的废宅中发现了浑身是伤的妖怪「游蔓」。夏目刚一叫他、只听游蔓说道「接下来换我当鬼了」、宅中顿时响起妖怪们的喧闹声。一问才知、在这..."},{"title":"犬夜叉完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/145ae170aad690934481271529dd62632c0b3da6.jpg","totalCount":"全26话","id":28223352,"follow":"72.5 万","view":"4478.3 万","danmaku":"114.5 万","coin":"8.4 万","score":9.8,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"我们仍未知道那天所看见的花的名字。","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6c1ca4159442a6de3577bbee5e583be72b00499f.jpg","totalCount":"全11话","id":835,"follow":"426.3 万","view":"5075.5 万","danmaku":"434.2 万","coin":"53.0 万","score":9.6,"des":"从小一起长大的六个孩子，在升上高中之后彼此有了距离。不太与人们接触的宅男宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道……只有幼年死去的本间芽衣..."},{"title":"夏目友人帐 第六季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/39716626d611a765c44ca27054f3526210c4d5cb.jpg","totalCount":"全13话","id":5977,"follow":"218.5 万","view":"4968.2 万","danmaku":"125.7 万","coin":"29.6 万","score":9.8,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 唤石者与怪异的访客","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6cf43708b779cde84ad285ff4e3a080de98df0af.png","totalCount":"全1话","id":28234316,"follow":"567.0 万","view":"1349.4 万","danmaku":"18.0 万","coin":"17.8 万","score":9.9,"des":"本作由【唤石者】与【怪异的访客】两个人气短篇集锦而成。讲述生来便能看见各种妖怪的夏目，与自称保镖的猫咪老师一同邂逅的一系列温暖故事。\n【唤石者】一天夏目在森林中遇到一只小妖怪——密实。密实称自己肩负「..."},{"title":"夏目友人帐 第五季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ecfa873a788ac7e8ddeee9b08755d3a8e6f46845.jpg","totalCount":"全11话","id":5550,"follow":"263.0 万","view":"5462.5 万","danmaku":"154.0 万","coin":"31.1 万","score":9.7,"des":"从小就能看见妖怪的少年夏目贵志。自从他从祖母玲子那里继承了与妖怪成为主从并将其名字书写在上的契约书“友人帐”以来，便与自称为保镖的妖怪猫咪老师一同，开始了将名字返还给妖怪的每一天。夏目与各种各样的妖怪..."},{"title":"夏目友人帐 OVA","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/a8172a69f9dc70f183c96b29510901fb4c66c031.png","totalCount":"全2话","id":3446,"follow":"60.4 万","view":"535.1 万","danmaku":"6.1 万","coin":"2.6 万","score":9.7,"des":"散歩中的猫咪老师遇到了一对迷路的双子兄妹，从而展开了一段奇妙的故事。 ..."},{"title":"夏目友人帐 第四季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1663,"follow":"116.3 万","view":"2328.8 万","danmaku":"154.3 万","coin":"6.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第三季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/88f879ff41c48361f1d2b3caf3c6dc93f0376894.jpg","totalCount":"全13话","id":1662,"follow":"118.0 万","view":"2423.4 万","danmaku":"168.6 万","coin":"9.3 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。与玲子一样，他也能看到人眼不可见之物。被同龄人叫成“骗子”，成为了被疏远的一员。唯一继承了玲子血统的他，做出了一个重要的决定：将..."},{"title":"夏目友人帐 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/2f382098ca70a645f90ecd1c37ed0890532b6a6e.jpg","totalCount":"全13话","id":1661,"follow":"128.8 万","view":"2732.0 万","danmaku":"207.5 万","coin":"7.9 万","score":9.8,"des":"夏目玲子之孙——夏目贵志从祖母的遗物中得到了由契约书所做成的“友人帐”。同样拥有看见鬼神的能力、唯一继承了玲子血统的他却做出了一个重要的决定：将玲子夺过来的妖怪们的名字一一归还。\n伴随着归还名字的行动..."},{"title":"漂流少年","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/5ab04233a441e3b5cc68d0c88bd39d1e5a89cc33.png","totalCount":"全12话","id":28234650,"follow":"103.2 万","view":"1708.7 万","danmaku":"12.0 万","coin":"17.4 万","score":9.7,"des":"漫长的暑假已然过半的8月16日。聚集在学校里的中学三年级学生·长良一行人突然被卷进从未设想过的事态之中。\n长良本人自不必说，神秘的转校生·希和瑞穗以及朝风等36名同班同学，都随着学校一起在异次元之中漂..."},{"title":"新机动战记高达W剧场版 无尽的华尔兹","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/3447d18e71d1ce4ba04e525d3d22a5e84301f372.jpg","totalCount":"全1话","id":28227667,"follow":"6.5 万","view":"135.4 万","danmaku":"1.4 万","coin":5297,"score":9.8,"des":"巴顿财团利用前OZ统帅托雷斯之女玛丽梅亚作傀儡领袖成立军队，以新建之殖民地X18999为基地，同时胁持担任地球外交官的莉莉娜作人质，企图实行第二次流星作战。希罗等人进入殖民地化解危机并把高达取回作战。..."},{"title":"浪客剑心 追忆篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ee2924296d2ef7a7235b229ca3a0a40039f603f5.jpg","totalCount":"全4话","id":28229015,"follow":"51.1 万","view":"445.3 万","danmaku":"3.4 万","coin":"3.8 万","score":9.9,"des":"幕府时代末期，外忧内患，山河动荡，百姓生活困苦，且生命时刻受到威胁。少年心太因其善良纯洁之心感动飞天御剑流高手比古清十郎，被其收入门下学习剑法，更名剑心。\r\n在国家危难之际，年轻的剑心怀揣改变时代的梦..."},{"title":"紫罗兰永恒花园","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/6565f297b31fb4a4a0337557033426930c3b88c0.png","totalCount":"全14话","id":8892,"follow":"766.5 万","view":"1.6 亿","danmaku":"337.5 万","coin":"199.3 万","score":9.8,"des":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界走向了和平。\n在战争中作为军人的薇尔莉特•伊芙加登，怀抱着对她来说无比重要之人留下的“话语”，离开军队来到了大港口城市。\n踊跃的人群在排列着煤气灯..."},{"title":"犬夜叉","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/0c39256b7c701547a0ce7082740dc082a50c9e68.jpg","totalCount":"全167话","id":28222083,"follow":"229.3 万","view":"2.5 亿","danmaku":"792.6 万","coin":"32.8 万","score":9.9,"des":"《犬夜叉》是根据日本漫画家高桥留美子所著同名作品改编的电视动画，故事讲述半妖少年——犬夜叉和穿越时空的少女——日暮戈薇，以及法师弥勒、驱魔师珊瑚、叉尾妖猫云母、小狐妖七宝一同对抗死敌奈落，并四处寻找四..."},{"title":"齐木楠雄的灾难 始动篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/ba59822eded39b5254fb01448a7f1502101d5624.png","totalCount":"全6话","id":28223748,"follow":"371.9 万","view":"3011.7 万","danmaku":"19.9 万","coin":"17.7 万","score":9.8,"des":"在电视剧中堪称帅气的超能力，对于高中生齐木楠雄来说只是招致灾难的元凶。作为新动画系列展开的楠雄的日常又会如何！？..."},{"title":"路人超能100 II(灵能百分百 第二季)","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/216e1bdaf88244215a13b1154116805ee9adbe07.png","totalCount":"全13话","id":4762734,"follow":"283.5 万","view":"1.0 亿","danmaku":"97.4 万","coin":"55.6 万","score":9.9,"des":"当有什么东西达到“100”的时候，就会爆发的少年·路人（龙套）。外表极其普通——不如说是不起眼。不擅长迎合气氛的他，实际上拥有着强力的超能力。盯上了这样的他的能力，而接连现身的伪灵能力者以及宗教团体、..."},{"title":"多罗罗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/3fc16a667502cbff226e585eb660a96a20c7458c.png","totalCount":"全24话","id":4312482,"follow":"450.6 万","view":"1.8 亿","danmaku":"143.5 万","coin":"73.6 万","score":9.4,"des":"他们向着命运抗争，在那尽头等待他们的是人心，还是业障。\n时值乱世。\n名为景光的醍醐将军，向某个寺庙殿堂中的12尊魔神像祈求早日结束战乱。\n作为代价，他的嫡子在出生时就失去了身体的某些部位，被丢弃在河流..."},{"title":"异度侵入 ID:INVADED","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9bf9e66968f85b33ec3769a16c86b36dc984abbc.png","totalCount":"全13话","id":28224080,"follow":"474.9 万","view":"1.2 亿","danmaku":"153.3 万","coin":"105.8 万","score":9.8,"des":"本片讲述利用能检测出人们杀意的装置以及利用思想粒子做出的“井”，来探知事件真相的科幻故事。..."},{"title":"新机动战记高达W TV版","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/106e9abda8d910f0a7806e3c612fc850d36ba555.jpg","totalCount":"全49话","id":131612,"follow":"16.1 万","view":"567.1 万","danmaku":"11.9 万","coin":8285,"score":9.5,"des":"《新机动战记高达 W》，是1995年4月到1996年3月在日本朝日电视台播映的高达系列作品电视系列动画片共49话。本作是高达系列首部成功打入女性观众市场的作品。\r\n《新机动战记高达 W》与《机动武斗传..."},{"title":"精灵宝可梦 无印","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/297063889e7836facea595b63eb6330f51904a24.jpg","totalCount":"全271话","id":5761,"follow":"76.3 万","view":"4993.3 万","danmaku":"198.1 万","coin":"8.1 万","score":9.8,"des":"《精灵宝可梦》动画改编自同名游戏，讲述了立志成为宝可梦大师的小智和皮卡丘结伴旅行的故事。一路上，小智邂逅了不少同伴、劲敌、好友，和他们展开了一次又一次冒险。《精灵宝可梦 无印》共分为关都地区石英联盟、..."},{"title":"鬼灭之刃","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/4179b4398bad6f92e876e352cae21be7b8ceb8bf.png","totalCount":"全26话","id":22718131,"follow":"1178.0 万","view":"8.6 亿","danmaku":"1001.8 万","coin":"389.9 万","score":9.7,"des":"大正时期，日本。心地善良的卖炭少年·炭治郎，有一天他的家人被鬼杀死了。而唯一幸存下来的妹妹——祢豆子变成了鬼。被绝望的现实打垮的炭治郎，为了寻找让妹妹变回人类的方法，决心朝着“鬼杀队”的道路前进。\n人..."},{"title":"游戏王 怪兽之决斗","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/9ae207910892d1fdf9924c73b15df2e42e256f87.jpg","totalCount":"全224话","id":3054,"follow":"84.7 万","view":"1.1 亿","danmaku":"246.2 万","coin":"14.9 万","score":9.8,"des":"《游☆戏☆王 Duel Monsters》改编自高桥和希所作的漫画《游戏王》，于2000-2004年间在东京电视台播出。故事以原作剧情为主，但因为中途超出了漫画连载进度，因此加入了相当程度的原创角色和..."},{"title":"齐木楠雄的灾难","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/7449bdd3c8067fec587a0cf2a8f7f1f5275b757f.jpg","totalCount":"全24话","id":5069,"follow":"302.7 万","view":"1.5 亿","danmaku":"153.0 万","coin":"33.6 万","score":9.7,"des":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能..."},{"title":"齐木楠雄的灾难 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/5e32e992cbb666d42b931a1ab8e3752f9d490b93.jpg","totalCount":"全24话","id":8812,"follow":"241.3 万","view":"1.2 亿","danmaku":"134.1 万","coin":"35.6 万","score":9.8,"des":"能够窥视别人的内心、看透墙壁、以念力移动物品、瞬间移动，一出生就拥有一切的超能力！他就是沉默寡言的超能力者，齐木楠雄。在一个平凡的日本家庭，父母都很普通，齐木楠雄的出生却不平凡。齐木楠雄天生下来就是个..."},{"title":"机动战士高达 铁血的奥尔芬斯 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a20296165901b6402c54d78c42d0c3274fca6cd1.png","totalCount":"全25话","id":4310082,"follow":"31.4 万","view":"1825.5 万","danmaku":"55.7 万","coin":"3.4 万","score":4,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达独角兽(UC) RE:0096","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/bc645c01dd9dce61bfc406d9368c3a19f401631a.jpg","totalCount":"全22话","id":122732,"follow":"62.2 万","view":"3541.2 万","danmaku":"32.3 万","coin":"6.2 万","score":9.3,"des":"在第二次新吉翁战争、别名‘逆袭的夏亚’终结后，地球圈取得了短暂的和平。这之后3年，宇宙世纪0096年。在工业殖民地“工业7号”上进行了一项秘密交涉。和地球联邦政府有秘密协议，并依此发展的‘毕斯特财团’..."},{"title":"机动战士高达00 第二季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/1d7a969e8f1045739c596de89a963e30475aff0e.jpg","totalCount":"全25话","id":1193,"follow":"36.6 万","view":"2367.9 万","danmaku":"60.4 万","coin":"4.0 万","score":9.8,"des":"天人与联合国军的最终决战后过了四年。建立地球联邦政府的人类，为了追求更进一步的国家间之统合，以及人类意识的统一，在联合正规军之外，设立了独立治安维持部队“A-Laws”，目的为对所有危害联合的势力与主..."},{"title":"机动战士高达00","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/35b11bf59eb3fd12f0387951510a5d722d7435e5.jpg","totalCount":"全25话","id":1192,"follow":"60.9 万","view":"2376.2 万","danmaku":"52.8 万","coin":"4.4 万","score":9.7,"des":"在西历2307年，虽然化石燃料枯竭了，但是人类得到了截然不同的新型能源。三台巨大的轨道升降机以及伴随它们的大规模的太阳光发电系统。但是能得到这个系统恩惠的，只有一部分大国和其同盟国而已。\n拥有三台轨道..."},{"title":"JOJO的奇妙冒险","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/9d8d2922b08f3d08d018e6e59e49607cf16d39e6.png","totalCount":"全26话","id":28223479,"follow":"547.3 万","view":"1.8 亿","danmaku":"488.3 万","coin":"52.5 万","score":9.8,"des":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。\n那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n时光..."},{"title":"机动战士高达：闪光的哈萨维","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/image/764f19dc9ad71bc660d91e92ef4b334682d8f2ed.png","totalCount":"全1话","id":28234742,"follow":"33.0 万","view":"413.3 万","danmaku":"4.0 万","coin":"7.6 万","score":9.8,"des":"第二次新吉翁战争（夏亚的叛乱）终结后已经过了12年，现在是U.C.0105—。即便经历了被视为展现人类和宇宙世纪未来的“阿克西斯撞击”，世界仍然是混乱的状态，不时地发生着军事冲突。地球联邦政府也愈加腐..."},{"title":"EVA 新世纪福音战士","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/03cd3e02df47b9200cf566c1d4048baf26f504c8.jpg","totalCount":"全26话","id":1635,"follow":"237.2 万","view":"8315.0 万","danmaku":"208.0 万","coin":"37.7 万","score":9.7,"des":"2000年9月13日，第二次冲击爆发。在南极大陆上发生的这起大灾难，造成地轴偏斜、海平面上升、全球气候改变，世界人口减半。2015年，不明巨型生物“使徒”在日本登陆，并向第3新东京市袭来。国联军与使徒..."},{"title":"机动战士高达 铁血的奥尔芬斯 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/f84a80d731d0431c00903d8951fd66623d8237f7.png","totalCount":"全25话","id":4310042,"follow":"61.6 万","view":"2259.5 万","danmaku":"51.5 万","coin":"5.2 万","score":9.5,"des":"主人公三日月·奥古斯，从所属的民间警备公司克律塞安保公司（下称CGS）那里，接受了对少女库德莉亚·蓝那·伯恩斯坦的护卫任务。但CGS受到了摘取反叛之芽的武力组织加拉尔霍恩的袭击，于是在把三日月当做诱饵..."},{"title":"机动战士高达 雷霆宙域战线 第一季","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/10e90ed6acd3edcfb0d7f353b85f283e30c091a1.jpg","totalCount":"全4话","id":6006,"follow":"23.2 万","view":"551.2 万","danmaku":"3.3 万","coin":8423,"score":9.6,"des":"宇宙世纪 0079 年，SIDE 3「吉翁公国」正式对地球联邦政府宣战后将近一年时，在原本太空殖民卫星 SIDE 4「姆亚」的遗址「雷霆宙域」，一心想要夺回故土联邦军「姆亚同胞团」的「伊欧.弗莱明」少..."},{"title":"EVA 新世纪福音战士新剧场版2.22：破","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/a98384d26fa30011f9476b8c1112066526f0446a.jpg","totalCount":"全1话","id":10352,"follow":"50.6 万","view":"1084.4 万","danmaku":"18.8 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版2.22：YOU CAN (NOT) ADVANCE》。作为新剧场版的第二部，本片延续了前作《序》的剧情。但与第一部不同，《破》的剧情与95年TV版剧情相比有较大变化。..."},{"title":"EVA 新世纪福音战士新剧场版1.11：序","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/41a56f681e3d020e531b67e523ddd972dfa61885.jpg","totalCount":"全1话","id":10332,"follow":"61.5 万","view":"1257.1 万","danmaku":"12.2 万","coin":"5.8 万","score":9.7,"des":"《EVA 新世纪福音战士新剧场版1.11：序：YOU ARE (NOT) ALONE》。本作基于TV动画1-6话重新制作，而非续编。与TV版剧情大致相同，但也有许多改动。..."},{"title":"齐木楠雄的灾难 完结篇","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/71a506a347fc4a719340fb66e3fe920d45dbabfb.png","totalCount":"全2话","id":5195852,"follow":"71.1 万","view":"1202.1 万","danmaku":"8.3 万","coin":"7.4 万","score":9.8,"des":"完结篇讲述了原作漫画中「忍舞市旅行的小插曲」哦！在忍舞市中，等待齐木和他的小伙伴们的灾难是…！？..."},{"title":"EVA 新世纪福音战士新剧场版3.33：Q","type":"番剧","area":"日本","cover":"https://i0.hdslb.com/bfs/bangumi/73fcd288f753d420365962d6622125fdb06fd9c5.jpg","totalCount":"全1话","id":10372,"follow":"54.1 万","view":"1100.9 万","danmaku":"15.5 万","coin":"5.5 万","score":9,"des":"《EVA 新世纪福音战士新剧场版3.33：YOU CAN (NOT) REDO》。在第二部《破》的尾段，明日香不幸被第三使徒精神污染及侵食，生死未卜，但在最后的预告中却出现了戴着眼罩的明日香。而这样的..."},{"title":"猫和老鼠 旧版","type":"番剧","area":"美国","cover":"https://i0.hdslb.com/bfs/bangumi/065926cbda8f464a31293758054620cca15e5589.jpg","totalCount":"全55话","id":132112,"follow":"271.8 万","view":"2.4 亿","danmaku":"209.2 万","coin":"55.3 万","score":9.9,"des":"机灵老鼠与笨猫的故事，堪与米老鼠和唐老鸭的故事相媲美。没有动物世界中恃强凌弱的残酷，只有两个邻居之间的日常琐事和纷争，诸如杰瑞偷吃了汤姆的奶酪，汤姆把捕鼠器放到了杰里的洞门口等等，中间穿插的无数恶作剧..."}]}}},"excerpt":"","more":"<h1 id=\"初识-RxJS\"><a href=\"#初识-RxJS\" class=\"headerlink\" title=\"初识 RxJS\"></a>初识 RxJS</h1><h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>刚入职了新公司，负责维护一个原来使用<code>Angular</code>构建的项目，奈何自己一直使用的是<code>React</code>。不过既来之，则安之。顺便插一句，熟悉<code>Vue</code>的朋友应该会觉得很亲切，其中很多语法如<code>v-if</code>、<code>v-bind</code>，与<code>Angualr</code>中的<code>ngIf</code>、<code>ngFor</code>的用法都如出一辙。</p>\n<p>看了两周左右的<code>Angular</code>，说一下第一印象，<code>Angular</code>确实是一个非常齐全的框架，它不像<code>Vue</code>跟<code>React</code>需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在<code>Angular</code>中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。<br>其中<code>RxJS</code>就是<code>Anuglar</code>提供的异步编程方案。</p>\n<p><code>RxJS</code>官网描述自己是<code>Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）</code>，也可以把<code>RxJS</code>当做处理异步行为的<code>Lodash</code>库<code>（Think of RxJS as Lodash for events）</code>。<code>RxJS</code>是编程范式函数式编程(<code>Functional Programming</code>)与响应式编程(<code>Reactive Programming</code>)的结合，换句话说，<code>RxJS</code>是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了<code>J.H. Blog</code>的<code>30天精通RxJS</code>系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。</p>\n<h1 id=\"什么是Observable\"><a href=\"#什么是Observable\" class=\"headerlink\" title=\"什么是Observable\"></a>什么是Observable</h1><h2 id=\"Observer-Pattern\"><a href=\"#Observer-Pattern\" class=\"headerlink\" title=\"Observer Pattern\"></a>Observer Pattern</h2><p>观察者模式在程序设计中并不少见，如<code>DOM</code>操作中的通过给<code>DOM</code>元素绑定相应的事件去监听该<code>DOM</code>元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的<code>Redux</code>的实现，其都是以观察者模式的思想为核心。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux 的简单实现</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createStore</span> = (<span class=\"params\">reducer</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 公共状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 监听者队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> listeners = [];</span><br><span class=\"line\">  <span class=\"comment\">// getter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">getState</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// setter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dispatch</span>(<span class=\"params\">action</span>) &#123;</span><br><span class=\"line\">    currentState = <span class=\"title function_\">reducer</span>(currentState, action);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当dispatch触发，即状态更新时通知listeners</span></span><br><span class=\"line\">    listeners.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> <span class=\"title function_\">fn</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加监听事件</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">subscribe</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    listeners.<span class=\"title function_\">push</span>(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化store数据</span></span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;@@REDUX_INIT&quot;</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Iterator-Pattern\"><a href=\"#Iterator-Pattern\" class=\"headerlink\" title=\"Iterator Pattern\"></a>Iterator Pattern</h2><p><code>iterator</code>（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>等JS中内置的数据结构都实现了该接口。实现<code>iterator</code>接口的方法是为其添加<code>Symbol.iterator</code>属性，其中包含<code>next</code>方法，该方法返回的迭代器对象包含两个属性：<code>value</code>和<code>done</code>。<code>done</code>指的是遍历是否结束，<code>value</code>为下一次迭代的值，<code>done</code>为<code>true</code>时<code>value</code>一般为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iterableExample = &#123;</span><br><span class=\"line\">\t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">next</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">value</span>: <span class=\"string\">&#x27;Sunday&#x27;</span>,</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">done</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">&#x27;Monday&#x27;</span>, <span class=\"string\">&#x27;Tuesday&#x27;</span>, <span class=\"string\">&#x27;Wednesday&#x27;</span>, <span class=\"string\">&#x27;Thursday&#x27;</span>, <span class=\"string\">&#x27;Friday&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> iterator = arr[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]()</span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Monday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Tuesday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Wednesday&#x27;, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了<code>iterator</code>与<code>iterable</code>的概念。</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p><code>Observable</code>结合了<code>Observer</code>与<code>Iterator</code>的思想，像<code>Observe</code>与<code>Iterator</code>一样以流的形式包装数据，同时能够以<code>Observe</code>的方式通知更新，以<code>Iterator</code>的方式去处理数据。这样说起来可能有点抽象，但是结合<code>Observable</code>实例就能很好地理解。</p>\n<h1 id=\"创建-Observable\"><a href=\"#创建-Observable\" class=\"headerlink\" title=\"创建 Observable\"></a>创建 Observable</h1><p>创建<code>Observable</code>实例的基本方法,使用<code>Observable</code>构造函数来创建一个<code>Observable</code>实例对象，其中可以传入一个回调函数,接收一个<code>subscriber</code>，用来指定该如何处理数据。需要注意的是，<code>Observable</code>作为被观察的对象，需要使用<code>subscribe</code>方法来通知<code>subscriber</code>去对<code>Observable</code>作出处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用subscrible方法来订阅Observable</span></span><br><span class=\"line\">observalbe1.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理非同步行为</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kasumi&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observalbe2.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"><span class=\"comment\">// Kasumi</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>订阅<code>Observable</code>的被称为观察者，观察者具有三种行为（方法）来处理<code>Observable</code>的数据：</p>\n<ul>\n<li><code>next</code>：当Observable发送新的值，即调用其中的next方法时，观察者的<code>next</code>方法就会被调用。</li>\n<li><code>complete</code>：在<code>Observable</code>中完成遍历即调用其中的<code>complete</code>方法时，观察者的<code>complete</code>方法会被调用，在此之后的<code>next</code>方法不会执行。</li>\n<li><code>error</code>：在<code>Observable</code>中出现错误时，观察者的<code>error</code>方法会被调用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> observable3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Inuyasha&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">complete</span>();</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kagome&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与Promise类似的处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = &#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">observable3.<span class=\"title function_\">subscribe</span>(observer);</span><br><span class=\"line\"><span class=\"comment\">// Inuyasha</span></span><br><span class=\"line\"><span class=\"comment\">// Kikyo</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，只传入一个函数时会被默认指定为<code>next</code>的回调函数。</p>\n<h1 id=\"创建-Observable-实例的常用方法\"><a href=\"#创建-Observable-实例的常用方法\" class=\"headerlink\" title=\"创建 Observable 实例的常用方法\"></a>创建 Observable 实例的常用方法</h1><h2 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h2><blockquote>\n<p><code>of&lt;T&gt;(...args: (SchedulerLike | T)[]): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>需要注意其参数与方法<code>Function.prototype.call</code>类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。</p>\n<p><img src=\"https://rxjs.dev/assets/images/marble-diagrams/of.png\" alt=\"of.png\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">of</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"from\"><a href=\"#from\" class=\"headerlink\" title=\"from\"></a>from</h2><blockquote>\n<p><code>from&lt;T&gt;(input: ObservableInput&lt;T&gt;, scheduler?: SchedulerLike): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>该方法弥补了<code>of</code>方法不能直接传入数组等数据结构等缺陷，参数为<code>Array</code>、<code>类数组对象</code>、<code>Promise</code>、<code>可迭代对象</code>或<code>类 Observable 对象</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">from</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"interval\"><a href=\"#interval\" class=\"headerlink\" title=\"interval\"></a>interval</h2><blockquote>\n<p><code>interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>这个方法能够实现JS中<code>setInterval</code>的功能，需要注意第一个参数是以<code>ms</code>为单位的时间间隔。</p>\n<p><img src=\"https://rxjs.dev/assets/images/marble-diagrams/interval.png\" alt=\"图片来自rxjs官网\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = <span class=\"title function_\">interval</span>(<span class=\"number\">2000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 以2秒的间隔从0开始在控制台输出数字</span></span><br><span class=\"line\">numbers.<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h2><blockquote>\n<p><code>timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>该方法与<code>Interval</code>类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; timer &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只传一个参数表示指需要调用一次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = <span class=\"title function_\">timer</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">source1.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一次调用后会每隔1秒调用1次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = <span class=\"title function_\">timer</span>(<span class=\"number\">2000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">source2.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 2秒之后开始输出 0 1 2 3 4 ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EMPTY-NEVER\"><a href=\"#EMPTY-NEVER\" class=\"headerlink\" title=\"EMPTY, NEVER\"></a>EMPTY, NEVER</h2><p>这两个<code>Observable</code>常量分别用来替代在以前版本的<code>empty</code>方法与<code>never</code>方法，前者会直接<code>complete</code>，后者不会被执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"variable constant_\">EMPTY</span>, <span class=\"variable constant_\">NEVER</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">EMPTY</span>.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不会被执行</span></span><br><span class=\"line\"><span class=\"variable constant_\">NEVER</span>.<span class=\"title function_\">subscribe</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;never be called&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"throwError\"><a href=\"#throwError\" class=\"headerlink\" title=\"throwError\"></a>throwError</h2><blockquote>\n<p><code>throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable&lt;never&gt;</code></p>\n</blockquote>\n<p>该方法会直接抛出异常，与<code>Promise.reject</code>方法类似。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; throwError &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">throwError</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Ops!&#x27;</span>)).<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a><strong>Subscription</strong></h2><p>在对<code>Observable</code>进行<code>subscribe</code>之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟<code>setTimeout</code>、<code>setInterval</code>等方法一样，需要我们在使用完后手动进行释放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">interval</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> subscriptipn = source.<span class=\"title function_\">subscribe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用完后手动释放</span></span><br><span class=\"line\">subscriptipn.<span class=\"title function_\">unsubscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong><a href=\"https://blog.jerry-hong.com/series/rxjs\">30天精通RxJS</a></strong></p>\n<p><strong><a href=\"https://rxjs.dev/\">RxJS官方文档</a></strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3re6un80008vuo969qd4xri","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6unc000tvuo9c7gk5fw5"},{"post_id":"cl3re6un80008vuo969qd4xri","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6und000vvuo92apvezyp"},{"post_id":"cl3re6un40001vuo9dxx92392","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6und000xvuo90lf62wcu"},{"post_id":"cl3re6un40001vuo9dxx92392","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6und000yvuo96cyd2fdy"},{"post_id":"cl3re6un80009vuo91vds63uu","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6und0010vuo92musd0xv"},{"post_id":"cl3re6un80009vuo91vds63uu","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6und0011vuo98f1v7u3e"},{"post_id":"cl3re6una000dvuo9cnsjfgut","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6und0013vuo9akkwcmup"},{"post_id":"cl3re6una000dvuo9cnsjfgut","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6und0014vuo92v1h21oy"},{"post_id":"cl3re6una000fvuo94eyvdjba","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6und0017vuo94b3teffo"},{"post_id":"cl3re6una000fvuo94eyvdjba","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6und0018vuo9grj0fodp"},{"post_id":"cl3re6unb000jvuo9dil81blt","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6und001avuo9d7p2c9bt"},{"post_id":"cl3re6unb000jvuo9dil81blt","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6und001bvuo94qyk6q5a"},{"post_id":"cl3re6un70006vuo9dbo8c100","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6une001cvuo9etnge5r1"},{"post_id":"cl3re6un70006vuo9dbo8c100","category_id":"cl3re6unb000lvuo96dds2lf9","_id":"cl3re6une001dvuo94x4hg589"},{"post_id":"cl3re6un60003vuo92ed1cs5u","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6une001evuo9f2g0fjc8"},{"post_id":"cl3re6un60003vuo92ed1cs5u","category_id":"cl3re6und000zvuo96qtr4miq","_id":"cl3re6une001fvuo9bfechxy9"},{"post_id":"cl3re6un60003vuo92ed1cs5u","category_id":"cl3re6und0019vuo9g4qfc0cq","_id":"cl3re6une001gvuo97ggih8rm"},{"post_id":"cl3re6une001hvuo9f6ry4ai8","category_id":"cl3re6un80007vuo98hkw2v50","_id":"cl3re6ung001lvuo9fgab0m31"},{"post_id":"cl3re6une001hvuo9f6ry4ai8","category_id":"cl3re6ung001jvuo90c8l80vd","_id":"cl3re6ung001mvuo9dyy5envr"}],"PostTag":[{"post_id":"cl3re6un80008vuo969qd4xri","tag_id":"cl3re6un70004vuo9hpsd32y3","_id":"cl3re6una000cvuo98nee5rhn"},{"post_id":"cl3re6un40001vuo9dxx92392","tag_id":"cl3re6un70004vuo9hpsd32y3","_id":"cl3re6una000evuo90nktf26m"},{"post_id":"cl3re6un80009vuo91vds63uu","tag_id":"cl3re6un70004vuo9hpsd32y3","_id":"cl3re6unb000ivuo98knb9e6a"},{"post_id":"cl3re6una000dvuo9cnsjfgut","tag_id":"cl3re6un70004vuo9hpsd32y3","_id":"cl3re6unb000kvuo9ggzu04n9"},{"post_id":"cl3re6un60003vuo92ed1cs5u","tag_id":"cl3re6un9000avuo9b4kxgt1f","_id":"cl3re6unc000nvuo950r3hyu0"},{"post_id":"cl3re6un70006vuo9dbo8c100","tag_id":"cl3re6un70004vuo9hpsd32y3","_id":"cl3re6unc000ovuo9cx6y200w"},{"post_id":"cl3re6una000fvuo94eyvdjba","tag_id":"cl3re6unb000mvuo926vya2tj","_id":"cl3re6unc000rvuo99qdl8kp6"},{"post_id":"cl3re6unb000jvuo9dil81blt","tag_id":"cl3re6unc000qvuo9fy11er2r","_id":"cl3re6unc000uvuo92ak01op2"},{"post_id":"cl3re6une001hvuo9f6ry4ai8","tag_id":"cl3re6unf001ivuo9hczha1uh","_id":"cl3re6ung001kvuo93bm81gpl"}],"Tag":[{"name":"数据类型","_id":"cl3re6un70004vuo9hpsd32y3"},{"name":"React","_id":"cl3re6un9000avuo9b4kxgt1f"},{"name":"类型转换","_id":"cl3re6unb000mvuo926vya2tj"},{"name":"变量","_id":"cl3re6unc000qvuo9fy11er2r"},{"name":"RxJS","_id":"cl3re6unf001ivuo9hczha1uh"}]}}