{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/rxjs-first-sight.jpeg","path":"img/rxjs-first-sight.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"57d4f05d4d1590b078984eed11f71e353dddc1b0","modified":1651730773008},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1651720759162},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1651720759162},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1651720759162},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1651720759162},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1651720759162},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1651720759162},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1651720759162},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1651720759163},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1651720759164},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1651720759163},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1651720759164},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1651720759163},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1651720759163},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1651720759164},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1651720759164},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1651720759164},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1651720759164},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1651720759164},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1651720759163},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1651720759164},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1651720759165},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1651720759163},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1651720759165},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1651720759165},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1651720759165},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1651720759165},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1651720759165},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1651720759166},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1651720759166},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1651720759167},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1651720759166},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1651720759167},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1651720759166},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1651720759167},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1651720759166},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1651720759167},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1651720759167},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1651720759167},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1651720759166},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1651720759167},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1651720759168},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1651720759168},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1651720759169},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1651720759169},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1651720759170},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1651720759169},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1651720759170},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1651720759170},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1651720759170},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1651720759171},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1651720759171},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1651720759171},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1651720759171},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1651720759168},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1651720759170},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1651720759168},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1651720759168},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1651720759168},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1651720759168},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1651720759168},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1651720759170},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1651720759173},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1651720759172},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1651720759172},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1651720759172},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1651720759173},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1651720759173},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1651720759173},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1651720759172},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1651720759173},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1651720759173},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1651720759173},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1651720759170},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1651720759174},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1651720759172},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1651720759175},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1651720759174},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1651720759169},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1651720759174},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1651720759175},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1651720759175},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1651720759175},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1651720759174},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1651720759175},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1651720759172},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1651722516907},{"_id":"themes/butterfly/README.md","hash":"6ee27baf95a5741abbc224ef8938d679b6597665","modified":1651722516907},{"_id":"themes/butterfly/README_CN.md","hash":"49ace5208f98783344f17a00adab7641cda43280","modified":1651722516907},{"_id":"themes/butterfly/package.json","hash":"42f0fab667d1424ead097b7dcc68cb9c8af281f4","modified":1651722516918},{"_id":"themes/butterfly/_config.yml","hash":"318a36799206b93f2c7ce17de403ee0b212405ac","modified":1651836881264},{"_id":"themes/butterfly/.github/stale.yml","hash":"5e8ea535424e8112439135d21afc5262c0bc0b39","modified":1651722516907},{"_id":"themes/butterfly/languages/default.yml","hash":"1e37a3695d50e3e61d7c36e58a6dac872a4a56cd","modified":1651722516908},{"_id":"themes/butterfly/languages/en.yml","hash":"d1bb560698eb8b0079495b7b18b44facb610f9fd","modified":1651722516908},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"28b6f0c39155651d747eb595e0a283bc97be2e09","modified":1651722516908},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"947f794e862bb2813e36887f777bdb760f70a322","modified":1651722516908},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1651722516908},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1651722516908},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1651722516917},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1651722516918},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1651722516917},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1651722516918},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"67e4f5a66d4b8cabadbaad0410628364ee75e0ae","modified":1651722516907},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1651722516907},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1651722516907},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1651722516907},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"594a977ebe8d97e60fa3d7cb40fc260ded4d8a58","modified":1651722516908},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"da27c20f0e672103b984e135eb2fe7770ca7fcce","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1651722516908},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"54511ed299a3bcf4ecbb62e3078f6b0611ccbd2c","modified":1651722516909},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1651722516918},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1651722516911},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1651722516918},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1651722516911},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/config.js","hash":"af5795ddf62855d13dece2b3947d6bb4481e0356","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/init.js","hash":"a7f567b3d3110afe2f99c967b8e15351a7f5bd6d","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1651722516918},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1651722516918},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1651722516919},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1651722516918},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b4cd617c619d1a0df93603721a6fa1317526174b","modified":1651722516919},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1651722516919},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"d368a8830e506c8b5eb6512b709ec8db354d5ea1","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1651722516919},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1651722516920},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1651722516919},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1651722516924},{"_id":"themes/butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1651722516924},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1651722516924},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1651722516924},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1651722516924},{"_id":"themes/butterfly/source/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1651722516925},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1651722516925},{"_id":"themes/butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1651722516909},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1651722516919},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"8f41fa9732ea654a10f6e666d9c782c7e27e5ea6","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1651722516909},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"ef2abe26e11ae9a786771144383e9fcb66719209","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"b9ebb02af8ccf43e3f73be43db19254fa913c57b","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1651722516910},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"de2e978ff0cacd02eb635cf7676a39e9a21781dd","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"bae2f32ac96cebef600c1e37eaa8467c9a7e5d92","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1651722516917},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1651722516917},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1651722516920},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1651722516920},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"644d520fe80cc82058467708ab82ccad313b0c27","modified":1651722516920},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"ca58af8903eb1d1d05edae54fc2e23aeac6da6c5","modified":1651722516921},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"15056fba0bd5a45ea8dc97eb557f6929ff16797a","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1651722516921},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"8314e9749eb1ae40c4bae9735b7a6638b2d6876a","modified":1651722516922},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1651722516922},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"f67177310f5594954b25a591d186d28d5d450b18","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1651722516922},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1651722516922},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"826dae759062d8f84eb2bf5ab8fdb80e0f79d58b","modified":1651722516922},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1651722516923},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"51e45625929d57c9df3ba9090af99b9b7bb9a15b","modified":1651722516923},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"f9cd4dbbe5e3c7760b1a37d4d2b8d09be37b8880","modified":1651722516923},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1651722516922},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"08493b66b9f31f2bd3e9a3115017a0ce16142b20","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1651722516923},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1651722516924},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1651722516924},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1651722516911},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"5f648086a33a32d169a2f8d8c549c08aa02f67db","modified":1651722516912},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1651722516925},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"309b9aee523f90aff13d48142d124de9039d8511","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7d98129f2ee08169f877b76d4d0b95c17df354f8","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"693d999777dd16e0566d29ac3203d4c167b2f9a7","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1651722516912},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"2d8fc3fb8f9aec61400acf3c94070bd8539058f8","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"22e2ef30fe5eb1db7566e89943c74ece029b2a8e","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"9302837f1e35f153323bb4f166514c7e96e8ecdd","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"c488a3414dbae899488b6d46f6cb91575bc23b9e","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"e4850f2c9ba5f6b2248808f7257662679e0fab0a","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"15462d1ed04651ad3b430c682842ac400f6f9b47","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"8cb8fcc210edab1ae1adf4aee8cc6948f7e9f28e","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"5737164f5a77fb813b5bacba0a273d2a490a2ced","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"7c712719bb8960c335f94b519923e5a86ee7bd32","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"26ac3fb930fe9f3ace0c5d0191b87425bf053e74","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1651722516913},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"dd0bc119029b62dce5dc965d5de7377e438fa29a","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1651722516915},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1651722516914},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1651722516916},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1651722516916},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1651722516920},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1651722516916},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1651722516920},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1651722516916},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1651722516920},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1651722516920},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1651722516920},{"_id":"source/tags/index.md","hash":"550ff3ca93ce55b391b14ab8e828ee3b7ce22709","modified":1651730930115},{"_id":"source/categories/index.md","hash":"66041de7a9d18a61cd479e2f7bcd246d8118102e","modified":1651730915648},{"_id":"source/_posts/js-again-primitive-type-number.md","hash":"7893208fd4f5f5c7082d0085ae8b48ea7b31265f","modified":1651803723659},{"_id":"source/_posts/js-again-varible.md","hash":"c463e53c10691c9971c735b18c6786236c950fea","modified":1651750732880},{"_id":"source/_posts/js-again-primitive-type-string.md","hash":"441811c758d0df9d674ff7ce2a98c538b18b921a","modified":1651803724764},{"_id":"source/_posts/js-again-primitive-type-boolean-undefined-null.md","hash":"8bc8dfe38ecfc68bbcf6ebb4481bef4016372cde","modified":1651803722179},{"_id":"source/_posts/js-again-primitive-type-bigint-symbol.md","hash":"630c84428ceea64816e47a5292c49fa616d86126","modified":1651803720378},{"_id":"public/404.html","hash":"d23a9adfc36493ed7bdac63ddc51c81497f56140","modified":1651836938441},{"_id":"public/tags/index.html","hash":"7a7866f2f80b98a2768fd39c3f218160ed122a7a","modified":1651836938441},{"_id":"public/2022/05/06/js-again-primitive-type-bigint-symbol/index.html","hash":"8a7990b3bcc64fe9336ee447a4b448d45c576c6c","modified":1651836938441},{"_id":"public/2022/05/05/js-again-primitive-type-string/index.html","hash":"eee659adcf342bde9f024a3f96b31a4693b7ea64","modified":1651836938441},{"_id":"public/2022/05/05/js-again-primitive-type-number/index.html","hash":"b59c87817f40a3ee2698ac24cca374b558338576","modified":1651836938441},{"_id":"public/categories/index.html","hash":"517b3c6b7bcce64664ddc929cfd6679b94329477","modified":1651836938441},{"_id":"public/2022/05/05/js-again-varible/index.html","hash":"8b884e2611dea79d8008ce27180265bba14b6925","modified":1651836938441},{"_id":"public/2022/05/05/js-again-primitive-type-boolean-undefined-null/index.html","hash":"9eff66b6162e2c1753d458b204f30c30fccc583e","modified":1651836938441},{"_id":"public/archives/index.html","hash":"604743230abce909236a0cbe484fea3dcf6539fe","modified":1651836938441},{"_id":"public/archives/2022/index.html","hash":"16b7ed55bb086541a3ac8d70eef5329c29fb3a2b","modified":1651836938441},{"_id":"public/archives/2022/05/index.html","hash":"a2b60c08f82e6cf351b409fdb0eff1ef2548d9cd","modified":1651836938441},{"_id":"public/categories/前端/index.html","hash":"f235ec76b2eafcf1ffd9e17b59be1e2aab163839","modified":1651836938441},{"_id":"public/index.html","hash":"7c2e3d1894c26f8554d5643258aa56a6924e2e18","modified":1651836938441},{"_id":"public/tags/JavaScript/index.html","hash":"ab57841c87083f09496d77d2ab3546170835e19a","modified":1651836938441},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1651817053636},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1651817053636},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1651817053636},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1651817053636},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1651817053636},{"_id":"public/js/search/algolia.js","hash":"ce8131b712dca80f289015aef75f86e727f62981","modified":1651817053636},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1651817053636},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1651817053636},{"_id":"public/css/index.css","hash":"91f74e17a4e97fb0e93cf40d64cd728c373c8517","modified":1651817053636},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1651817053636},{"_id":"source/about/index.md","hash":"0fa1360391eea95cb9684d1bb3bb2d423cfd1973","modified":1651819520790},{"_id":"source/_posts/rxjs-first-sight.md","hash":"d2d4a3012a3c98487a8b9ed1369db032f9f3ab37","modified":1651821848488},{"_id":"source/img/rxjs-first-sight.jpeg","hash":"8e2822394b6df213a20d9b033c3f473cb645d9d5","modified":1647153853201},{"_id":"source/img/.DS_Store","hash":"f962d19eba041437d566b8b45f4eb810d79df317","modified":1651821824647},{"_id":"public/about/index.html","hash":"c6c307caaab7eaaad400c4db5a1fade756af7f62","modified":1651836938441},{"_id":"public/tags/RxJS/index.html","hash":"b05fdca1e3c66f5f726459db6923891eabbc4a19","modified":1651836938441},{"_id":"public/2022/05/06/rxjs-first-sight/index.html","hash":"b73cf2b2ed6d3501d326394e03e4ba70622e441e","modified":1651836938441},{"_id":"public/img/rxjs-first-sight.jpeg","hash":"8e2822394b6df213a20d9b033c3f473cb645d9d5","modified":1651821979902}],"Category":[{"name":"JavaScript","_id":"cl2sltvde0002l2o99tya7sa4"},{"name":"前端","_id":"cl2sx0rny00047yo9f1ou0375"}],"Data":[],"Page":[{"title":"文章标签","date":"2022-05-05T06:06:46.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 文章标签\ndate: 2022-05-05 14:06:46\ntype: \"tags\"\n---\n","updated":"2022-05-05T06:08:50.115Z","path":"tags/index.html","_id":"cl2slwfr70000u6o99fpabiot","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""},{"title":"文章分类","date":"2022-05-05T06:07:55.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2022-05-05 14:07:55\ntype: \"categories\"\n---\n","updated":"2022-05-05T06:08:35.648Z","path":"categories/index.html","_id":"cl2slx0jt0001u6o9a5ll4a37","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""},{"title":"关于我","date":"2022-05-06T06:44:45.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-05-06 14:44:45\n---\n","updated":"2022-05-06T06:45:20.790Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl2u2p2hd0000nvo9hh2c40hc","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","excerpt":"","more":""}],"Post":[{"title":"再学 JS 之数据类型 —— number","date":"2022-05-05T08:35:21.000Z","updated":"2022-05-06T02:22:03.659Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"## 原始类型(primitive values)\n\n原始类型一共有七种：`number`、`string`、`boolean`、`undefined`、`null`、`bigInt`、`symbol`。\n\n原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。\n\n> 在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（`String`、`Number`、`Boolean`、`Symbol`），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。\n\n```js\n// 不能为原始类型的实例直接添加属性\nlet str = 'Hi'\nstr.test = 4\nconsole.log(str.test) // undefined\n\n// 可以显式地为原始类型进行“包装”\nlet num = new Number(2)\nnum.test = 33\nconsole.log(num.test) // 33\n\n// 在调用原始类型的方法时，由于原始类型上并没有方法\n// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法\n// 调用完此方法后会将该临时对象销毁，留下原始值\nconst lower = 'lowercase'\nconst upper = lower.toUpperCase()\nconsole.log(lower) // lowercase\nconsole.log(upper) // LOWERCASE\n```\n\n# number\n\n在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。\n\n```js\ntypeof 1 === 'number'\n\n// NaN(Not-a-Number) 表示非数值\ntypeof NaN === 'number'\n\nNumber.MAX_SAFE_INTEGER // 9007199254740991\n\nNumber.MIN_SAFE_INTEGER // -9007199254740991\n\n// Infinity 表示无穷\ntypeof Infinity === 'number'\n\n// +Infinity 表示正无穷 -Infinity 表示负无穷\n+Infinity > 0 // true\n```\n\n需要注意的是，在 JavaScript 中，可以直接使用`number`类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（[具体原理涉及汇编，有基础的话可参考这篇文章](https://zhuanlan.zhihu.com/p/352723802)），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。\n\n> 实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用`toFixed`方法对数字显式地进行格式化\n\n```js\nconst floatNum1 = 1.9\n\nconst floatNum2 = .2 // 小数点前可以不需要整数，但这种做法并不推荐\n\nconst floatNum3 = 3.000 // 会被当作整数3处理\n```\n\n## 精度丢失问题（0.1+0.2 !== 0.3）\n\n造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6)转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。\n\n> 虽然存在一位用于表示符号，但是`+0`与`-0`在 JavaScript 中被认为是相等的，但可以使用`Object.is()`方法可以判断`+0`与`-0`不相等，此为特殊情况。\n>\n> ```js\n> +0 === -0 // true\n> Object.is(+0, -0) // false\n> ```\n\n```js\n0.1+0.2 // 0.30000000000000004\n\n// 该数字转换为二进制后存在53位，超出范围\n9999999999999999 // 10000000000000000\n```\n\n并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。\n\n## 使用科学计数法表示\n\n```js\n// 使用科学计数法\n1e2 === 100 // true\n1e-3 === 0.001 // true\n```\n\n## 二进制，八进制与十六进制\n\njavaScript 中默认支持这三种进制的写法，其他进制可以通过方法`parseInt`转换\n\n```js\n// 不正确的进制表示会报语法错误\n// 二进制数字每位只能是1或0\n0b103 // Uncaught SyntaxError: Invalid or unexpected token\n\n// 不同进制的数字在进行数学操作时都会被视作为十进制数字\n0b101+017 === 20 // true\n0xff + 0o377 === 510 // true\n\n// 二进制 使用0b前缀\n0b101 === 5 // true\n\n// 八进制 使用0o前缀\n0o17 === 15 // true\n\n// 非严格模式下可以使用前缀0来表示八进制（不推荐）\n017 === 15 // true\n// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字\n019 === 19 // true\n\n// 十六进制 使用0x前缀\n0xff === 255 // true\n// 大小写不会造成影响\n0xfF === 0xff // true\n```\n\n## 常用方法\n\n> 不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。\n\n```js\n6.toString() // Uncaught SyntaxError: Invalid or unexpected token\n\n(0xfe).toString() === '254' // true\n(20).toString() === '20' // true\n20..toString() === '20' // true\n\n```\n\n### **num.toString(base)**\n\n将数字转换为字符串，参数`base`表示需要转换的进制，默认值为 10。\n\n```js\n// 十进制转换为二进制\n2.toString(2) === '10' // true\n\n// 八进制转换为十六进制\n(0o377).toString(16) === 'ff' // true\n```\n\n### **num.toFixed(digits)**\n\n格式化数字，返回字符串。参数`digits`表示需要保留几位小数。该方法会对数字进行四舍五入。\n\n```js\n// 保留小数点后3位\n1.23.toFixed(3) === '1.230' // true\n\n// 保留小数点后2位\n1.256.toFixed(2) === '1.26' // true\n```\n\n注意 toFixed 方法同样存在精度丢失的问题。\n\n```js\n// 如果小数部分是一个无限的二进制,存储会造成精度损失\n\n1.35.toFixed(20) // 1.35000000000000008882\n1.55.toFixed(1) === '1.6' // true\n\n6.35.toFixed(20) // 6.34999999999999964473\n6.35.toFixed(1) === '6.3' // true\n\n// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字\n// 等操作完后再进行还原\n(6.35 * 10).toFixed(20) // 63.50000000000000000000\n```\n\n### **isNaN(value)**\n\n判断一个值是否为 NaN\n\n> 注意`NaN === NaN`的比较结果为`false`，这是因为`NaN`是独一无二的，它不等于任何东西，这也是`isNaN`方法存在的意义。不过，使用`Object.is()`方法同样可以判断是否为`NaN`。\n\n```js\nisNaN(12) === false // true\n\n// 此处发生了类型的隐式转换\n// 如果参数不是数字，会尝试将参数转换为数值\nisNaN('11') === false // true\n\nisNaN('ab') === true // true\n\n// 使用Object.is()方法判断\nObject.is(NaN, NaN) // true\n```\n\n### **isFinite(value)**\n\n判断传入的数字是否为有限数字，参数是  `NaN`、正无穷大或者负无穷大，会返回`false`，其他返回  `true`。\n\n### **parseInt(string, radix)**\n\n### **parseFloat(string, radix)**\n\n将字符串强制转换为十进制数字。参数`string`表示需要解析的字符串，`radix`表示解析时采用什么进制，有效范围为`2到36`。\n\n不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回`NaN`。\n\n第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回`NaN`。\n\n```js\n// 如果第一个字符不能转换为数字，则直接返回NaN\n// 遇到其他进制的数字会正常解析，如二进制以0b开头等\nparseInt('a12') // NaN\nparseInt('0b101') === 5 // true\n\n// 直到读取到非数字为止，会转换之前读取到的数字\nparseInt('2a1') === 2 // true\n\n// 第二个参数传入非有效进制\nparseFloat('1.2', 1) // NaN\n\n// 第二个参数传入0时按照十进制解析\nparseFloat('1.2', 0) === 1.2 // true\n\n// 3 并非有效的二进制表示\nparseInt('3', 2) // NaN\n```\n\n### **Number(value)**\n\n`number`类型的对象包装器，可以通过`Number()`构造函数来创建`number`类型，这个函数的参数`value`可以为其他类型如`stirng`、`boolean`等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：\n\n- `boolean`，`true`返回`1`，`false`返回`0`。\n- `number`，直接返回值。\n- `null`，返回`0`。\n- `undefined`，返回`NaN`。\n- `string`，规则如下:\n  - 字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字\n  - 空字符串返回`0`\n  - 如果字符串中包含其他字符，则直接返回`NaN`，注意就算是像`'12a'`这样的值也会返回`NaN`，这点与`parseInt`方法中解析规则直到读取到非数字为止不同。\n\n这里已经涉及到**隐式类型转换**，具体的会在之后详细地解释。\n\n## 常见面试题\n\n1. `0.1 + 0.2 !== 0.3`的原因（考察 JavaScript 中数字的存储）\n2. `['1','2','3'].map(parseInt)`的输出结果（考察`map`、`parseInt`方法以及函数式编程中管道的概念）\n\n## 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**\n\n","source":"_posts/js-again-primitive-type-number.md","raw":"---\ntitle: 再学 JS 之数据类型 —— number\ndate: 2022-05-05 16:35:21\nupdated:\ntags: JavaScript\ncategories: 前端\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n## 原始类型(primitive values)\n\n原始类型一共有七种：`number`、`string`、`boolean`、`undefined`、`null`、`bigInt`、`symbol`。\n\n原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。\n\n> 在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（`String`、`Number`、`Boolean`、`Symbol`），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。\n\n```js\n// 不能为原始类型的实例直接添加属性\nlet str = 'Hi'\nstr.test = 4\nconsole.log(str.test) // undefined\n\n// 可以显式地为原始类型进行“包装”\nlet num = new Number(2)\nnum.test = 33\nconsole.log(num.test) // 33\n\n// 在调用原始类型的方法时，由于原始类型上并没有方法\n// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法\n// 调用完此方法后会将该临时对象销毁，留下原始值\nconst lower = 'lowercase'\nconst upper = lower.toUpperCase()\nconsole.log(lower) // lowercase\nconsole.log(upper) // LOWERCASE\n```\n\n# number\n\n在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。\n\n```js\ntypeof 1 === 'number'\n\n// NaN(Not-a-Number) 表示非数值\ntypeof NaN === 'number'\n\nNumber.MAX_SAFE_INTEGER // 9007199254740991\n\nNumber.MIN_SAFE_INTEGER // -9007199254740991\n\n// Infinity 表示无穷\ntypeof Infinity === 'number'\n\n// +Infinity 表示正无穷 -Infinity 表示负无穷\n+Infinity > 0 // true\n```\n\n需要注意的是，在 JavaScript 中，可以直接使用`number`类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（[具体原理涉及汇编，有基础的话可参考这篇文章](https://zhuanlan.zhihu.com/p/352723802)），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。\n\n> 实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用`toFixed`方法对数字显式地进行格式化\n\n```js\nconst floatNum1 = 1.9\n\nconst floatNum2 = .2 // 小数点前可以不需要整数，但这种做法并不推荐\n\nconst floatNum3 = 3.000 // 会被当作整数3处理\n```\n\n## 精度丢失问题（0.1+0.2 !== 0.3）\n\n造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6)转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。\n\n> 虽然存在一位用于表示符号，但是`+0`与`-0`在 JavaScript 中被认为是相等的，但可以使用`Object.is()`方法可以判断`+0`与`-0`不相等，此为特殊情况。\n>\n> ```js\n> +0 === -0 // true\n> Object.is(+0, -0) // false\n> ```\n\n```js\n0.1+0.2 // 0.30000000000000004\n\n// 该数字转换为二进制后存在53位，超出范围\n9999999999999999 // 10000000000000000\n```\n\n并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。\n\n## 使用科学计数法表示\n\n```js\n// 使用科学计数法\n1e2 === 100 // true\n1e-3 === 0.001 // true\n```\n\n## 二进制，八进制与十六进制\n\njavaScript 中默认支持这三种进制的写法，其他进制可以通过方法`parseInt`转换\n\n```js\n// 不正确的进制表示会报语法错误\n// 二进制数字每位只能是1或0\n0b103 // Uncaught SyntaxError: Invalid or unexpected token\n\n// 不同进制的数字在进行数学操作时都会被视作为十进制数字\n0b101+017 === 20 // true\n0xff + 0o377 === 510 // true\n\n// 二进制 使用0b前缀\n0b101 === 5 // true\n\n// 八进制 使用0o前缀\n0o17 === 15 // true\n\n// 非严格模式下可以使用前缀0来表示八进制（不推荐）\n017 === 15 // true\n// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字\n019 === 19 // true\n\n// 十六进制 使用0x前缀\n0xff === 255 // true\n// 大小写不会造成影响\n0xfF === 0xff // true\n```\n\n## 常用方法\n\n> 不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。\n\n```js\n6.toString() // Uncaught SyntaxError: Invalid or unexpected token\n\n(0xfe).toString() === '254' // true\n(20).toString() === '20' // true\n20..toString() === '20' // true\n\n```\n\n### **num.toString(base)**\n\n将数字转换为字符串，参数`base`表示需要转换的进制，默认值为 10。\n\n```js\n// 十进制转换为二进制\n2.toString(2) === '10' // true\n\n// 八进制转换为十六进制\n(0o377).toString(16) === 'ff' // true\n```\n\n### **num.toFixed(digits)**\n\n格式化数字，返回字符串。参数`digits`表示需要保留几位小数。该方法会对数字进行四舍五入。\n\n```js\n// 保留小数点后3位\n1.23.toFixed(3) === '1.230' // true\n\n// 保留小数点后2位\n1.256.toFixed(2) === '1.26' // true\n```\n\n注意 toFixed 方法同样存在精度丢失的问题。\n\n```js\n// 如果小数部分是一个无限的二进制,存储会造成精度损失\n\n1.35.toFixed(20) // 1.35000000000000008882\n1.55.toFixed(1) === '1.6' // true\n\n6.35.toFixed(20) // 6.34999999999999964473\n6.35.toFixed(1) === '6.3' // true\n\n// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字\n// 等操作完后再进行还原\n(6.35 * 10).toFixed(20) // 63.50000000000000000000\n```\n\n### **isNaN(value)**\n\n判断一个值是否为 NaN\n\n> 注意`NaN === NaN`的比较结果为`false`，这是因为`NaN`是独一无二的，它不等于任何东西，这也是`isNaN`方法存在的意义。不过，使用`Object.is()`方法同样可以判断是否为`NaN`。\n\n```js\nisNaN(12) === false // true\n\n// 此处发生了类型的隐式转换\n// 如果参数不是数字，会尝试将参数转换为数值\nisNaN('11') === false // true\n\nisNaN('ab') === true // true\n\n// 使用Object.is()方法判断\nObject.is(NaN, NaN) // true\n```\n\n### **isFinite(value)**\n\n判断传入的数字是否为有限数字，参数是  `NaN`、正无穷大或者负无穷大，会返回`false`，其他返回  `true`。\n\n### **parseInt(string, radix)**\n\n### **parseFloat(string, radix)**\n\n将字符串强制转换为十进制数字。参数`string`表示需要解析的字符串，`radix`表示解析时采用什么进制，有效范围为`2到36`。\n\n不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回`NaN`。\n\n第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回`NaN`。\n\n```js\n// 如果第一个字符不能转换为数字，则直接返回NaN\n// 遇到其他进制的数字会正常解析，如二进制以0b开头等\nparseInt('a12') // NaN\nparseInt('0b101') === 5 // true\n\n// 直到读取到非数字为止，会转换之前读取到的数字\nparseInt('2a1') === 2 // true\n\n// 第二个参数传入非有效进制\nparseFloat('1.2', 1) // NaN\n\n// 第二个参数传入0时按照十进制解析\nparseFloat('1.2', 0) === 1.2 // true\n\n// 3 并非有效的二进制表示\nparseInt('3', 2) // NaN\n```\n\n### **Number(value)**\n\n`number`类型的对象包装器，可以通过`Number()`构造函数来创建`number`类型，这个函数的参数`value`可以为其他类型如`stirng`、`boolean`等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：\n\n- `boolean`，`true`返回`1`，`false`返回`0`。\n- `number`，直接返回值。\n- `null`，返回`0`。\n- `undefined`，返回`NaN`。\n- `string`，规则如下:\n  - 字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字\n  - 空字符串返回`0`\n  - 如果字符串中包含其他字符，则直接返回`NaN`，注意就算是像`'12a'`这样的值也会返回`NaN`，这点与`parseInt`方法中解析规则直到读取到非数字为止不同。\n\n这里已经涉及到**隐式类型转换**，具体的会在之后详细地解释。\n\n## 常见面试题\n\n1. `0.1 + 0.2 !== 0.3`的原因（考察 JavaScript 中数字的存储）\n2. `['1','2','3'].map(parseInt)`的输出结果（考察`map`、`parseInt`方法以及函数式编程中管道的概念）\n\n## 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**\n\n","slug":"js-again-primitive-type-number","published":1,"_id":"cl2swzk0q00007yo93udh23ar","layout":"post","photos":[],"link":"","content":"<h2 id=\"原始类型-primitive-values\"><a href=\"#原始类型-primitive-values\" class=\"headerlink\" title=\"原始类型(primitive values)\"></a>原始类型(primitive values)</h2><p>原始类型一共有七种：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>bigInt</code>、<code>symbol</code>。</p>\n<p>原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。</p>\n<blockquote>\n<p>在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code>），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不能为原始类型的实例直接添加属性</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Hi&#x27;</span></span><br><span class=\"line\">str.<span class=\"property\">test</span> = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"property\">test</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以显式地为原始类型进行“包装”</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">num.<span class=\"property\">test</span> = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num.<span class=\"property\">test</span>) <span class=\"comment\">// 33</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在调用原始类型的方法时，由于原始类型上并没有方法</span></span><br><span class=\"line\"><span class=\"comment\">// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法</span></span><br><span class=\"line\"><span class=\"comment\">// 调用完此方法后会将该临时对象销毁，留下原始值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> lower = <span class=\"string\">&#x27;lowercase&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> upper = lower.<span class=\"title function_\">toUpperCase</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(lower) <span class=\"comment\">// lowercase</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(upper) <span class=\"comment\">// LOWERCASE</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">1</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NaN(Not-a-Number) 表示非数值</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">NaN</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span> <span class=\"comment\">// 9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MIN_SAFE_INTEGER</span> <span class=\"comment\">// -9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Infinity 表示无穷</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Infinity</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +Infinity 表示正无穷 -Infinity 表示负无穷</span></span><br><span class=\"line\">+<span class=\"title class_\">Infinity</span> &gt; <span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在 JavaScript 中，可以直接使用<code>number</code>类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（<a href=\"https://zhuanlan.zhihu.com/p/352723802\">具体原理涉及汇编，有基础的话可参考这篇文章</a>），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。</p>\n<blockquote>\n<p>实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用<code>toFixed</code>方法对数字显式地进行格式化</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floatNum1 = <span class=\"number\">1.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum2 = <span class=\"number\">.2</span> <span class=\"comment\">// 小数点前可以不需要整数，但这种做法并不推荐</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum3 = <span class=\"number\">3.000</span> <span class=\"comment\">// 会被当作整数3处理</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"精度丢失问题（0-1-0-2-0-3）\"><a href=\"#精度丢失问题（0-1-0-2-0-3）\" class=\"headerlink\" title=\"精度丢失问题（0.1+0.2 !== 0.3）\"></a>精度丢失问题（0.1+0.2 !== 0.3）</h2><p>造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6\">二进制</a>转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式<a href=\"https://zh.wikipedia.org/wiki/IEEE_754\">IEEE 754</a> 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。</p>\n<blockquote>\n<p>虽然存在一位用于表示符号，但是<code>+0</code>与<code>-0</code>在 JavaScript 中被认为是相等的，但可以使用<code>Object.is()</code>方法可以判断<code>+0</code>与<code>-0</code>不相等，此为特殊情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">+<span class=\"number\">0</span> === -<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span>+<span class=\"number\">0.2</span> <span class=\"comment\">// 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该数字转换为二进制后存在53位，超出范围</span></span><br><span class=\"line\"><span class=\"number\">9999999999999999</span> <span class=\"comment\">// 10000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<p>并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。</p>\n<h2 id=\"使用科学计数法表示\"><a href=\"#使用科学计数法表示\" class=\"headerlink\" title=\"使用科学计数法表示\"></a>使用科学计数法表示</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用科学计数法</span></span><br><span class=\"line\"><span class=\"number\">1e2</span> === <span class=\"number\">100</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">1e-3</span> === <span class=\"number\">0.001</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二进制，八进制与十六进制\"><a href=\"#二进制，八进制与十六进制\" class=\"headerlink\" title=\"二进制，八进制与十六进制\"></a>二进制，八进制与十六进制</h2><p>javaScript 中默认支持这三种进制的写法，其他进制可以通过方法<code>parseInt</code>转换</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不正确的进制表示会报语法错误</span></span><br><span class=\"line\"><span class=\"comment\">// 二进制数字每位只能是1或0</span></span><br><span class=\"line\">0b103 <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同进制的数字在进行数学操作时都会被视作为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">0b101</span>+<span class=\"number\">017</span> === <span class=\"number\">20</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> + <span class=\"number\">0o377</span> === <span class=\"number\">510</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制 使用0b前缀</span></span><br><span class=\"line\"><span class=\"number\">0b101</span> === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制 使用0o前缀</span></span><br><span class=\"line\"><span class=\"number\">0o17</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非严格模式下可以使用前缀0来表示八进制（不推荐）</span></span><br><span class=\"line\"><span class=\"number\">017</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">019</span> === <span class=\"number\">19</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制 使用0x前缀</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> === <span class=\"number\">255</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 大小写不会造成影响</span></span><br><span class=\"line\"><span class=\"number\">0xfF</span> === <span class=\"number\">0xff</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><blockquote>\n<p>不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6.</span><span class=\"title function_\">toString</span>() <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">0xfe</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;254&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"number\">20</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">20.</span>.<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toString-base\"><a href=\"#num-toString-base\" class=\"headerlink\" title=\"num.toString(base)\"></a><strong>num.toString(base)</strong></h3><p>将数字转换为字符串，参数<code>base</code>表示需要转换的进制，默认值为 10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转换为二进制</span></span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"title function_\">toString</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;10&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制转换为十六进制</span></span><br><span class=\"line\">(<span class=\"number\">0o377</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>) === <span class=\"string\">&#x27;ff&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toFixed-digits\"><a href=\"#num-toFixed-digits\" class=\"headerlink\" title=\"num.toFixed(digits)\"></a><strong>num.toFixed(digits)</strong></h3><p>格式化数字，返回字符串。参数<code>digits</code>表示需要保留几位小数。该方法会对数字进行四舍五入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保留小数点后3位</span></span><br><span class=\"line\"><span class=\"number\">1.23</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;1.230&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 保留小数点后2位</span></span><br><span class=\"line\"><span class=\"number\">1.256</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;1.26&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>注意 toFixed 方法同样存在精度丢失的问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果小数部分是一个无限的二进制,存储会造成精度损失</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 1.35000000000000008882</span></span><br><span class=\"line\"><span class=\"number\">1.55</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;1.6&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 6.34999999999999964473</span></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;6.3&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 等操作完后再进行还原</span></span><br><span class=\"line\">(<span class=\"number\">6.35</span> * <span class=\"number\">10</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 63.50000000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isNaN-value\"><a href=\"#isNaN-value\" class=\"headerlink\" title=\"isNaN(value)\"></a><strong>isNaN(value)</strong></h3><p>判断一个值是否为 NaN</p>\n<blockquote>\n<p>注意<code>NaN === NaN</code>的比较结果为<code>false</code>，这是因为<code>NaN</code>是独一无二的，它不等于任何东西，这也是<code>isNaN</code>方法存在的意义。不过，使用<code>Object.is()</code>方法同样可以判断是否为<code>NaN</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">12</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此处发生了类型的隐式转换</span></span><br><span class=\"line\"><span class=\"comment\">// 如果参数不是数字，会尝试将参数转换为数值</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;11&#x27;</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;ab&#x27;</span>) === <span class=\"literal\">true</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Object.is()方法判断</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(<span class=\"title class_\">NaN</span>, <span class=\"title class_\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isFinite-value\"><a href=\"#isFinite-value\" class=\"headerlink\" title=\"isFinite(value)\"></a><strong>isFinite(value)</strong></h3><p>判断传入的数字是否为有限数字，参数是  <code>NaN</code>、正无穷大或者负无穷大，会返回<code>false</code>，其他返回  <code>true</code>。</p>\n<h3 id=\"parseInt-string-radix\"><a href=\"#parseInt-string-radix\" class=\"headerlink\" title=\"parseInt(string, radix)\"></a><strong>parseInt(string, radix)</strong></h3><h3 id=\"parseFloat-string-radix\"><a href=\"#parseFloat-string-radix\" class=\"headerlink\" title=\"parseFloat(string, radix)\"></a><strong>parseFloat(string, radix)</strong></h3><p>将字符串强制转换为十进制数字。参数<code>string</code>表示需要解析的字符串，<code>radix</code>表示解析时采用什么进制，有效范围为<code>2到36</code>。</p>\n<p>不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回<code>NaN</code>。</p>\n<p>第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回<code>NaN</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果第一个字符不能转换为数字，则直接返回NaN</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到其他进制的数字会正常解析，如二进制以0b开头等</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;a12&#x27;</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0b101&#x27;</span>) === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直到读取到非数字为止，会转换之前读取到的数字</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;2a1&#x27;</span>) === <span class=\"number\">2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入非有效进制</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">1</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入0时按照十进制解析</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">0</span>) === <span class=\"number\">1.2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3 并非有效的二进制表示</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Number-value\"><a href=\"#Number-value\" class=\"headerlink\" title=\"Number(value)\"></a><strong>Number(value)</strong></h3><p><code>number</code>类型的对象包装器，可以通过<code>Number()</code>构造函数来创建<code>number</code>类型，这个函数的参数<code>value</code>可以为其他类型如<code>stirng</code>、<code>boolean</code>等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：</p>\n<ul>\n<li><code>boolean</code>，<code>true</code>返回<code>1</code>，<code>false</code>返回<code>0</code>。</li>\n<li><code>number</code>，直接返回值。</li>\n<li><code>null</code>，返回<code>0</code>。</li>\n<li><code>undefined</code>，返回<code>NaN</code>。</li>\n<li><code>string</code>，规则如下:<ul>\n<li>字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字</li>\n<li>空字符串返回<code>0</code></li>\n<li>如果字符串中包含其他字符，则直接返回<code>NaN</code>，注意就算是像<code>&#39;12a&#39;</code>这样的值也会返回<code>NaN</code>，这点与<code>parseInt</code>方法中解析规则直到读取到非数字为止不同。</li>\n</ul>\n</li>\n</ul>\n<p>这里已经涉及到<strong>隐式类型转换</strong>，具体的会在之后详细地解释。</p>\n<h2 id=\"常见面试题\"><a href=\"#常见面试题\" class=\"headerlink\" title=\"常见面试题\"></a>常见面试题</h2><ol>\n<li><code>0.1 + 0.2 !== 0.3</code>的原因（考察 JavaScript 中数字的存储）</li>\n<li><code>[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</code>的输出结果（考察<code>map</code>、<code>parseInt</code>方法以及函数式编程中管道的概念）</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原始类型-primitive-values\"><a href=\"#原始类型-primitive-values\" class=\"headerlink\" title=\"原始类型(primitive values)\"></a>原始类型(primitive values)</h2><p>原始类型一共有七种：<code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>bigInt</code>、<code>symbol</code>。</p>\n<p>原始类型的值本身无法改变，对一个变量重新赋值的时候该原始的值并不会变。</p>\n<blockquote>\n<p>在设计原始类型时，设计者想尽可能地保持原始类型的轻量，但同时考虑到使用者会对原始类型做出很多操作，需要为对原始类型的操作封装成方法。这样的想法显然十分矛盾，而最后的解决方案是为原始类型提供了特殊的“对象包装器”（<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code>），其中封装了许多对原始类型操作的方法，使用完其中的方法后创建的临时对象就会被销毁。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不能为原始类型的实例直接添加属性</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Hi&#x27;</span></span><br><span class=\"line\">str.<span class=\"property\">test</span> = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"property\">test</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以显式地为原始类型进行“包装”</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">num.<span class=\"property\">test</span> = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num.<span class=\"property\">test</span>) <span class=\"comment\">// 33</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在调用原始类型的方法时，由于原始类型上并没有方法</span></span><br><span class=\"line\"><span class=\"comment\">// 会创建一个包含字符串字面值的特殊对象，该对象具有此方法</span></span><br><span class=\"line\"><span class=\"comment\">// 调用完此方法后会将该临时对象销毁，留下原始值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> lower = <span class=\"string\">&#x27;lowercase&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> upper = lower.<span class=\"title function_\">toUpperCase</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(lower) <span class=\"comment\">// lowercase</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(upper) <span class=\"comment\">// LOWERCASE</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>在JavaScript中数字是基于IEEE 754 标准的双精度 64 位二进制格式（IEEE754可视化，可以帮助理解）进行存储，能够安全表示的范围为$-(2^{53}-1)$（即-9007199254740991）到$2^{53}-1$，超过此范围的数字可用BigInt类型来存储。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">1</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NaN(Not-a-Number) 表示非数值</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">NaN</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span> <span class=\"comment\">// 9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MIN_SAFE_INTEGER</span> <span class=\"comment\">// -9007199254740991</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Infinity 表示无穷</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Infinity</span> === <span class=\"string\">&#x27;number&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// +Infinity 表示正无穷 -Infinity 表示负无穷</span></span><br><span class=\"line\">+<span class=\"title class_\">Infinity</span> &gt; <span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在 JavaScript 中，可以直接使用<code>number</code>类型表示浮点数，但需要注意的是，存储浮点数使用的内存空间是存储整数值的两倍（<a href=\"https://zhuanlan.zhihu.com/p/352723802\">具体原理涉及汇编，有基础的话可参考这篇文章</a>），所以在小数点后面没有数字或者小数点后跟的是 0（如 23.00），会被转换为整数。</p>\n<blockquote>\n<p>实际业务场景经常会有需求需要格式化数字，如保留小数后两位，以防像 23.00 这样的数字被处理为 23，可以使用<code>toFixed</code>方法对数字显式地进行格式化</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> floatNum1 = <span class=\"number\">1.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum2 = <span class=\"number\">.2</span> <span class=\"comment\">// 小数点前可以不需要整数，但这种做法并不推荐</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> floatNum3 = <span class=\"number\">3.000</span> <span class=\"comment\">// 会被当作整数3处理</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"精度丢失问题（0-1-0-2-0-3）\"><a href=\"#精度丢失问题（0-1-0-2-0-3）\" class=\"headerlink\" title=\"精度丢失问题（0.1+0.2 !== 0.3）\"></a>精度丢失问题（0.1+0.2 !== 0.3）</h2><p>造成这个原因的是在 JavaScript 中数字以二进制的形式存储在内存中，而像 0.1、0.2 这样的小数在进行<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6\">二进制</a>转换后会出现无限循环，而在 JavaScript 中数字以 64 位格式<a href=\"https://zh.wikipedia.org/wiki/IEEE_754\">IEEE 754</a> 表示：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。超过其范围就会将数字舍入到最接近的可能数字，从而造成了极小的精度损失。</p>\n<blockquote>\n<p>虽然存在一位用于表示符号，但是<code>+0</code>与<code>-0</code>在 JavaScript 中被认为是相等的，但可以使用<code>Object.is()</code>方法可以判断<code>+0</code>与<code>-0</code>不相等，此为特殊情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">+<span class=\"number\">0</span> === -<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(+<span class=\"number\">0</span>, -<span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span>+<span class=\"number\">0.2</span> <span class=\"comment\">// 0.30000000000000004</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该数字转换为二进制后存在53位，超出范围</span></span><br><span class=\"line\"><span class=\"number\">9999999999999999</span> <span class=\"comment\">// 10000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<p>并不只是 JavaScript 存在该问题，其他使用 IEEE 754 标准来存储数字的语言也存在该问题。</p>\n<h2 id=\"使用科学计数法表示\"><a href=\"#使用科学计数法表示\" class=\"headerlink\" title=\"使用科学计数法表示\"></a>使用科学计数法表示</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用科学计数法</span></span><br><span class=\"line\"><span class=\"number\">1e2</span> === <span class=\"number\">100</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">1e-3</span> === <span class=\"number\">0.001</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二进制，八进制与十六进制\"><a href=\"#二进制，八进制与十六进制\" class=\"headerlink\" title=\"二进制，八进制与十六进制\"></a>二进制，八进制与十六进制</h2><p>javaScript 中默认支持这三种进制的写法，其他进制可以通过方法<code>parseInt</code>转换</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不正确的进制表示会报语法错误</span></span><br><span class=\"line\"><span class=\"comment\">// 二进制数字每位只能是1或0</span></span><br><span class=\"line\">0b103 <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不同进制的数字在进行数学操作时都会被视作为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">0b101</span>+<span class=\"number\">017</span> === <span class=\"number\">20</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> + <span class=\"number\">0o377</span> === <span class=\"number\">510</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制 使用0b前缀</span></span><br><span class=\"line\"><span class=\"number\">0b101</span> === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制 使用0o前缀</span></span><br><span class=\"line\"><span class=\"number\">0o17</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非严格模式下可以使用前缀0来表示八进制（不推荐）</span></span><br><span class=\"line\"><span class=\"number\">017</span> === <span class=\"number\">15</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 超过八进制每位的表示范围（0-7）会忽略前缀0，被视为十进制数字</span></span><br><span class=\"line\"><span class=\"number\">019</span> === <span class=\"number\">19</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制 使用0x前缀</span></span><br><span class=\"line\"><span class=\"number\">0xff</span> === <span class=\"number\">255</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 大小写不会造成影响</span></span><br><span class=\"line\"><span class=\"number\">0xfF</span> === <span class=\"number\">0xff</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><blockquote>\n<p>不能直接在整数数字后面采用点（.）加上方法名的形式来调用方法，因为 JavaScript 语法中隐含了第一个点之后的部分为小数部分，所以直接调用会报语法错误。可以使用两个点(只对十进制数字整数有效)或者用括号将数字部分包裹的形式来进行调用。如果数字本身存在小数部分则可以直接采用点加上方法名的形式来调用方法。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6.</span><span class=\"title function_\">toString</span>() <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">0xfe</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;254&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"number\">20</span>).<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">20.</span>.<span class=\"title function_\">toString</span>() === <span class=\"string\">&#x27;20&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toString-base\"><a href=\"#num-toString-base\" class=\"headerlink\" title=\"num.toString(base)\"></a><strong>num.toString(base)</strong></h3><p>将数字转换为字符串，参数<code>base</code>表示需要转换的进制，默认值为 10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转换为二进制</span></span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"title function_\">toString</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;10&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 八进制转换为十六进制</span></span><br><span class=\"line\">(<span class=\"number\">0o377</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>) === <span class=\"string\">&#x27;ff&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"num-toFixed-digits\"><a href=\"#num-toFixed-digits\" class=\"headerlink\" title=\"num.toFixed(digits)\"></a><strong>num.toFixed(digits)</strong></h3><p>格式化数字，返回字符串。参数<code>digits</code>表示需要保留几位小数。该方法会对数字进行四舍五入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保留小数点后3位</span></span><br><span class=\"line\"><span class=\"number\">1.23</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;1.230&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 保留小数点后2位</span></span><br><span class=\"line\"><span class=\"number\">1.256</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">2</span>) === <span class=\"string\">&#x27;1.26&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>注意 toFixed 方法同样存在精度丢失的问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果小数部分是一个无限的二进制,存储会造成精度损失</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 1.35000000000000008882</span></span><br><span class=\"line\"><span class=\"number\">1.55</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;1.6&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 6.34999999999999964473</span></span><br><span class=\"line\"><span class=\"number\">6.35</span>.<span class=\"title function_\">toFixed</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;6.3&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方法为先将其转换为能够在二进制数字系统中可以被精确地表示的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 等操作完后再进行还原</span></span><br><span class=\"line\">(<span class=\"number\">6.35</span> * <span class=\"number\">10</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">20</span>) <span class=\"comment\">// 63.50000000000000000000</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isNaN-value\"><a href=\"#isNaN-value\" class=\"headerlink\" title=\"isNaN(value)\"></a><strong>isNaN(value)</strong></h3><p>判断一个值是否为 NaN</p>\n<blockquote>\n<p>注意<code>NaN === NaN</code>的比较结果为<code>false</code>，这是因为<code>NaN</code>是独一无二的，它不等于任何东西，这也是<code>isNaN</code>方法存在的意义。不过，使用<code>Object.is()</code>方法同样可以判断是否为<code>NaN</code>。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">12</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此处发生了类型的隐式转换</span></span><br><span class=\"line\"><span class=\"comment\">// 如果参数不是数字，会尝试将参数转换为数值</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;11&#x27;</span>) === <span class=\"literal\">false</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">&#x27;ab&#x27;</span>) === <span class=\"literal\">true</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Object.is()方法判断</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">is</span>(<span class=\"title class_\">NaN</span>, <span class=\"title class_\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"isFinite-value\"><a href=\"#isFinite-value\" class=\"headerlink\" title=\"isFinite(value)\"></a><strong>isFinite(value)</strong></h3><p>判断传入的数字是否为有限数字，参数是  <code>NaN</code>、正无穷大或者负无穷大，会返回<code>false</code>，其他返回  <code>true</code>。</p>\n<h3 id=\"parseInt-string-radix\"><a href=\"#parseInt-string-radix\" class=\"headerlink\" title=\"parseInt(string, radix)\"></a><strong>parseInt(string, radix)</strong></h3><h3 id=\"parseFloat-string-radix\"><a href=\"#parseFloat-string-radix\" class=\"headerlink\" title=\"parseFloat(string, radix)\"></a><strong>parseFloat(string, radix)</strong></h3><p>将字符串强制转换为十进制数字。参数<code>string</code>表示需要解析的字符串，<code>radix</code>表示解析时采用什么进制，有效范围为<code>2到36</code>。</p>\n<p>不传第二个参数或传入的参数值为 0 时默认按照十进制进行解析，传入其他非有效进制的值时会返回<code>NaN</code>。</p>\n<p>第一个参数中数字的进制如果与第二个参数中的进制不匹配时也会返回<code>NaN</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果第一个字符不能转换为数字，则直接返回NaN</span></span><br><span class=\"line\"><span class=\"comment\">// 遇到其他进制的数字会正常解析，如二进制以0b开头等</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;a12&#x27;</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0b101&#x27;</span>) === <span class=\"number\">5</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直到读取到非数字为止，会转换之前读取到的数字</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;2a1&#x27;</span>) === <span class=\"number\">2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入非有效进制</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">1</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数传入0时按照十进制解析</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">&#x27;1.2&#x27;</span>, <span class=\"number\">0</span>) === <span class=\"number\">1.2</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3 并非有效的二进制表示</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;3&#x27;</span>, <span class=\"number\">2</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Number-value\"><a href=\"#Number-value\" class=\"headerlink\" title=\"Number(value)\"></a><strong>Number(value)</strong></h3><p><code>number</code>类型的对象包装器，可以通过<code>Number()</code>构造函数来创建<code>number</code>类型，这个函数的参数<code>value</code>可以为其他类型如<code>stirng</code>、<code>boolean</code>等类型的值。由此可见，该函数主要用于数值转换，根据参数，具体的转换规则如下：</p>\n<ul>\n<li><code>boolean</code>，<code>true</code>返回<code>1</code>，<code>false</code>返回<code>0</code>。</li>\n<li><code>number</code>，直接返回值。</li>\n<li><code>null</code>，返回<code>0</code>。</li>\n<li><code>undefined</code>，返回<code>NaN</code>。</li>\n<li><code>string</code>，规则如下:<ul>\n<li>字符串为数字时（包括二进制、十六进制、浮点数等能被 JavaScript 失败的数字）返回对应的十进制数字</li>\n<li>空字符串返回<code>0</code></li>\n<li>如果字符串中包含其他字符，则直接返回<code>NaN</code>，注意就算是像<code>&#39;12a&#39;</code>这样的值也会返回<code>NaN</code>，这点与<code>parseInt</code>方法中解析规则直到读取到非数字为止不同。</li>\n</ul>\n</li>\n</ul>\n<p>这里已经涉及到<strong>隐式类型转换</strong>，具体的会在之后详细地解释。</p>\n<h2 id=\"常见面试题\"><a href=\"#常见面试题\" class=\"headerlink\" title=\"常见面试题\"></a>常见面试题</h2><ol>\n<li><code>0.1 + 0.2 !== 0.3</code>的原因（考察 JavaScript 中数字的存储）</li>\n<li><code>[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</code>的输出结果（考察<code>map</code>、<code>parseInt</code>方法以及函数式编程中管道的概念）</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之变量","date":"2022-05-05T06:02:00.000Z","updated":"2022-05-05T11:38:52.880Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# 作用域简述\n\n提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。\n\nJavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块`{...}`。在这里先粗略地知道这三个概念就可以了。\n\n# JS变量\n\n\n在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。\n\n一共有三个关键字用于声明变量：`var`、`let`、`const`。其中`let`、`const`为ES6时新增的关键字，只能在ES6之后的版本使用。\n\n从另一个角度来说，使用`function`、`import`、`class`关键字也可以声明变量，但这里不会提及。\n\n需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为`window`。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。\n\n```js\nif(true) {\n\ta = 10\n}\n\n// 浏览器环境下\nthis === window // true\nconsole.log(this.a) // 10\n```\n\n需要定义多个变量时可以使用`,`号分隔每个变量。\n\n```js\nvar str1 = 'c++', str2 = 'java', str3 = 'c#'\n```\n\n# 变量命名\n\nJavaScript 的变量命名有两个限制：\n\n1. 变量名仅包含字母，数字，符号 `$`\n 和 `_`。\n2. 首字符必须非数字。\n\n> 除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如`async`仍可以用来命名，不能用来命名的关键字可以参考[保留关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97)，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。\n> \n\n```js\nconst 1m = 2 // Uncaught SyntaxError: Invalid or unexpected token\nvar t-an; // Uncaught SyntaxError: Unexpected token '-'\n\nlet 这是一个变量名 = 22 // 合法，但不推荐\n```\n\n现在主流的命名方式是[小驼峰](https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。\n\n常量用作别名时，命名时通常会将单词大写，单词与单词之间使用`_`链接。\n\n```js\nlet currentYear = 2022\nconst COMPANY_NAME = 'it is too looooooooooooooong to remember'\n```\n\n# var 关键字\n\n在声明未赋值的情况下变量会保存一个特殊值`undefined`。\n\n```js\nvar msg // 声明\nconsole.log(msg) // undefined\n```\n\n可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。\n\n```js\nvar msg = 100 // 声明变量并进行赋值\nmsg = 'Hi' \n```\n\n重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。\n\n```js\nvar test = true // 声明并赋值\nvar test = false // 无效的重复声明\nconsole.log(test) // false\n```\n\n通过var声明的全局变量也会挂到全局对象上去。\n\n```js\nvar aaa = 'aaa'\n\n// 浏览器环境下\nwindow.aaa === 'aaa' // true\n```\n\n## 作用范围\n\n由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有`var`，因此通过关键字`var`声明的变量的有效作用范围为函数作用域。\n\n在函数作用域中使用`var`关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。\n\n```js\nfunction fn1 () {\n\tvar n = 100 // 函数作用域中定义的局部变量\n}\nfn1();\nconsole.log(n) // Uncaught ReferenceError: msg is not defined\n```\n\n## 变量提升\n\n变量提升指的是会将变量的声明提升到当前作用域的顶部。用`var`关键字定义的变量就存在变量提升，注意**提升的只是变量的声明，并不是赋值**。\n\n```js\nconsole.log(age) // undefined\nvar age = 99\n\nfunction test() {\n\t// 变量提升，变量a先被赋值为1，再被赋值为0\n\ta = 1;\n\tvar a = 0;\n\tconsole.log(a) // 0\n}\n```\n\n## 模仿块级作用域\n\n由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为`(function(){...})()`，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。\n\n```js\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n})()\n\n// 以下的写法也可以\n+function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}()\n\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}())\n\n```\n\n# let 关键字\n\n## 作用范围\n\n这里主要讲一下`let`与`var`的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用`var`关键字声明的变量在块级作用域之外仍能够访问。\n\n```js\n{\n\tlet a = 1\n\tvar b = 2\n}\n\nconsole.log(a) // Uncaught ReferenceError: a is not defined\nconsole.log(b) // 2\n\nfor(var i = 0; i < 5; i++) {\n  // 不受块级作用域约束，迭代变量渗透到循环体外部\n\t// 相当于重复声明i, 并对其赋值\n\t// 输出5个5\n\tsetTimeout(()=>{\n\t\tconsole.log(i)\n\t})\n}\n\nfor(let j = 0; j < 5; j++) {\n\t// 受到块级作用域的约束\n\t// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值\n\t// 输出 0 1 2 3 4\n\tsetTimeout(()=>{\n\t\tconsole.log(j)\n\t})\n}\n```\n\n同时使用`let`关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。\n\n```js\nvar time;\nlet time; // Uncaught SyntaxError: Identifier 'time' has already been declared\n\nlet age;\nvar age; // Uncaught SyntaxError: Identifier 'age' has already been declared\n\nlet name = 'Joe'\nif(true) {\n\tlet name = 'Roselyn'\n\tconsole.log(name) // Roselyn\n}\nconsole.log(name) // Joe\n\n```\n\n当使用`let`关键字在全局作用域声明变量时也不会污染全局对象。\n\n```js\nlet a = 10;\n// 浏览器环境下\nthis.a // undefined\n```\n\n## 暂时性死区（temporal dead zone，简称 TDZ）\n\n使用`let`声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在`let`变量声明之前的部分被称为暂时性死区，在暂时性死区中引用`let`变量会报引用错误。\n\n```js\nconsole.log(temp) // Uncaught ReferenceError: temp is not defined\n\nlet temp = 'Hi'\n```\n\n使用`typeof`访问暂时性死区中的let变量也会报错。\n\n```js\ntypeof a // 'undefined'\ntypeof b // 'undefined'\ntypeof c // Uncaught ReferenceError: c is not defined\n\nvar b\nlet c\n```\n\n# const 关键字\n\n与`let`相似，`const`的作用范围是块级作用域，也存在暂时性死区。使用`const`关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。\n\n```js\nconst a = 2\n// 即使是相等的值也不行\na = 2 // Uncaught TypeError: Assignment to constant variable\n\nconst b // Uncaught SyntaxError: Missing initializer in const declaration\n```\n\n不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于**原始类型**来说，变量指向的那个内存地址所保存的就是对应的值，而**引用类型**变量指向的内存地址，保存的是指向实际数据的地址，`const`只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。\n\n```js\nconst person = {}\n// 向对象中添加属性\nperson.age = 24\nperson.name = 'ikura'\n\n// 尝试改变指向的地址\nperson = {} // Uncaught TypeError: Assignment to constant variable\n```\n\n# 常见面试题\n\n1. 代码输出结果（变量提升）\n    \n    ```js\n    function sayHi() {\n      console.log(name);\n      console.log(age);\n      var name = \"Jerry\";\n      let age = 82;\n    }\n    \n    sayHi();\n    ```\n    \n2. 代码输出结果（变量声明）\n    \n    ```js\n    let day = 13\n    dya = 14\n    console.log(dya)\n    ```\n    \n3. 代码输出结果(变量作用范围)\n    \n    ```js\n    for(var i = 0; i < 5; i++) {\n    \tsetTimeout(()=>{\n    \t\tconsole.log(i)\n    \t})\n    }\n    \n    for(let i = 0; i < 5; i++) {\n    \tsetTimeout(()=>{\n    \t\tconsole.log(i)\n    \t})\n    }\n    ```\n    \n4. 代码输出结果（变量作用范围）\n    \n    ```js\n    var a = 13; \n    function fun(){ \n    \tvar a = 10; \n    } \n    fun(); \n    console.log(a)\n    ```\n    \n5. 代码输出结果（变量提升）\n    \n    ```js\n    a = 2\n    var a\n    console.log(a)\n    ```\n    \n6. 代码输出结果（变量提升）\n    \n    ```js\n    if(false) {\n    \tvar temp = 5\n    }\n    console.log(temp)\n    ```\n    \n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/js-again-varible.md","raw":"---\ntitle: 再学 JS 之变量\ndate: 2022-05-05 14:02:00\nupdated:\ntags: JavaScript\ncategories: 前端\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# 作用域简述\n\n提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。\n\nJavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块`{...}`。在这里先粗略地知道这三个概念就可以了。\n\n# JS变量\n\n\n在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。\n\n一共有三个关键字用于声明变量：`var`、`let`、`const`。其中`let`、`const`为ES6时新增的关键字，只能在ES6之后的版本使用。\n\n从另一个角度来说，使用`function`、`import`、`class`关键字也可以声明变量，但这里不会提及。\n\n需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为`window`。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。\n\n```js\nif(true) {\n\ta = 10\n}\n\n// 浏览器环境下\nthis === window // true\nconsole.log(this.a) // 10\n```\n\n需要定义多个变量时可以使用`,`号分隔每个变量。\n\n```js\nvar str1 = 'c++', str2 = 'java', str3 = 'c#'\n```\n\n# 变量命名\n\nJavaScript 的变量命名有两个限制：\n\n1. 变量名仅包含字母，数字，符号 `$`\n 和 `_`。\n2. 首字符必须非数字。\n\n> 除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如`async`仍可以用来命名，不能用来命名的关键字可以参考[保留关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97)，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。\n> \n\n```js\nconst 1m = 2 // Uncaught SyntaxError: Invalid or unexpected token\nvar t-an; // Uncaught SyntaxError: Unexpected token '-'\n\nlet 这是一个变量名 = 22 // 合法，但不推荐\n```\n\n现在主流的命名方式是[小驼峰](https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。\n\n常量用作别名时，命名时通常会将单词大写，单词与单词之间使用`_`链接。\n\n```js\nlet currentYear = 2022\nconst COMPANY_NAME = 'it is too looooooooooooooong to remember'\n```\n\n# var 关键字\n\n在声明未赋值的情况下变量会保存一个特殊值`undefined`。\n\n```js\nvar msg // 声明\nconsole.log(msg) // undefined\n```\n\n可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。\n\n```js\nvar msg = 100 // 声明变量并进行赋值\nmsg = 'Hi' \n```\n\n重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。\n\n```js\nvar test = true // 声明并赋值\nvar test = false // 无效的重复声明\nconsole.log(test) // false\n```\n\n通过var声明的全局变量也会挂到全局对象上去。\n\n```js\nvar aaa = 'aaa'\n\n// 浏览器环境下\nwindow.aaa === 'aaa' // true\n```\n\n## 作用范围\n\n由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有`var`，因此通过关键字`var`声明的变量的有效作用范围为函数作用域。\n\n在函数作用域中使用`var`关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。\n\n```js\nfunction fn1 () {\n\tvar n = 100 // 函数作用域中定义的局部变量\n}\nfn1();\nconsole.log(n) // Uncaught ReferenceError: msg is not defined\n```\n\n## 变量提升\n\n变量提升指的是会将变量的声明提升到当前作用域的顶部。用`var`关键字定义的变量就存在变量提升，注意**提升的只是变量的声明，并不是赋值**。\n\n```js\nconsole.log(age) // undefined\nvar age = 99\n\nfunction test() {\n\t// 变量提升，变量a先被赋值为1，再被赋值为0\n\ta = 1;\n\tvar a = 0;\n\tconsole.log(a) // 0\n}\n```\n\n## 模仿块级作用域\n\n由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为`(function(){...})()`，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。\n\n```js\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n})()\n\n// 以下的写法也可以\n+function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}()\n\n(function(){\n\tvar temp = 20;\n\tconsole.log(temp)\n}())\n\n```\n\n# let 关键字\n\n## 作用范围\n\n这里主要讲一下`let`与`var`的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用`var`关键字声明的变量在块级作用域之外仍能够访问。\n\n```js\n{\n\tlet a = 1\n\tvar b = 2\n}\n\nconsole.log(a) // Uncaught ReferenceError: a is not defined\nconsole.log(b) // 2\n\nfor(var i = 0; i < 5; i++) {\n  // 不受块级作用域约束，迭代变量渗透到循环体外部\n\t// 相当于重复声明i, 并对其赋值\n\t// 输出5个5\n\tsetTimeout(()=>{\n\t\tconsole.log(i)\n\t})\n}\n\nfor(let j = 0; j < 5; j++) {\n\t// 受到块级作用域的约束\n\t// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值\n\t// 输出 0 1 2 3 4\n\tsetTimeout(()=>{\n\t\tconsole.log(j)\n\t})\n}\n```\n\n同时使用`let`关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。\n\n```js\nvar time;\nlet time; // Uncaught SyntaxError: Identifier 'time' has already been declared\n\nlet age;\nvar age; // Uncaught SyntaxError: Identifier 'age' has already been declared\n\nlet name = 'Joe'\nif(true) {\n\tlet name = 'Roselyn'\n\tconsole.log(name) // Roselyn\n}\nconsole.log(name) // Joe\n\n```\n\n当使用`let`关键字在全局作用域声明变量时也不会污染全局对象。\n\n```js\nlet a = 10;\n// 浏览器环境下\nthis.a // undefined\n```\n\n## 暂时性死区（temporal dead zone，简称 TDZ）\n\n使用`let`声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在`let`变量声明之前的部分被称为暂时性死区，在暂时性死区中引用`let`变量会报引用错误。\n\n```js\nconsole.log(temp) // Uncaught ReferenceError: temp is not defined\n\nlet temp = 'Hi'\n```\n\n使用`typeof`访问暂时性死区中的let变量也会报错。\n\n```js\ntypeof a // 'undefined'\ntypeof b // 'undefined'\ntypeof c // Uncaught ReferenceError: c is not defined\n\nvar b\nlet c\n```\n\n# const 关键字\n\n与`let`相似，`const`的作用范围是块级作用域，也存在暂时性死区。使用`const`关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。\n\n```js\nconst a = 2\n// 即使是相等的值也不行\na = 2 // Uncaught TypeError: Assignment to constant variable\n\nconst b // Uncaught SyntaxError: Missing initializer in const declaration\n```\n\n不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于**原始类型**来说，变量指向的那个内存地址所保存的就是对应的值，而**引用类型**变量指向的内存地址，保存的是指向实际数据的地址，`const`只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。\n\n```js\nconst person = {}\n// 向对象中添加属性\nperson.age = 24\nperson.name = 'ikura'\n\n// 尝试改变指向的地址\nperson = {} // Uncaught TypeError: Assignment to constant variable\n```\n\n# 常见面试题\n\n1. 代码输出结果（变量提升）\n    \n    ```js\n    function sayHi() {\n      console.log(name);\n      console.log(age);\n      var name = \"Jerry\";\n      let age = 82;\n    }\n    \n    sayHi();\n    ```\n    \n2. 代码输出结果（变量声明）\n    \n    ```js\n    let day = 13\n    dya = 14\n    console.log(dya)\n    ```\n    \n3. 代码输出结果(变量作用范围)\n    \n    ```js\n    for(var i = 0; i < 5; i++) {\n    \tsetTimeout(()=>{\n    \t\tconsole.log(i)\n    \t})\n    }\n    \n    for(let i = 0; i < 5; i++) {\n    \tsetTimeout(()=>{\n    \t\tconsole.log(i)\n    \t})\n    }\n    ```\n    \n4. 代码输出结果（变量作用范围）\n    \n    ```js\n    var a = 13; \n    function fun(){ \n    \tvar a = 10; \n    } \n    fun(); \n    console.log(a)\n    ```\n    \n5. 代码输出结果（变量提升）\n    \n    ```js\n    a = 2\n    var a\n    console.log(a)\n    ```\n    \n6. 代码输出结果（变量提升）\n    \n    ```js\n    if(false) {\n    \tvar temp = 5\n    }\n    console.log(temp)\n    ```\n    \n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"js-again-varible","published":1,"_id":"cl2swzk0u00017yo9dckjg3zj","layout":"post","photos":[],"link":"","content":"<h1 id=\"作用域简述\"><a href=\"#作用域简述\" class=\"headerlink\" title=\"作用域简述\"></a>作用域简述</h1><p>提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。</p>\n<p>JavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块<code>&#123;...&#125;</code>。在这里先粗略地知道这三个概念就可以了。</p>\n<h1 id=\"JS变量\"><a href=\"#JS变量\" class=\"headerlink\" title=\"JS变量\"></a>JS变量</h1><p>在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。</p>\n<p>一共有三个关键字用于声明变量：<code>var</code>、<code>let</code>、<code>const</code>。其中<code>let</code>、<code>const</code>为ES6时新增的关键字，只能在ES6之后的版本使用。</p>\n<p>从另一个角度来说，使用<code>function</code>、<code>import</code>、<code>class</code>关键字也可以声明变量，但这里不会提及。</p>\n<p>需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为<code>window</code>。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\ta = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span> === <span class=\"variable language_\">window</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>需要定义多个变量时可以使用<code>,</code>号分隔每个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">&#x27;c++&#x27;</span>, str2 = <span class=\"string\">&#x27;java&#x27;</span>, str3 = <span class=\"string\">&#x27;c#&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h1><p>JavaScript 的变量命名有两个限制：</p>\n<ol>\n<li>变量名仅包含字母，数字，符号 <code>$</code><br> 和 <code>_</code>。</li>\n<li>首字符必须非数字。</li>\n</ol>\n<blockquote>\n<p>除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如<code>async</code>仍可以用来命名，不能用来命名的关键字可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97\">保留关键字</a>，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> 1m = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> t-an; <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;-&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> 这是一个变量名 = <span class=\"number\">22</span> <span class=\"comment\">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>\n\n<p>现在主流的命名方式是<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB\">小驼峰</a>式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。</p>\n<p>常量用作别名时，命名时通常会将单词大写，单词与单词之间使用<code>_</code>链接。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentYear = <span class=\"number\">2022</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">COMPANY_NAME</span> = <span class=\"string\">&#x27;it is too looooooooooooooong to remember&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"var-关键字\"><a href=\"#var-关键字\" class=\"headerlink\" title=\"var 关键字\"></a>var 关键字</h1><p>在声明未赋值的情况下变量会保存一个特殊值<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"number\">100</span> <span class=\"comment\">// 声明变量并进行赋值</span></span><br><span class=\"line\">msg = <span class=\"string\">&#x27;Hi&#x27;</span> </span><br></pre></td></tr></table></figure>\n\n<p>重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">true</span> <span class=\"comment\">// 声明并赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">false</span> <span class=\"comment\">// 无效的重复声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>通过var声明的全局变量也会挂到全局对象上去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aaa = <span class=\"string\">&#x27;aaa&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">aaa</span> === <span class=\"string\">&#x27;aaa&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有<code>var</code>，因此通过关键字<code>var</code>声明的变量的有效作用范围为函数作用域。</p>\n<p>在函数作用域中使用<code>var</code>关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span> () &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> n = <span class=\"number\">100</span> <span class=\"comment\">// 函数作用域中定义的局部变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n) <span class=\"comment\">// Uncaught ReferenceError: msg is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><p>变量提升指的是会将变量的声明提升到当前作用域的顶部。用<code>var</code>关键字定义的变量就存在变量提升，注意<strong>提升的只是变量的声明，并不是赋值</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 变量提升，变量a先被赋值为1，再被赋值为0</span></span><br><span class=\"line\">\ta = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为<code>(function()&#123;...&#125;)()</code>，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下的写法也可以</span></span><br><span class=\"line\">+<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"let-关键字\"><a href=\"#let-关键字\" class=\"headerlink\" title=\"let 关键字\"></a>let 关键字</h1><h2 id=\"作用范围-1\"><a href=\"#作用范围-1\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>这里主要讲一下<code>let</code>与<code>var</code>的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用<code>var</code>关键字声明的变量在块级作用域之外仍能够访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不受块级作用域约束，迭代变量渗透到循环体外部</span></span><br><span class=\"line\">\t<span class=\"comment\">// 相当于重复声明i, 并对其赋值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出5个5</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 受到块级作用域的约束</span></span><br><span class=\"line\">\t<span class=\"comment\">// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出 0 1 2 3 4</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时使用<code>let</code>关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time;</span><br><span class=\"line\"><span class=\"keyword\">let</span> time; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;time&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Joe&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Roselyn&#x27;</span></span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Roselyn</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Joe</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当使用<code>let</code>关键字在全局作用域声明变量时也不会污染全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">a</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"暂时性死区（temporal-dead-zone，简称-TDZ）\"><a href=\"#暂时性死区（temporal-dead-zone，简称-TDZ）\" class=\"headerlink\" title=\"暂时性死区（temporal dead zone，简称 TDZ）\"></a>暂时性死区（temporal dead zone，简称 TDZ）</h2><p>使用<code>let</code>声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在<code>let</code>变量声明之前的部分被称为暂时性死区，在暂时性死区中引用<code>let</code>变量会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp) <span class=\"comment\">// Uncaught ReferenceError: temp is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> temp = <span class=\"string\">&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>typeof</code>访问暂时性死区中的let变量也会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c <span class=\"comment\">// Uncaught ReferenceError: c is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b</span><br><span class=\"line\"><span class=\"keyword\">let</span> c</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h1><p>与<code>let</code>相似，<code>const</code>的作用范围是块级作用域，也存在暂时性死区。使用<code>const</code>关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 即使是相等的值也不行</span></span><br><span class=\"line\">a = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b <span class=\"comment\">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>\n\n<p>不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于<strong>原始类型</strong>来说，变量指向的那个内存地址所保存的就是对应的值，而<strong>引用类型</strong>变量指向的内存地址，保存的是指向实际数据的地址，<code>const</code>只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 向对象中添加属性</span></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">24</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;ikura&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试改变指向的地址</span></span><br><span class=\"line\">person = &#123;&#125; <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常见面试题\"><a href=\"#常见面试题\" class=\"headerlink\" title=\"常见面试题\"></a>常见面试题</h1><ol>\n<li>代码输出结果（变量提升） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Jerry&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> age = <span class=\"number\">82</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">sayHi</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量声明） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> day = <span class=\"number\">13</span></span><br><span class=\"line\">dya = <span class=\"number\">14</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dya)</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果(变量作用范围) <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量作用范围） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">13</span>; </span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun</span>(<span class=\"params\"></span>)&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">10</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"title function_\">fun</span>(); </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量提升） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量提升） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用域简述\"><a href=\"#作用域简述\" class=\"headerlink\" title=\"作用域简述\"></a>作用域简述</h1><p>提到变量，就离不开作用域，这里先简单提及一下，具体的会放到后面讲。作用域指的是当前执行的上下文，也可以理解为作用范围。子作用域可以访问父作用域，而父作用域不能访问子作用域（涉及作用域链）。</p>\n<p>JavaScript中作用域分为全局作用域、函数作用域和块级作用域（ES6新增）。顾名思义，全局作用域的作用范围为全局，函数作用域为当前的函数，块级作用域为所在的代码块<code>&#123;...&#125;</code>。在这里先粗略地知道这三个概念就可以了。</p>\n<h1 id=\"JS变量\"><a href=\"#JS变量\" class=\"headerlink\" title=\"JS变量\"></a>JS变量</h1><p>在JavaScript中，变量为松散类型，可以用于保存任何类型的数据。</p>\n<p>一共有三个关键字用于声明变量：<code>var</code>、<code>let</code>、<code>const</code>。其中<code>let</code>、<code>const</code>为ES6时新增的关键字，只能在ES6之后的版本使用。</p>\n<p>从另一个角度来说，使用<code>function</code>、<code>import</code>、<code>class</code>关键字也可以声明变量，但这里不会提及。</p>\n<p>需要注意的是，在非严格模式下，不使用关键字声明的变量为全局变量，会被挂到全局对象上，在浏览器环境下为<code>window</code>。不过这样做的话会不仅会导致变量难以维护，而且变量无法被回收，污染了全局对象，造成了内存泄漏。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\ta = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span> === <span class=\"variable language_\">window</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>需要定义多个变量时可以使用<code>,</code>号分隔每个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">&#x27;c++&#x27;</span>, str2 = <span class=\"string\">&#x27;java&#x27;</span>, str3 = <span class=\"string\">&#x27;c#&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"变量命名\"><a href=\"#变量命名\" class=\"headerlink\" title=\"变量命名\"></a>变量命名</h1><p>JavaScript 的变量命名有两个限制：</p>\n<ol>\n<li>变量名仅包含字母，数字，符号 <code>$</code><br> 和 <code>_</code>。</li>\n<li>首字符必须非数字。</li>\n</ol>\n<blockquote>\n<p>除此之外，JavaScript中的关键字也不能用来命名变量，但并不是所有的关键字，比如<code>async</code>仍可以用来命名，不能用来命名的关键字可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_6_%E4%B8%AD%E7%9A%84%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97\">保留关键字</a>，为了以防在未来的版本中关键字被加入到保留关键字中，最好不要使用关键字对变量命名。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> 1m = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> t-an; <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;-&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> 这是一个变量名 = <span class=\"number\">22</span> <span class=\"comment\">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>\n\n<p>现在主流的命名方式是<a href=\"https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB\">小驼峰</a>式命名法，即首个单词的首字母小写，从第二个单词开始首字母大写。</p>\n<p>常量用作别名时，命名时通常会将单词大写，单词与单词之间使用<code>_</code>链接。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentYear = <span class=\"number\">2022</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">COMPANY_NAME</span> = <span class=\"string\">&#x27;it is too looooooooooooooong to remember&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"var-关键字\"><a href=\"#var-关键字\" class=\"headerlink\" title=\"var 关键字\"></a>var 关键字</h1><p>在声明未赋值的情况下变量会保存一个特殊值<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>可以重新赋值，不仅可以改变值，也可以改变值的类型，但并不推荐这样做，容易引起逻辑混乱。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"number\">100</span> <span class=\"comment\">// 声明变量并进行赋值</span></span><br><span class=\"line\">msg = <span class=\"string\">&#x27;Hi&#x27;</span> </span><br></pre></td></tr></table></figure>\n\n<p>重复声明不会报错，但是会被认为是无效声明，但是赋值是有效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">true</span> <span class=\"comment\">// 声明并赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"literal\">false</span> <span class=\"comment\">// 无效的重复声明</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>通过var声明的全局变量也会挂到全局对象上去。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aaa = <span class=\"string\">&#x27;aaa&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">aaa</span> === <span class=\"string\">&#x27;aaa&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用范围\"><a href=\"#作用范围\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>由于在ES6之前并没有块级作用域与全局作用域之分，且声明变量的关键字也只有<code>var</code>，因此通过关键字<code>var</code>声明的变量的有效作用范围为函数作用域。</p>\n<p>在函数作用域中使用<code>var</code>关键字定义的变量只能在其定义的函数中访问，在作用范围外调用会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span> () &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> n = <span class=\"number\">100</span> <span class=\"comment\">// 函数作用域中定义的局部变量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n) <span class=\"comment\">// Uncaught ReferenceError: msg is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><p>变量提升指的是会将变量的声明提升到当前作用域的顶部。用<code>var</code>关键字定义的变量就存在变量提升，注意<strong>提升的只是变量的声明，并不是赋值</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 变量提升，变量a先被赋值为1，再被赋值为0</span></span><br><span class=\"line\">\ta = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>由于在ES6之前并不存在块级作用域，但是上有政策下有对策，程序员们发明了“立即调用函数表达式”（immediately-invoked function expressions，IIFE），即创建一个函数并立刻调用它来实现块级作用域的效果，一般的写法为<code>(function()&#123;...&#125;)()</code>，尽管在ES6块级作用域出现后，这种方法就不再使用了，但有时候还是会遇到这种写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下的写法也可以</span></span><br><span class=\"line\">+<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br><span class=\"line\">&#125;())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"let-关键字\"><a href=\"#let-关键字\" class=\"headerlink\" title=\"let 关键字\"></a>let 关键字</h1><h2 id=\"作用范围-1\"><a href=\"#作用范围-1\" class=\"headerlink\" title=\"作用范围\"></a>作用范围</h2><p>这里主要讲一下<code>let</code>与<code>var</code>的区别，let作为块级作用域变量，只能在其声明的作用域或子域中使用，而在块级作用域中使用<code>var</code>关键字声明的变量在块级作用域之外仍能够访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 不受块级作用域约束，迭代变量渗透到循环体外部</span></span><br><span class=\"line\">\t<span class=\"comment\">// 相当于重复声明i, 并对其赋值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出5个5</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 受到块级作用域的约束</span></span><br><span class=\"line\">\t<span class=\"comment\">// 每一次循环开始时都在新的块级作用域声明，保留其块级作用域中引用的值</span></span><br><span class=\"line\">\t<span class=\"comment\">// 输出 0 1 2 3 4</span></span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时使用<code>let</code>关键字声明的变量不能在同一个块级作用域中重复声明，这样会导致报语法错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> time;</span><br><span class=\"line\"><span class=\"keyword\">let</span> time; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;time&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age; <span class=\"comment\">// Uncaught SyntaxError: Identifier &#x27;age&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Joe&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;Roselyn&#x27;</span></span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Roselyn</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name) <span class=\"comment\">// Joe</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当使用<code>let</code>关键字在全局作用域声明变量时也不会污染全局对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 浏览器环境下</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">a</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"暂时性死区（temporal-dead-zone，简称-TDZ）\"><a href=\"#暂时性死区（temporal-dead-zone，简称-TDZ）\" class=\"headerlink\" title=\"暂时性死区（temporal dead zone，简称 TDZ）\"></a>暂时性死区（temporal dead zone，简称 TDZ）</h2><p>使用<code>let</code>声明的变量不会被提升到当前作用域的顶部，直到它们的定义被执行时才可以访问。在<code>let</code>变量声明之前的部分被称为暂时性死区，在暂时性死区中引用<code>let</code>变量会报引用错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp) <span class=\"comment\">// Uncaught ReferenceError: temp is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> temp = <span class=\"string\">&#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>typeof</code>访问暂时性死区中的let变量也会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c <span class=\"comment\">// Uncaught ReferenceError: c is not defined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b</span><br><span class=\"line\"><span class=\"keyword\">let</span> c</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h1><p>与<code>let</code>相似，<code>const</code>的作用范围是块级作用域，也存在暂时性死区。使用<code>const</code>关键字可声明常量，需要注意的是，常量在声明的同时必须进行初始化，而且初始化完成后不能改变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 即使是相等的值也不行</span></span><br><span class=\"line\">a = <span class=\"number\">2</span> <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b <span class=\"comment\">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>\n\n<p>不能改变并不是指该变量指向的值不能改变，而是变量指向的那个内存地址所保存的数据不得改动，对于<strong>原始类型</strong>来说，变量指向的那个内存地址所保存的就是对应的值，而<strong>引用类型</strong>变量指向的内存地址，保存的是指向实际数据的地址，<code>const</code>只能保证它保存的地址是不变的，而实际的数据则无法控制（关于原始类型和引用类型的内容之后会讲）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 向对象中添加属性</span></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">24</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;ikura&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试改变指向的地址</span></span><br><span class=\"line\">person = &#123;&#125; <span class=\"comment\">// Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常见面试题\"><a href=\"#常见面试题\" class=\"headerlink\" title=\"常见面试题\"></a>常见面试题</h1><ol>\n<li>代码输出结果（变量提升） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHi</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Jerry&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> age = <span class=\"number\">82</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">sayHi</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量声明） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> day = <span class=\"number\">13</span></span><br><span class=\"line\">dya = <span class=\"number\">14</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dya)</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果(变量作用范围) <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量作用范围） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">13</span>; </span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun</span>(<span class=\"params\"></span>)&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">10</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"title function_\">fun</span>(); </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量提升） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br></pre></td></tr></table></figure>\n</li>\n<li>代码输出结果（变量提升） <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> temp = <span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(temp)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之数据类型 —— string","date":"2022-05-05T11:20:53.000Z","updated":"2022-05-06T02:22:04.764Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# string\n\n在JavaScript中字符串必须被括号包裹，括号包括`''`、`\"\"`、````。其中````为ES6中引入的符号，又被称为模板字符串。\n\n```js\ntypeof 'hello' === 'string'\ntypeof \"true\" === 'string'\ntypeof '' === 'string'\ntypeof `aa` === 'string'\n```\n\n## 单引与双引\n\n单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符`\\n`来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如`\\\\`、`\\'`等。\n\n```js\nlet str = 'hello\n\t\tworld' // Uncaught SyntaxError: Invalid or unexpected token\nstr = '\\\\aa'\nconsole.log(str) // \\aa\n```\n\n在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。\n\n```js\nconst str1 = 'Love\\'s not Time\\'s fool, though rosy lips and cheeks' + \n\t\t\t\t\t\t 'within his bending sickle\\'s compass come;' + \n\t\t\t\t\t\t 'Love alters not with his brief hours and weeks,' +\n\t\t\t\t\t\t 'But bears it out even to the edge of doom.'\n\nconst str2 = 'In faith I do not love thee with mine eyes,\\\nFor they in thee a thousand errors note;'\n```\n\n## 模板字符串\n\n在ES6引入的模板字符串可以视作增强版的字符串，用` `` `包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以`${...}`嵌入JavaScript表达式或变量。\n\n```js\nconst name = 'Tim';\nlet str = `hello, ${name}`\nconsole.log(str) // hello, Tim\n\nconst template\n```\n\n## 不可变值\n\n需要注意的是，string属于原始类型，其值不可变。\n\n```js\nlet str = 'hello';\nconsole.log(str) // hello\n// 可以用str.length来访问字符串的长度\n// 用str[pos]的方式来获取第pos个字符\nstr[0] = 'aaaa' // 无效赋值\nconsole.log(str) // hello\n```\n\n## 常用方法\n\n### str.indexOf(subStr[, pos])\n\n该方法指的是从`str`的`pos`位置开始查找`subStr`，如果能够找到，则返回`subStr`第一次出现的位置；如果未能找到，则返回`-1`。其中第二个参数为可选参数，如果不写的话默认从`0`开始，如果`pos`小于`0`也会从`0`开始查找，大于`str.length`的话会直接返回`-1`。\n\n```js\nlet str = 'hello world'\nconsole.log(str.indexOf('world', 2)) // 6\nconsole.log(str.indexOf('a')) // -1\nconsole.log(str.indexOf('hello', 1)) // -1\nconsole.log(str.indexOf('h', 20)) // -1\n```\n\n另外存在一个现象，当`subStr`的值为`''`时，如果第二个参数`pos`的值在`0`到`str.length`的范围内时，返回值为`pos`，小于`0`返回`0`，大于`str.length`返回`str.length`。\n\n```js\nlet str = 'test'\nconsole.log(str.indexOf('', -2)) // 0\nconsole.log(str.indexOf('', 3)) // 3\nconsole.log(str.indexOf('', 8)) // 4\n```\n\n### str.lastIndexOf(substr[, pos])\n\n与`indexOf`方法类似，只不过该方法查找的是最后一次`substr`出现的位置，同时是从`pos`开始从后往前查找。\n\n```js\n// pos只限制待匹配字符串的开头\nconsole.log('ababab'.lastIndexOf('ab',2)) // 2\n```\n\n### str.charAt(pos)\n\n该方法会返回`str`中位置为`pos`的字符。如果`pos`的值超出了`0`到`str.length-1`的范围则会返回`''`。如果未传入`pos`的话，则默认`pos`为`0`。\n\n```js\nconsole.log('Snow Falling on Cedars'.charAt(5)) // F\n```\n\n### str.substring(start[, end])\n\n该方法在str中截取从`start`的位置到`end`的位置（不包含`end`）的字符。其中第二个参数为可选参数，未传入的话将截取从`start`到`str.length-1`的字符。\n\n如果`start`的值大于`end`，则截取的字符串为从`end`至`start`（不包含`start`）。\n\n其中任一参数的值小于`0`或大于`str.length`的话，会被当作`0`或者`str.length`处理。任一参数的值为`NaN`（包括隐式转换后为`NaN`）的话也会被当作`0`处理。\n\n```js\nlet str = 'The Snows of Kilimanjaro'\n\nconsole.log(str.substring(3,0)) // The\nconsole.log(str.substring({},3)) // The\nconsole.log(str.substring(-2,25)) // The Snows of Kilimanjaro\n```\n\n> MDN文档中提到`substr`方法在将来有可能被移除掉，因为`substring`方法功能类似，所以尽量使用`substring`方法去替代它。\n> \n\n### str.toUpperCase()\n\n### str.toLowerCase()\n\n这两个方法顾名思义，将字符串转换为大写/小写。\n\n```js\nlet str = 'abCdEfG'\nconsole.log(str.toUpperCase()) // ABCDEFG\nconsole.log(str.toLowerCase()) // abcdefg\n```\n\n### str.includes(substr[, pos])\n\n该方法是ES6新加的方法，用来判断`substr`是否包含在`str`中，是的话返回`true`，否则返回`false`。其中`pos`为可选参数，指的是开始查找的位置，未传入的话从`0`开始。\n\n```js\nlet str = 'Kagome To Inuyasha'\nconsole.log(str.includes('Kikyo')) // false\n```\n\n### str.startsWith(substr[, pos])\n\n### str.endsWith(substr[,pos])\n\n这两个也是ES6新加的方法，顾名思义，判断`str`是否以`substr`开头/结尾，是的话返回`true`，否则返回`false`。可选参数`includes`方法中的可选参数是同样的作用，但要注意在`endsWith`中查找的方式与`lastIndexOf`一致。\n\n```js\nlet str = 'We Made a Beautiful Bouquet'\nconsole.log(str.startsWith('We')) // true\nconsole.log(str.endsWith('auti', str.length-10)) // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/js-again-primitive-type-string.md","raw":"---\ntitle: 再学 JS 之数据类型 —— string\ndate: 2022-05-05 19:20:53\nupdated:\ntags: JavaScript\ncategories: 前端\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# string\n\n在JavaScript中字符串必须被括号包裹，括号包括`''`、`\"\"`、````。其中````为ES6中引入的符号，又被称为模板字符串。\n\n```js\ntypeof 'hello' === 'string'\ntypeof \"true\" === 'string'\ntypeof '' === 'string'\ntypeof `aa` === 'string'\n```\n\n## 单引与双引\n\n单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符`\\n`来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如`\\\\`、`\\'`等。\n\n```js\nlet str = 'hello\n\t\tworld' // Uncaught SyntaxError: Invalid or unexpected token\nstr = '\\\\aa'\nconsole.log(str) // \\aa\n```\n\n在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。\n\n```js\nconst str1 = 'Love\\'s not Time\\'s fool, though rosy lips and cheeks' + \n\t\t\t\t\t\t 'within his bending sickle\\'s compass come;' + \n\t\t\t\t\t\t 'Love alters not with his brief hours and weeks,' +\n\t\t\t\t\t\t 'But bears it out even to the edge of doom.'\n\nconst str2 = 'In faith I do not love thee with mine eyes,\\\nFor they in thee a thousand errors note;'\n```\n\n## 模板字符串\n\n在ES6引入的模板字符串可以视作增强版的字符串，用` `` `包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以`${...}`嵌入JavaScript表达式或变量。\n\n```js\nconst name = 'Tim';\nlet str = `hello, ${name}`\nconsole.log(str) // hello, Tim\n\nconst template\n```\n\n## 不可变值\n\n需要注意的是，string属于原始类型，其值不可变。\n\n```js\nlet str = 'hello';\nconsole.log(str) // hello\n// 可以用str.length来访问字符串的长度\n// 用str[pos]的方式来获取第pos个字符\nstr[0] = 'aaaa' // 无效赋值\nconsole.log(str) // hello\n```\n\n## 常用方法\n\n### str.indexOf(subStr[, pos])\n\n该方法指的是从`str`的`pos`位置开始查找`subStr`，如果能够找到，则返回`subStr`第一次出现的位置；如果未能找到，则返回`-1`。其中第二个参数为可选参数，如果不写的话默认从`0`开始，如果`pos`小于`0`也会从`0`开始查找，大于`str.length`的话会直接返回`-1`。\n\n```js\nlet str = 'hello world'\nconsole.log(str.indexOf('world', 2)) // 6\nconsole.log(str.indexOf('a')) // -1\nconsole.log(str.indexOf('hello', 1)) // -1\nconsole.log(str.indexOf('h', 20)) // -1\n```\n\n另外存在一个现象，当`subStr`的值为`''`时，如果第二个参数`pos`的值在`0`到`str.length`的范围内时，返回值为`pos`，小于`0`返回`0`，大于`str.length`返回`str.length`。\n\n```js\nlet str = 'test'\nconsole.log(str.indexOf('', -2)) // 0\nconsole.log(str.indexOf('', 3)) // 3\nconsole.log(str.indexOf('', 8)) // 4\n```\n\n### str.lastIndexOf(substr[, pos])\n\n与`indexOf`方法类似，只不过该方法查找的是最后一次`substr`出现的位置，同时是从`pos`开始从后往前查找。\n\n```js\n// pos只限制待匹配字符串的开头\nconsole.log('ababab'.lastIndexOf('ab',2)) // 2\n```\n\n### str.charAt(pos)\n\n该方法会返回`str`中位置为`pos`的字符。如果`pos`的值超出了`0`到`str.length-1`的范围则会返回`''`。如果未传入`pos`的话，则默认`pos`为`0`。\n\n```js\nconsole.log('Snow Falling on Cedars'.charAt(5)) // F\n```\n\n### str.substring(start[, end])\n\n该方法在str中截取从`start`的位置到`end`的位置（不包含`end`）的字符。其中第二个参数为可选参数，未传入的话将截取从`start`到`str.length-1`的字符。\n\n如果`start`的值大于`end`，则截取的字符串为从`end`至`start`（不包含`start`）。\n\n其中任一参数的值小于`0`或大于`str.length`的话，会被当作`0`或者`str.length`处理。任一参数的值为`NaN`（包括隐式转换后为`NaN`）的话也会被当作`0`处理。\n\n```js\nlet str = 'The Snows of Kilimanjaro'\n\nconsole.log(str.substring(3,0)) // The\nconsole.log(str.substring({},3)) // The\nconsole.log(str.substring(-2,25)) // The Snows of Kilimanjaro\n```\n\n> MDN文档中提到`substr`方法在将来有可能被移除掉，因为`substring`方法功能类似，所以尽量使用`substring`方法去替代它。\n> \n\n### str.toUpperCase()\n\n### str.toLowerCase()\n\n这两个方法顾名思义，将字符串转换为大写/小写。\n\n```js\nlet str = 'abCdEfG'\nconsole.log(str.toUpperCase()) // ABCDEFG\nconsole.log(str.toLowerCase()) // abcdefg\n```\n\n### str.includes(substr[, pos])\n\n该方法是ES6新加的方法，用来判断`substr`是否包含在`str`中，是的话返回`true`，否则返回`false`。其中`pos`为可选参数，指的是开始查找的位置，未传入的话从`0`开始。\n\n```js\nlet str = 'Kagome To Inuyasha'\nconsole.log(str.includes('Kikyo')) // false\n```\n\n### str.startsWith(substr[, pos])\n\n### str.endsWith(substr[,pos])\n\n这两个也是ES6新加的方法，顾名思义，判断`str`是否以`substr`开头/结尾，是的话返回`true`，否则返回`false`。可选参数`includes`方法中的可选参数是同样的作用，但要注意在`endsWith`中查找的方式与`lastIndexOf`一致。\n\n```js\nlet str = 'We Made a Beautiful Bouquet'\nconsole.log(str.startsWith('We')) // true\nconsole.log(str.endsWith('auti', str.length-10)) // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n****[现代 JavaScript 教程](https://zh.javascript.info/)****\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"js-again-primitive-type-string","published":1,"_id":"cl2sx3i0200087yo92x8h0nl0","layout":"post","photos":[],"link":"","content":"<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>在JavaScript中字符串必须被括号包裹，括号包括<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>。其中</code>为ES6中引入的符号，又被称为模板字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;hello&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;true&quot;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">`aa`</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单引与双引\"><a href=\"#单引与双引\" class=\"headerlink\" title=\"单引与双引\"></a>单引与双引</h2><p>单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符<code>\\n</code>来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如<code>\\\\</code>、<code>\\&#39;</code>等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello</span></span><br><span class=\"line\"><span class=\"string\">\t\tworld&#x27;</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\">str = <span class=\"string\">&#x27;\\\\aa&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// \\aa</span></span><br></pre></td></tr></table></figure>\n\n<p>在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str1 = <span class=\"string\">&#x27;Love\\&#x27;s not Time\\&#x27;s fool, though rosy lips and cheeks&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;within his bending sickle\\&#x27;s compass come;&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;Love alters not with his brief hours and weeks,&#x27;</span> +</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;But bears it out even to the edge of doom.&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> str2 = <span class=\"string\">&#x27;In faith I do not love thee with mine eyes,\\</span></span><br><span class=\"line\"><span class=\"string\">For they in thee a thousand errors note;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>在ES6引入的模板字符串可以视作增强版的字符串，用<code>``</code>包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以<code>$&#123;...&#125;</code>嵌入JavaScript表达式或变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;Tim&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">`hello, <span class=\"subst\">$&#123;name&#125;</span>`</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello, Tim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> template</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不可变值\"><a href=\"#不可变值\" class=\"headerlink\" title=\"不可变值\"></a>不可变值</h2><p>需要注意的是，string属于原始类型，其值不可变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// 可以用str.length来访问字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 用str[pos]的方式来获取第pos个字符</span></span><br><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"comment\">// 无效赋值</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"str-indexOf-subStr-pos\"><a href=\"#str-indexOf-subStr-pos\" class=\"headerlink\" title=\"str.indexOf(subStr[, pos])\"></a>str.indexOf(subStr[, pos])</h3><p>该方法指的是从<code>str</code>的<code>pos</code>位置开始查找<code>subStr</code>，如果能够找到，则返回<code>subStr</code>第一次出现的位置；如果未能找到，则返回<code>-1</code>。其中第二个参数为可选参数，如果不写的话默认从<code>0</code>开始，如果<code>pos</code>小于<code>0</code>也会从<code>0</code>开始查找，大于<code>str.length</code>的话会直接返回<code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;world&#x27;</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;a&#x27;</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"number\">20</span>)) <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>另外存在一个现象，当<code>subStr</code>的值为<code>&#39;&#39;</code>时，如果第二个参数<code>pos</code>的值在<code>0</code>到<code>str.length</code>的范围内时，返回值为<code>pos</code>，小于<code>0</code>返回<code>0</code>，大于<code>str.length</code>返回<code>str.length</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;test&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, -<span class=\"number\">2</span>)) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>)) <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-lastIndexOf-substr-pos\"><a href=\"#str-lastIndexOf-substr-pos\" class=\"headerlink\" title=\"str.lastIndexOf(substr[, pos])\"></a>str.lastIndexOf(substr[, pos])</h3><p>与<code>indexOf</code>方法类似，只不过该方法查找的是最后一次<code>substr</code>出现的位置，同时是从<code>pos</code>开始从后往前查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pos只限制待匹配字符串的开头</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ababab&#x27;</span>.<span class=\"title function_\">lastIndexOf</span>(<span class=\"string\">&#x27;ab&#x27;</span>,<span class=\"number\">2</span>)) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-charAt-pos\"><a href=\"#str-charAt-pos\" class=\"headerlink\" title=\"str.charAt(pos)\"></a>str.charAt(pos)</h3><p>该方法会返回<code>str</code>中位置为<code>pos</code>的字符。如果<code>pos</code>的值超出了<code>0</code>到<code>str.length-1</code>的范围则会返回<code>&#39;&#39;</code>。如果未传入<code>pos</code>的话，则默认<code>pos</code>为<code>0</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Snow Falling on Cedars&#x27;</span>.<span class=\"title function_\">charAt</span>(<span class=\"number\">5</span>)) <span class=\"comment\">// F</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-substring-start-end\"><a href=\"#str-substring-start-end\" class=\"headerlink\" title=\"str.substring(start[, end])\"></a>str.substring(start[, end])</h3><p>该方法在str中截取从<code>start</code>的位置到<code>end</code>的位置（不包含<code>end</code>）的字符。其中第二个参数为可选参数，未传入的话将截取从<code>start</code>到<code>str.length-1</code>的字符。</p>\n<p>如果<code>start</code>的值大于<code>end</code>，则截取的字符串为从<code>end</code>至<code>start</code>（不包含<code>start</code>）。</p>\n<p>其中任一参数的值小于<code>0</code>或大于<code>str.length</code>的话，会被当作<code>0</code>或者<code>str.length</code>处理。任一参数的值为<code>NaN</code>（包括隐式转换后为<code>NaN</code>）的话也会被当作<code>0</code>处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;The Snows of Kilimanjaro&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(<span class=\"number\">3</span>,<span class=\"number\">0</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(&#123;&#125;,<span class=\"number\">3</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(-<span class=\"number\">2</span>,<span class=\"number\">25</span>)) <span class=\"comment\">// The Snows of Kilimanjaro</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MDN文档中提到<code>substr</code>方法在将来有可能被移除掉，因为<code>substring</code>方法功能类似，所以尽量使用<code>substring</code>方法去替代它。</p>\n</blockquote>\n<h3 id=\"str-toUpperCase\"><a href=\"#str-toUpperCase\" class=\"headerlink\" title=\"str.toUpperCase()\"></a>str.toUpperCase()</h3><h3 id=\"str-toLowerCase\"><a href=\"#str-toLowerCase\" class=\"headerlink\" title=\"str.toLowerCase()\"></a>str.toLowerCase()</h3><p>这两个方法顾名思义，将字符串转换为大写/小写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abCdEfG&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toUpperCase</span>()) <span class=\"comment\">// ABCDEFG</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toLowerCase</span>()) <span class=\"comment\">// abcdefg</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-includes-substr-pos\"><a href=\"#str-includes-substr-pos\" class=\"headerlink\" title=\"str.includes(substr[, pos])\"></a>str.includes(substr[, pos])</h3><p>该方法是ES6新加的方法，用来判断<code>substr</code>是否包含在<code>str</code>中，是的话返回<code>true</code>，否则返回<code>false</code>。其中<code>pos</code>为可选参数，指的是开始查找的位置，未传入的话从<code>0</code>开始。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Kagome To Inuyasha&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">includes</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-startsWith-substr-pos\"><a href=\"#str-startsWith-substr-pos\" class=\"headerlink\" title=\"str.startsWith(substr[, pos])\"></a>str.startsWith(substr[, pos])</h3><h3 id=\"str-endsWith-substr-pos\"><a href=\"#str-endsWith-substr-pos\" class=\"headerlink\" title=\"str.endsWith(substr[,pos])\"></a>str.endsWith(substr[,pos])</h3><p>这两个也是ES6新加的方法，顾名思义，判断<code>str</code>是否以<code>substr</code>开头/结尾，是的话返回<code>true</code>，否则返回<code>false</code>。可选参数<code>includes</code>方法中的可选参数是同样的作用，但要注意在<code>endsWith</code>中查找的方式与<code>lastIndexOf</code>一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;We Made a Beautiful Bouquet&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;We&#x27;</span>)) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">endsWith</span>(<span class=\"string\">&#x27;auti&#x27;</span>, str.<span class=\"property\">length</span>-<span class=\"number\">10</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>在JavaScript中字符串必须被括号包裹，括号包括<code>&#39;&#39;</code>、<code>&quot;&quot;</code>、<code>。其中</code>为ES6中引入的符号，又被称为模板字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;hello&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;true&quot;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;&#x27;</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">`aa`</span> === <span class=\"string\">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单引与双引\"><a href=\"#单引与双引\" class=\"headerlink\" title=\"单引与双引\"></a>单引与双引</h2><p>单引号和双引号的作用一样，但是要前后保持一致，不能混用。另外单引号和双引号都不允许字符串跨行，但是可以使用换行符<code>\\n</code>来实现换行，与其他语言一样，可以通过转义字符\\来表示特殊字符，如<code>\\\\</code>、<code>\\&#39;</code>等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello</span></span><br><span class=\"line\"><span class=\"string\">\t\tworld&#x27;</span> <span class=\"comment\">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class=\"line\">str = <span class=\"string\">&#x27;\\\\aa&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// \\aa</span></span><br></pre></td></tr></table></figure>\n\n<p>在表示长字符串时，一行可能表示不下，可以使用+运算符来连接多个字符串，或者在每一行字符串的末尾使用\\来表示下一行继续。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str1 = <span class=\"string\">&#x27;Love\\&#x27;s not Time\\&#x27;s fool, though rosy lips and cheeks&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;within his bending sickle\\&#x27;s compass come;&#x27;</span> + </span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;Love alters not with his brief hours and weeks,&#x27;</span> +</span><br><span class=\"line\">\t\t\t\t\t\t <span class=\"string\">&#x27;But bears it out even to the edge of doom.&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> str2 = <span class=\"string\">&#x27;In faith I do not love thee with mine eyes,\\</span></span><br><span class=\"line\"><span class=\"string\">For they in thee a thousand errors note;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>在ES6引入的模板字符串可以视作增强版的字符串，用<code>``</code>包裹。比起普通的字符串，它可以直接定义跨行字符串，而且可以直接在字符串中以<code>$&#123;...&#125;</code>嵌入JavaScript表达式或变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">&#x27;Tim&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">`hello, <span class=\"subst\">$&#123;name&#125;</span>`</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello, Tim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> template</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不可变值\"><a href=\"#不可变值\" class=\"headerlink\" title=\"不可变值\"></a>不可变值</h2><p>需要注意的是，string属于原始类型，其值不可变。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// 可以用str.length来访问字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 用str[pos]的方式来获取第pos个字符</span></span><br><span class=\"line\">str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;aaaa&#x27;</span> <span class=\"comment\">// 无效赋值</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str) <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"str-indexOf-subStr-pos\"><a href=\"#str-indexOf-subStr-pos\" class=\"headerlink\" title=\"str.indexOf(subStr[, pos])\"></a>str.indexOf(subStr[, pos])</h3><p>该方法指的是从<code>str</code>的<code>pos</code>位置开始查找<code>subStr</code>，如果能够找到，则返回<code>subStr</code>第一次出现的位置；如果未能找到，则返回<code>-1</code>。其中第二个参数为可选参数，如果不写的话默认从<code>0</code>开始，如果<code>pos</code>小于<code>0</code>也会从<code>0</code>开始查找，大于<code>str.length</code>的话会直接返回<code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;world&#x27;</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;a&#x27;</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">1</span>)) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"number\">20</span>)) <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>另外存在一个现象，当<code>subStr</code>的值为<code>&#39;&#39;</code>时，如果第二个参数<code>pos</code>的值在<code>0</code>到<code>str.length</code>的范围内时，返回值为<code>pos</code>，小于<code>0</code>返回<code>0</code>，大于<code>str.length</code>返回<code>str.length</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;test&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, -<span class=\"number\">2</span>)) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;&#x27;</span>, <span class=\"number\">8</span>)) <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-lastIndexOf-substr-pos\"><a href=\"#str-lastIndexOf-substr-pos\" class=\"headerlink\" title=\"str.lastIndexOf(substr[, pos])\"></a>str.lastIndexOf(substr[, pos])</h3><p>与<code>indexOf</code>方法类似，只不过该方法查找的是最后一次<code>substr</code>出现的位置，同时是从<code>pos</code>开始从后往前查找。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pos只限制待匹配字符串的开头</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ababab&#x27;</span>.<span class=\"title function_\">lastIndexOf</span>(<span class=\"string\">&#x27;ab&#x27;</span>,<span class=\"number\">2</span>)) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-charAt-pos\"><a href=\"#str-charAt-pos\" class=\"headerlink\" title=\"str.charAt(pos)\"></a>str.charAt(pos)</h3><p>该方法会返回<code>str</code>中位置为<code>pos</code>的字符。如果<code>pos</code>的值超出了<code>0</code>到<code>str.length-1</code>的范围则会返回<code>&#39;&#39;</code>。如果未传入<code>pos</code>的话，则默认<code>pos</code>为<code>0</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Snow Falling on Cedars&#x27;</span>.<span class=\"title function_\">charAt</span>(<span class=\"number\">5</span>)) <span class=\"comment\">// F</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-substring-start-end\"><a href=\"#str-substring-start-end\" class=\"headerlink\" title=\"str.substring(start[, end])\"></a>str.substring(start[, end])</h3><p>该方法在str中截取从<code>start</code>的位置到<code>end</code>的位置（不包含<code>end</code>）的字符。其中第二个参数为可选参数，未传入的话将截取从<code>start</code>到<code>str.length-1</code>的字符。</p>\n<p>如果<code>start</code>的值大于<code>end</code>，则截取的字符串为从<code>end</code>至<code>start</code>（不包含<code>start</code>）。</p>\n<p>其中任一参数的值小于<code>0</code>或大于<code>str.length</code>的话，会被当作<code>0</code>或者<code>str.length</code>处理。任一参数的值为<code>NaN</code>（包括隐式转换后为<code>NaN</code>）的话也会被当作<code>0</code>处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;The Snows of Kilimanjaro&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(<span class=\"number\">3</span>,<span class=\"number\">0</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(&#123;&#125;,<span class=\"number\">3</span>)) <span class=\"comment\">// The</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">substring</span>(-<span class=\"number\">2</span>,<span class=\"number\">25</span>)) <span class=\"comment\">// The Snows of Kilimanjaro</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MDN文档中提到<code>substr</code>方法在将来有可能被移除掉，因为<code>substring</code>方法功能类似，所以尽量使用<code>substring</code>方法去替代它。</p>\n</blockquote>\n<h3 id=\"str-toUpperCase\"><a href=\"#str-toUpperCase\" class=\"headerlink\" title=\"str.toUpperCase()\"></a>str.toUpperCase()</h3><h3 id=\"str-toLowerCase\"><a href=\"#str-toLowerCase\" class=\"headerlink\" title=\"str.toLowerCase()\"></a>str.toLowerCase()</h3><p>这两个方法顾名思义，将字符串转换为大写/小写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abCdEfG&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toUpperCase</span>()) <span class=\"comment\">// ABCDEFG</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">toLowerCase</span>()) <span class=\"comment\">// abcdefg</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-includes-substr-pos\"><a href=\"#str-includes-substr-pos\" class=\"headerlink\" title=\"str.includes(substr[, pos])\"></a>str.includes(substr[, pos])</h3><p>该方法是ES6新加的方法，用来判断<code>substr</code>是否包含在<code>str</code>中，是的话返回<code>true</code>，否则返回<code>false</code>。其中<code>pos</code>为可选参数，指的是开始查找的位置，未传入的话从<code>0</code>开始。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;Kagome To Inuyasha&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">includes</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"str-startsWith-substr-pos\"><a href=\"#str-startsWith-substr-pos\" class=\"headerlink\" title=\"str.startsWith(substr[, pos])\"></a>str.startsWith(substr[, pos])</h3><h3 id=\"str-endsWith-substr-pos\"><a href=\"#str-endsWith-substr-pos\" class=\"headerlink\" title=\"str.endsWith(substr[,pos])\"></a>str.endsWith(substr[,pos])</h3><p>这两个也是ES6新加的方法，顾名思义，判断<code>str</code>是否以<code>substr</code>开头/结尾，是的话返回<code>true</code>，否则返回<code>false</code>。可选参数<code>includes</code>方法中的可选参数是同样的作用，但要注意在<code>endsWith</code>中查找的方式与<code>lastIndexOf</code>一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;We Made a Beautiful Bouquet&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;We&#x27;</span>)) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str.<span class=\"title function_\">endsWith</span>(<span class=\"string\">&#x27;auti&#x27;</span>, str.<span class=\"property\">length</span>-<span class=\"number\">10</span>)) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之数据类型 —— boolean、undefined、null","date":"2022-05-05T11:35:21.000Z","updated":"2022-05-06T02:22:02.179Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# boolean\n\n原始类型中的`boolean`类型仅有两个值：`true`和`false`，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。\n\n```jsx\ntypeof true === 'boolean' // true\n\n// 逻辑运算符的使用与隐式类型转换\ntypeof !'false' === 'boolean' // true\n```\n\n## 有关boolean类型转换\n\n### 显式类型转换\n\n可以使用之前提到过的对象包装器`Boolean`将其他类型的值进行显示地转换为boolean的值，或者使用双重非（`!!`）。\n\n```jsx\nconst bool1 = !!{x:100} // 将对象显式转换为boolean值\nconst bool2 = Boolean('Yui') // 将字符串显式转换为boolean值\n// 使用new关键字时创建的是一个对象，而不是类型转换\nconst boolObj = new Boolean(false)\n\ntypeof bool1 // 'boolean'\ntypeof bool2 // 'boolean'\ntypeof boolObj // 'object'\n```\n\n### 隐式类型转换\n\n类型转换指的是将其他类型的值转换为`boolean`的值时所采用的规则。如在使用`Boolean`转换其他类型的值时，未传入参数或者参数值为`0`、`null`、`undefined`、`NaN`、`''`时转换后的布尔值为`false`。\n\n因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。\n\n```jsx\n// 一个涉及对象的隐式类型转换的例子\n[] == ![] // true\n```\n\n隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。\n# undefined\n\n原始类型中的`undefined`只包含一个值：`undefined`，意为未被赋值。当使用`var`、`let`关键字声明变量而赋值时，变量的值就为`undefined`，同时也可以显示地给变量赋值为`undefined`（不建议这样做）。\n\n```jsx\ntypeof undefined // 'undefined'\n\nlet undefinedX\ntypeof undefinedX // 'undefined'\n```\n\n# null\n\nnull同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。\n\n```jsx\ntypeof null // 'object'\n```\n\n虽然`null`是原始类型的值，但是在这里却被“错误”地判断为`object`，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为`0`的话就会被认为是`object`，而`null`的二进制表示全为`0`，故被错误地识别为`object`。\n\n## undefined 与 null 的区别\n\n从逻辑上讲，`null`处于主动，需要使用时必须显式地赋值；`undefined`处于被动，当使用者忘记赋值时系统会默认赋值为`undefined`，如函数没有返回值时会默认返回`undefined`、调用函数未传入应该提供的参数时参数默认值为`undefined`等。\n\n另外需要注意的是`undefined`在进行类型转换时与`null`的区别。\n\n```jsx\n// 涉及隐式类型转换\n// 关系运算符与相等运算符的规则不同\n// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑\nundefined == null // true\n10 + null // 10\n10 + undefined // NaN\n\nnull > 0  // null会被转换为0， 结果为false\nnull == 0 // null在此处不会进行类型转换 结果为false\n\nNumber(null) // 0\nNumber(undefined) // NaN\n\n// 使用全等运算符判断结果为false\n// 关于全等运算符与相等运算符的差别后面会讲\nundefined === null // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/js-again-primitive-type-boolean-undefined-null.md","raw":"---\ntitle: 再学 JS 之数据类型 —— boolean、undefined、null\ndate: 2022-05-05 19:35:21\nupdated:\ntags: JavaScript\ncategories: 前端\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# boolean\n\n原始类型中的`boolean`类型仅有两个值：`true`和`false`，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。\n\n```jsx\ntypeof true === 'boolean' // true\n\n// 逻辑运算符的使用与隐式类型转换\ntypeof !'false' === 'boolean' // true\n```\n\n## 有关boolean类型转换\n\n### 显式类型转换\n\n可以使用之前提到过的对象包装器`Boolean`将其他类型的值进行显示地转换为boolean的值，或者使用双重非（`!!`）。\n\n```jsx\nconst bool1 = !!{x:100} // 将对象显式转换为boolean值\nconst bool2 = Boolean('Yui') // 将字符串显式转换为boolean值\n// 使用new关键字时创建的是一个对象，而不是类型转换\nconst boolObj = new Boolean(false)\n\ntypeof bool1 // 'boolean'\ntypeof bool2 // 'boolean'\ntypeof boolObj // 'object'\n```\n\n### 隐式类型转换\n\n类型转换指的是将其他类型的值转换为`boolean`的值时所采用的规则。如在使用`Boolean`转换其他类型的值时，未传入参数或者参数值为`0`、`null`、`undefined`、`NaN`、`''`时转换后的布尔值为`false`。\n\n因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。\n\n```jsx\n// 一个涉及对象的隐式类型转换的例子\n[] == ![] // true\n```\n\n隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。\n# undefined\n\n原始类型中的`undefined`只包含一个值：`undefined`，意为未被赋值。当使用`var`、`let`关键字声明变量而赋值时，变量的值就为`undefined`，同时也可以显示地给变量赋值为`undefined`（不建议这样做）。\n\n```jsx\ntypeof undefined // 'undefined'\n\nlet undefinedX\ntypeof undefinedX // 'undefined'\n```\n\n# null\n\nnull同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。\n\n```jsx\ntypeof null // 'object'\n```\n\n虽然`null`是原始类型的值，但是在这里却被“错误”地判断为`object`，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为`0`的话就会被认为是`object`，而`null`的二进制表示全为`0`，故被错误地识别为`object`。\n\n## undefined 与 null 的区别\n\n从逻辑上讲，`null`处于主动，需要使用时必须显式地赋值；`undefined`处于被动，当使用者忘记赋值时系统会默认赋值为`undefined`，如函数没有返回值时会默认返回`undefined`、调用函数未传入应该提供的参数时参数默认值为`undefined`等。\n\n另外需要注意的是`undefined`在进行类型转换时与`null`的区别。\n\n```jsx\n// 涉及隐式类型转换\n// 关系运算符与相等运算符的规则不同\n// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑\nundefined == null // true\n10 + null // 10\n10 + undefined // NaN\n\nnull > 0  // null会被转换为0， 结果为false\nnull == 0 // null在此处不会进行类型转换 结果为false\n\nNumber(null) // 0\nNumber(undefined) // NaN\n\n// 使用全等运算符判断结果为false\n// 关于全等运算符与相等运算符的差别后面会讲\nundefined === null // false\n```\n\n# 参考资料\n\n**JavaScirpt高级程序设计（第4版）**\n\n**你不知道的JavaScript**\n\n**ECMAScript 6 入门**\n\n**[现代 JavaScript 教程](https://zh.javascript.info/)**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"js-again-primitive-type-boolean-undefined-null","published":1,"_id":"cl2sxm33l0000e1o91ut83y7z","layout":"post","photos":[],"link":"","content":"<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>原始类型中的<code>boolean</code>类型仅有两个值：<code>true</code>和<code>false</code>，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 逻辑运算符的使用与隐式类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> !<span class=\"string\">&#x27;false&#x27;</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有关boolean类型转换\"><a href=\"#有关boolean类型转换\" class=\"headerlink\" title=\"有关boolean类型转换\"></a>有关boolean类型转换</h2><h3 id=\"显式类型转换\"><a href=\"#显式类型转换\" class=\"headerlink\" title=\"显式类型转换\"></a>显式类型转换</h3><p>可以使用之前提到过的对象包装器<code>Boolean</code>将其他类型的值进行显示地转换为boolean的值，或者使用双重非（<code>!!</code>）。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bool1 = !!&#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125; <span class=\"comment\">// 将对象显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bool2 = <span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;Yui&#x27;</span>) <span class=\"comment\">// 将字符串显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"comment\">// 使用new关键字时创建的是一个对象，而不是类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> boolObj = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool1 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool2 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> boolObj <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>类型转换指的是将其他类型的值转换为<code>boolean</code>的值时所采用的规则。如在使用<code>Boolean</code>转换其他类型的值时，未传入参数或者参数值为<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>&#39;&#39;</code>时转换后的布尔值为<code>false</code>。</p>\n<p>因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个涉及对象的隐式类型转换的例子</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>原始类型中的<code>undefined</code>只包含一个值：<code>undefined</code>，意为未被赋值。当使用<code>var</code>、<code>let</code>关键字声明变量而赋值时，变量的值就为<code>undefined</code>，同时也可以显示地给变量赋值为<code>undefined</code>（不建议这样做）。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> undefinedX</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undefinedX <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>null同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然<code>null</code>是原始类型的值，但是在这里却被“错误”地判断为<code>object</code>，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为<code>0</code>的话就会被认为是<code>object</code>，而<code>null</code>的二进制表示全为<code>0</code>，故被错误地识别为<code>object</code>。</p>\n<h2 id=\"undefined-与-null-的区别\"><a href=\"#undefined-与-null-的区别\" class=\"headerlink\" title=\"undefined 与 null 的区别\"></a>undefined 与 null 的区别</h2><p>从逻辑上讲，<code>null</code>处于主动，需要使用时必须显式地赋值；<code>undefined</code>处于被动，当使用者忘记赋值时系统会默认赋值为<code>undefined</code>，如函数没有返回值时会默认返回<code>undefined</code>、调用函数未传入应该提供的参数时参数默认值为<code>undefined</code>等。</p>\n<p>另外需要注意的是<code>undefined</code>在进行类型转换时与<code>null</code>的区别。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 涉及隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// 关系运算符与相等运算符的规则不同</span></span><br><span class=\"line\"><span class=\"comment\">// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> &gt; <span class=\"number\">0</span>  <span class=\"comment\">// null会被转换为0， 结果为false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// null在此处不会进行类型转换 结果为false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用全等运算符判断结果为false</span></span><br><span class=\"line\"><span class=\"comment\">// 关于全等运算符与相等运算符的差别后面会讲</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>原始类型中的<code>boolean</code>类型仅有两个值：<code>true</code>和<code>false</code>，即真与假。通常使用布尔类型的值来进行一些逻辑判断，需要注意的是其中常常会存在类型转换和逻辑运算符的使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 逻辑运算符的使用与隐式类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> !<span class=\"string\">&#x27;false&#x27;</span> === <span class=\"string\">&#x27;boolean&#x27;</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"有关boolean类型转换\"><a href=\"#有关boolean类型转换\" class=\"headerlink\" title=\"有关boolean类型转换\"></a>有关boolean类型转换</h2><h3 id=\"显式类型转换\"><a href=\"#显式类型转换\" class=\"headerlink\" title=\"显式类型转换\"></a>显式类型转换</h3><p>可以使用之前提到过的对象包装器<code>Boolean</code>将其他类型的值进行显示地转换为boolean的值，或者使用双重非（<code>!!</code>）。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bool1 = !!&#123;<span class=\"attr\">x</span>:<span class=\"number\">100</span>&#125; <span class=\"comment\">// 将对象显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bool2 = <span class=\"title class_\">Boolean</span>(<span class=\"string\">&#x27;Yui&#x27;</span>) <span class=\"comment\">// 将字符串显式转换为boolean值</span></span><br><span class=\"line\"><span class=\"comment\">// 使用new关键字时创建的是一个对象，而不是类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> boolObj = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool1 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> bool2 <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> boolObj <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h3><p>类型转换指的是将其他类型的值转换为<code>boolean</code>的值时所采用的规则。如在使用<code>Boolean</code>转换其他类型的值时，未传入参数或者参数值为<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>&#39;&#39;</code>时转换后的布尔值为<code>false</code>。</p>\n<p>因为对象的类型转换规则比较复杂，详细的规则会在之后讲到。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个涉及对象的隐式类型转换的例子</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>隐式类型转换指的是在某些情况下会自动地将非布尔类型的值转换为布尔类型的值。</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>原始类型中的<code>undefined</code>只包含一个值：<code>undefined</code>，意为未被赋值。当使用<code>var</code>、<code>let</code>关键字声明变量而赋值时，变量的值就为<code>undefined</code>，同时也可以显示地给变量赋值为<code>undefined</code>（不建议这样做）。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> undefinedX</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undefinedX <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>null同样也只包含一个值：null，意为空值。需要注意的是使用typeof判断null的类型时会与期待的结果有所不同。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然<code>null</code>是原始类型的值，但是在这里却被“错误”地判断为<code>object</code>，这实际上是远古时期JavaScript就存在的一个bug，却一直没有得到修复，具体原因是JavaScript中，不同的对象在底层的表示都为二进制，二进制表示前三位为都为<code>0</code>的话就会被认为是<code>object</code>，而<code>null</code>的二进制表示全为<code>0</code>，故被错误地识别为<code>object</code>。</p>\n<h2 id=\"undefined-与-null-的区别\"><a href=\"#undefined-与-null-的区别\" class=\"headerlink\" title=\"undefined 与 null 的区别\"></a>undefined 与 null 的区别</h2><p>从逻辑上讲，<code>null</code>处于主动，需要使用时必须显式地赋值；<code>undefined</code>处于被动，当使用者忘记赋值时系统会默认赋值为<code>undefined</code>，如函数没有返回值时会默认返回<code>undefined</code>、调用函数未传入应该提供的参数时参数默认值为<code>undefined</code>等。</p>\n<p>另外需要注意的是<code>undefined</code>在进行类型转换时与<code>null</code>的区别。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 涉及隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// 关系运算符与相等运算符的规则不同</span></span><br><span class=\"line\"><span class=\"comment\">// 在设计上关系运算符总会将运算元尝试转换为number，而相等运算符则没有这方面的考虑</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"number\">10</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">null</span> &gt; <span class=\"number\">0</span>  <span class=\"comment\">// null会被转换为0， 结果为false</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// null在此处不会进行类型转换 结果为false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用全等运算符判断结果为false</span></span><br><span class=\"line\"><span class=\"comment\">// 关于全等运算符与相等运算符的差别后面会讲</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> === <span class=\"literal\">null</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>JavaScirpt高级程序设计（第4版）</strong></p>\n<p><strong>你不知道的JavaScript</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a></strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"},{"title":"再学 JS 之数据类型 —— bigint、symbol","date":"2022-05-06T02:20:04.000Z","updated":"2022-05-06T02:22:00.378Z","keywords":null,"description":null,"top_img":null,"comments":1,"cover":"https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# bigInt 与 symbol\n\n# bigInt\n\n在一个整数字面量后面加 `n` 的方式定义一个 `bigInt`的变量，或者通过调用函数`BigInt()`创建（不需要使用`new`关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。\n\n> `bigInt`类型不能和`number`类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用`+value`的形式来将`bigInt`类型的值转换为`number`类型，需使用`Number()`方法显式地进行转换；`BigInt`类型的值在转换为`number`类型的值时可能会丢失精度，建议在值可能大于`2^53`的情况下再使用 `bigInt`类型；同时`bigInt`类型的值不能使用`Math`对象的方法。\n> \n\n```jsx\ntypeof 4n === 'bigint'\ntypeof BigInt(3) === 'bigint'\n// 与number类型的值可进行比较\n\n// 宽松相等 严格不相等\n3n == 3 // true\n3n === 3 // false\n\n2 > 1n // true\n3.0 <= 3n // true\n\n// BigInt类型的值进行小数运算时会取整\n3n/2n === 1n // true\n\n+3n // Uncaught TypeError: Cannot convert a BigInt value to a number\n\nMath.ceil(5n/2n) // Uncaught TypeError: Cannot convert a BigInt value to a number\n```\n\n# symbol\n\n`symbol`类型只能通过调用`Symbol()`函数（不需要使用`new`关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。\n\n```jsx\ntypeof Symbol() === 'symbol'\n```\n\n`Symbol`函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于`symbol`类型的值是独一无二的，所以就算是传入相同的字符串的`symbol`也不相等。\n\n```jsx\nconst s1 = Symbol('foo')\nconst s2 = Symbol('foo')\n\nconsole.log(s1) // Symbol(foo)\n\ns1 == s2 // false\ns1 === s2 // false\n```\n\n## 内置的Symbol\n\nES6除了引入`symbol`这一基本类型以外，还提供了11个内置的`symbol`值，它们在语言内部使用，用于暴露语言内部的行为。比如`for...of`循环要求被循环的对象实现了`Symbol.iterator`这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。\n\n```jsx\n// 以下代码为使用 Symbol.iterator 来实现指针结构\n\nclass Node {\n  value;\n  next;\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n  [Symbol.iterator]() {\n    let iterator = { next: next };\n    let current = this;\n    function next() {\n      if (current) {\n        const value = current.value;\n        current = current.next;\n        return {\n          done: false,\n          value: value,\n        };\n      } else {\n        return {\n          done: true,\n        };\n      }\n    }\n    return iterator;\n  }\n}\n\nlet one = new Node(1);\nlet two = new Node(2);\nlet three = new Node(3);\n\none.next = two;\ntwo.next = three;\n\nfor (const n of one) {\n  console.log(n);\n}\n// 1 2 3\n```\n\n## 常用方法\n\n### Symbol.for(key)\n\n该方法会根据传入的`key`，在运行时的`全局symbol注册表`中去查找是否存在已经登记了相同`key`值的`symbol`，如果存在，则返回该`symbol`；反之则创建一个新的`symbol`，并将其登记到`全局symbol注册表`中去。这也是该方法与`Symbol`方法的区别，直接使用`Symbol`方法创建`symbol`类型的值不会被放到`全局symbol注册表`中。\n\n```jsx\nconst s1 = Symbol.for('foo')\nconst s2 = Symbol.for('foo')\n\ns1 === s2 // true\n```\n\n### Symbol.keyFor(symbol)\n\n该方法需要传入一个`symbol`类型的参数，然后会根据传入的参数在`全局symbol注册表`中查找与该参数相关联的`key`值，并返回`key`值；如果没有找到，则返回`undefined`。\n\n```jsx\nlet sym = Symbol();\nSymbol.keyFor(sym) // undefined\n\nsym = Symbol.for('foo')\nSymbol.keyFor(sym) // 'foo'\n```\n\n## symbol的实际应用\n\n### 消除魔法字符串\n\n魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。\n\n```jsx\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\nexport const REACT_PORTAL_TYPE = hasSymbol\n  ? Symbol.for('react.portal')\n  : 0xeaca;\nexport const REACT_FRAGMENT_TYPE = hasSymbol\n  ? Symbol.for('react.fragment')\n  : 0xeacb;\nexport const REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.strict_mode')\n  : 0xeacc;\nexport const REACT_PROFILER_TYPE = hasSymbol\n  ? Symbol.for('react.profiler')\n  : 0xead2;\nexport const REACT_PROVIDER_TYPE = hasSymbol\n  ? Symbol.for('react.provider')\n  : 0xeacd;\nexport const REACT_CONTEXT_TYPE = hasSymbol\n  ? Symbol.for('react.context')\n  : 0xeace;\nexport const REACT_CONCURRENT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.concurrent_mode')\n  : 0xeacf;\nexport const REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for('react.forward_ref')\n  : 0xead0;\nexport const REACT_SUSPENSE_TYPE = hasSymbol\n  ? Symbol.for('react.suspense')\n  : 0xead1;\nexport const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nexport const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n```\n\n### 隐藏属性\n\n这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且`symbol`类型的属性不会参与`for...in`、`for...of`等循环，但需要注意，可以通过`Object.getOwnPropertySymbols()`方法获取指定对象的所有 Symbol 属性名。","source":"_posts/js-again-primitive-type-bigint-symbol.md","raw":"---\ntitle: 再学 JS 之数据类型 —— bigint、symbol\ndate: 2022-05-06 10:20:04\nupdated:\ntags: JavaScript\ncategories: 前端\nkeywords:\ndescription:\ntop_img:\ncomments:\ncover:\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n# bigInt 与 symbol\n\n# bigInt\n\n在一个整数字面量后面加 `n` 的方式定义一个 `bigInt`的变量，或者通过调用函数`BigInt()`创建（不需要使用`new`关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。\n\n> `bigInt`类型不能和`number`类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用`+value`的形式来将`bigInt`类型的值转换为`number`类型，需使用`Number()`方法显式地进行转换；`BigInt`类型的值在转换为`number`类型的值时可能会丢失精度，建议在值可能大于`2^53`的情况下再使用 `bigInt`类型；同时`bigInt`类型的值不能使用`Math`对象的方法。\n> \n\n```jsx\ntypeof 4n === 'bigint'\ntypeof BigInt(3) === 'bigint'\n// 与number类型的值可进行比较\n\n// 宽松相等 严格不相等\n3n == 3 // true\n3n === 3 // false\n\n2 > 1n // true\n3.0 <= 3n // true\n\n// BigInt类型的值进行小数运算时会取整\n3n/2n === 1n // true\n\n+3n // Uncaught TypeError: Cannot convert a BigInt value to a number\n\nMath.ceil(5n/2n) // Uncaught TypeError: Cannot convert a BigInt value to a number\n```\n\n# symbol\n\n`symbol`类型只能通过调用`Symbol()`函数（不需要使用`new`关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。\n\n```jsx\ntypeof Symbol() === 'symbol'\n```\n\n`Symbol`函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于`symbol`类型的值是独一无二的，所以就算是传入相同的字符串的`symbol`也不相等。\n\n```jsx\nconst s1 = Symbol('foo')\nconst s2 = Symbol('foo')\n\nconsole.log(s1) // Symbol(foo)\n\ns1 == s2 // false\ns1 === s2 // false\n```\n\n## 内置的Symbol\n\nES6除了引入`symbol`这一基本类型以外，还提供了11个内置的`symbol`值，它们在语言内部使用，用于暴露语言内部的行为。比如`for...of`循环要求被循环的对象实现了`Symbol.iterator`这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。\n\n```jsx\n// 以下代码为使用 Symbol.iterator 来实现指针结构\n\nclass Node {\n  value;\n  next;\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n  [Symbol.iterator]() {\n    let iterator = { next: next };\n    let current = this;\n    function next() {\n      if (current) {\n        const value = current.value;\n        current = current.next;\n        return {\n          done: false,\n          value: value,\n        };\n      } else {\n        return {\n          done: true,\n        };\n      }\n    }\n    return iterator;\n  }\n}\n\nlet one = new Node(1);\nlet two = new Node(2);\nlet three = new Node(3);\n\none.next = two;\ntwo.next = three;\n\nfor (const n of one) {\n  console.log(n);\n}\n// 1 2 3\n```\n\n## 常用方法\n\n### Symbol.for(key)\n\n该方法会根据传入的`key`，在运行时的`全局symbol注册表`中去查找是否存在已经登记了相同`key`值的`symbol`，如果存在，则返回该`symbol`；反之则创建一个新的`symbol`，并将其登记到`全局symbol注册表`中去。这也是该方法与`Symbol`方法的区别，直接使用`Symbol`方法创建`symbol`类型的值不会被放到`全局symbol注册表`中。\n\n```jsx\nconst s1 = Symbol.for('foo')\nconst s2 = Symbol.for('foo')\n\ns1 === s2 // true\n```\n\n### Symbol.keyFor(symbol)\n\n该方法需要传入一个`symbol`类型的参数，然后会根据传入的参数在`全局symbol注册表`中查找与该参数相关联的`key`值，并返回`key`值；如果没有找到，则返回`undefined`。\n\n```jsx\nlet sym = Symbol();\nSymbol.keyFor(sym) // undefined\n\nsym = Symbol.for('foo')\nSymbol.keyFor(sym) // 'foo'\n```\n\n## symbol的实际应用\n\n### 消除魔法字符串\n\n魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。\n\n```jsx\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\nexport const REACT_PORTAL_TYPE = hasSymbol\n  ? Symbol.for('react.portal')\n  : 0xeaca;\nexport const REACT_FRAGMENT_TYPE = hasSymbol\n  ? Symbol.for('react.fragment')\n  : 0xeacb;\nexport const REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.strict_mode')\n  : 0xeacc;\nexport const REACT_PROFILER_TYPE = hasSymbol\n  ? Symbol.for('react.profiler')\n  : 0xead2;\nexport const REACT_PROVIDER_TYPE = hasSymbol\n  ? Symbol.for('react.provider')\n  : 0xeacd;\nexport const REACT_CONTEXT_TYPE = hasSymbol\n  ? Symbol.for('react.context')\n  : 0xeace;\nexport const REACT_CONCURRENT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.concurrent_mode')\n  : 0xeacf;\nexport const REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for('react.forward_ref')\n  : 0xead0;\nexport const REACT_SUSPENSE_TYPE = hasSymbol\n  ? Symbol.for('react.suspense')\n  : 0xead1;\nexport const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nexport const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n```\n\n### 隐藏属性\n\n这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且`symbol`类型的属性不会参与`for...in`、`for...of`等循环，但需要注意，可以通过`Object.getOwnPropertySymbols()`方法获取指定对象的所有 Symbol 属性名。","slug":"js-again-primitive-type-bigint-symbol","published":1,"_id":"cl2tt7ugm00006ro938oq9huk","layout":"post","photos":[],"link":"","content":"<h1 id=\"bigInt-与-symbol\"><a href=\"#bigInt-与-symbol\" class=\"headerlink\" title=\"bigInt 与 symbol\"></a>bigInt 与 symbol</h1><h1 id=\"bigInt\"><a href=\"#bigInt\" class=\"headerlink\" title=\"bigInt\"></a>bigInt</h1><p>在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>bigInt</code>的变量，或者通过调用函数<code>BigInt()</code>创建（不需要使用<code>new</code>关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。</p>\n<blockquote>\n<p><code>bigInt</code>类型不能和<code>number</code>类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用<code>+value</code>的形式来将<code>bigInt</code>类型的值转换为<code>number</code>类型，需使用<code>Number()</code>方法显式地进行转换；<code>BigInt</code>类型的值在转换为<code>number</code>类型的值时可能会丢失精度，建议在值可能大于<code>2^53</code>的情况下再使用 <code>bigInt</code>类型；同时<code>bigInt</code>类型的值不能使用<code>Math</code>对象的方法。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">4n</span> === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">BigInt</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 与number类型的值可进行比较</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宽松相等 严格不相等</span></span><br><span class=\"line\"><span class=\"number\">3n</span> == <span class=\"number\">3</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3n</span> === <span class=\"number\">3</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span> &gt; <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3.0</span> &lt;= <span class=\"number\">3n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BigInt类型的值进行小数运算时会取整</span></span><br><span class=\"line\"><span class=\"number\">3n</span>/<span class=\"number\">2n</span> === <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"number\">3n</span> <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(<span class=\"number\">5n</span>/<span class=\"number\">2n</span>) <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p><code>symbol</code>类型只能通过调用<code>Symbol()</code>函数（不需要使用<code>new</code>关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>() === <span class=\"string\">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于<code>symbol</code>类型的值是独一无二的，所以就算是传入相同的字符串的<code>symbol</code>也不相等。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s1) <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1 == s2 <span class=\"comment\">// false</span></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内置的Symbol\"><a href=\"#内置的Symbol\" class=\"headerlink\" title=\"内置的Symbol\"></a>内置的Symbol</h2><p>ES6除了引入<code>symbol</code>这一基本类型以外，还提供了11个内置的<code>symbol</code>值，它们在语言内部使用，用于暴露语言内部的行为。比如<code>for...of</code>循环要求被循环的对象实现了<code>Symbol.iterator</code>这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下代码为使用 Symbol.iterator 来实现指针结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  value;</span><br><span class=\"line\">  next;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">next</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> iterator = &#123; <span class=\"attr\">next</span>: next &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> value = current.<span class=\"property\">value</span>;</span><br><span class=\"line\">        current = current.<span class=\"property\">next</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"attr\">value</span>: value,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> three = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">one.<span class=\"property\">next</span> = two;</span><br><span class=\"line\">two.<span class=\"property\">next</span> = three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> one) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"Symbol-for-key\"><a href=\"#Symbol-for-key\" class=\"headerlink\" title=\"Symbol.for(key)\"></a>Symbol.for(key)</h3><p>该方法会根据传入的<code>key</code>，在运行时的<code>全局symbol注册表</code>中去查找是否存在已经登记了相同<code>key</code>值的<code>symbol</code>，如果存在，则返回该<code>symbol</code>；反之则创建一个新的<code>symbol</code>，并将其登记到<code>全局symbol注册表</code>中去。这也是该方法与<code>Symbol</code>方法的区别，直接使用<code>Symbol</code>方法创建<code>symbol</code>类型的值不会被放到<code>全局symbol注册表</code>中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol-keyFor-symbol\"><a href=\"#Symbol-keyFor-symbol\" class=\"headerlink\" title=\"Symbol.keyFor(symbol)\"></a>Symbol.keyFor(symbol)</h3><p>该方法需要传入一个<code>symbol</code>类型的参数，然后会根据传入的参数在<code>全局symbol注册表</code>中查找与该参数相关联的<code>key</code>值，并返回<code>key</code>值；如果没有找到，则返回<code>undefined</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">sym = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"symbol的实际应用\"><a href=\"#symbol的实际应用\" class=\"headerlink\" title=\"symbol的实际应用\"></a>symbol的实际应用</h2><h3 id=\"消除魔法字符串\"><a href=\"#消除魔法字符串\" class=\"headerlink\" title=\"消除魔法字符串\"></a>消除魔法字符串</h3><p>魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span></span><br><span class=\"line\"><span class=\"comment\">// nor polyfill, then a plain number is used for performance.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasSymbol = <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; <span class=\"title class_\">Symbol</span>.<span class=\"property\">for</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.element&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeac7</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PORTAL_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.portal&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeaca</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FRAGMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.fragment&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacb</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_STRICT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.strict_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacc</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROFILER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.profiler&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead2</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROVIDER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.provider&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacd</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONTEXT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.context&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeace</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONCURRENT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.concurrent_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacf</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FORWARD_REF_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.forward_ref&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_SUSPENSE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.suspense&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_MEMO_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.memo&#x27;</span>) : <span class=\"number\">0xead3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_LAZY_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.lazy&#x27;</span>) : <span class=\"number\">0xead4</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏属性\"><a href=\"#隐藏属性\" class=\"headerlink\" title=\"隐藏属性\"></a>隐藏属性</h3><p>这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且<code>symbol</code>类型的属性不会参与<code>for...in</code>、<code>for...of</code>等循环，但需要注意，可以通过<code>Object.getOwnPropertySymbols()</code>方法获取指定对象的所有 Symbol 属性名。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"bigInt-与-symbol\"><a href=\"#bigInt-与-symbol\" class=\"headerlink\" title=\"bigInt 与 symbol\"></a>bigInt 与 symbol</h1><h1 id=\"bigInt\"><a href=\"#bigInt\" class=\"headerlink\" title=\"bigInt\"></a>bigInt</h1><p>在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>bigInt</code>的变量，或者通过调用函数<code>BigInt()</code>创建（不需要使用<code>new</code>关键字）。该类型一般用于数据过大时的精确运算中，业务场景有限，这里只做基本介绍。</p>\n<blockquote>\n<p><code>bigInt</code>类型不能和<code>number</code>类型的值进行混合运算，但可以转换为同一类型再进行运算；在进行类型转换时，不能像其他类型一样采用<code>+value</code>的形式来将<code>bigInt</code>类型的值转换为<code>number</code>类型，需使用<code>Number()</code>方法显式地进行转换；<code>BigInt</code>类型的值在转换为<code>number</code>类型的值时可能会丢失精度，建议在值可能大于<code>2^53</code>的情况下再使用 <code>bigInt</code>类型；同时<code>bigInt</code>类型的值不能使用<code>Math</code>对象的方法。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">4n</span> === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">BigInt</span>(<span class=\"number\">3</span>) === <span class=\"string\">&#x27;bigint&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 与number类型的值可进行比较</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宽松相等 严格不相等</span></span><br><span class=\"line\"><span class=\"number\">3n</span> == <span class=\"number\">3</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3n</span> === <span class=\"number\">3</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span> &gt; <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">3.0</span> &lt;= <span class=\"number\">3n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BigInt类型的值进行小数运算时会取整</span></span><br><span class=\"line\"><span class=\"number\">3n</span>/<span class=\"number\">2n</span> === <span class=\"number\">1n</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"number\">3n</span> <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(<span class=\"number\">5n</span>/<span class=\"number\">2n</span>) <span class=\"comment\">// Uncaught TypeError: Cannot convert a BigInt value to a number</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p><code>symbol</code>类型只能通过调用<code>Symbol()</code>函数（不需要使用<code>new</code>关键字）来创建。该类型在ES6中被引入，它能够保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>() === <span class=\"string\">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol</code>函数可以接收一个字符串作为参数，其作用是作为描述便于分辨。需要注意的是，由于<code>symbol</code>类型的值是独一无二的，所以就算是传入相同的字符串的<code>symbol</code>也不相等。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s1) <span class=\"comment\">// Symbol(foo)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1 == s2 <span class=\"comment\">// false</span></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内置的Symbol\"><a href=\"#内置的Symbol\" class=\"headerlink\" title=\"内置的Symbol\"></a>内置的Symbol</h2><p>ES6除了引入<code>symbol</code>这一基本类型以外，还提供了11个内置的<code>symbol</code>值，它们在语言内部使用，用于暴露语言内部的行为。比如<code>for...of</code>循环要求被循环的对象实现了<code>Symbol.iterator</code>这个接口，开发者可以通过这个属性自定义在遍历时的行为，在这里就不做过多的展开。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下代码为使用 Symbol.iterator 来实现指针结构</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  value;</span><br><span class=\"line\">  next;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">next</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> iterator = &#123; <span class=\"attr\">next</span>: next &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">next</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (current) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> value = current.<span class=\"property\">value</span>;</span><br><span class=\"line\">        current = current.<span class=\"property\">next</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          <span class=\"attr\">value</span>: value,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iterator;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> one = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> two = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> three = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">one.<span class=\"property\">next</span> = two;</span><br><span class=\"line\">two.<span class=\"property\">next</span> = three;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> n <span class=\"keyword\">of</span> one) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"Symbol-for-key\"><a href=\"#Symbol-for-key\" class=\"headerlink\" title=\"Symbol.for(key)\"></a>Symbol.for(key)</h3><p>该方法会根据传入的<code>key</code>，在运行时的<code>全局symbol注册表</code>中去查找是否存在已经登记了相同<code>key</code>值的<code>symbol</code>，如果存在，则返回该<code>symbol</code>；反之则创建一个新的<code>symbol</code>，并将其登记到<code>全局symbol注册表</code>中去。这也是该方法与<code>Symbol</code>方法的区别，直接使用<code>Symbol</code>方法创建<code>symbol</code>类型的值不会被放到<code>全局symbol注册表</code>中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol-keyFor-symbol\"><a href=\"#Symbol-keyFor-symbol\" class=\"headerlink\" title=\"Symbol.keyFor(symbol)\"></a>Symbol.keyFor(symbol)</h3><p>该方法需要传入一个<code>symbol</code>类型的参数，然后会根据传入的参数在<code>全局symbol注册表</code>中查找与该参数相关联的<code>key</code>值，并返回<code>key</code>值；如果没有找到，则返回<code>undefined</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">sym = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;foo&#x27;</span>)</span><br><span class=\"line\"><span class=\"title class_\">Symbol</span>.<span class=\"title function_\">keyFor</span>(sym) <span class=\"comment\">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"symbol的实际应用\"><a href=\"#symbol的实际应用\" class=\"headerlink\" title=\"symbol的实际应用\"></a>symbol的实际应用</h2><h3 id=\"消除魔法字符串\"><a href=\"#消除魔法字符串\" class=\"headerlink\" title=\"消除魔法字符串\"></a>消除魔法字符串</h3><p>魔法字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。如在团队开发中业务逻辑代码中直接使用字符串字面量就会使得代码难以维护。再如在React源码中，就有大量的symbol应用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span></span><br><span class=\"line\"><span class=\"comment\">// nor polyfill, then a plain number is used for performance.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hasSymbol = <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; <span class=\"title class_\">Symbol</span>.<span class=\"property\">for</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.element&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeac7</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PORTAL_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.portal&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeaca</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FRAGMENT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.fragment&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacb</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_STRICT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.strict_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacc</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROFILER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.profiler&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead2</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_PROVIDER_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.provider&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacd</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONTEXT_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.context&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeace</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_CONCURRENT_MODE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.concurrent_mode&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xeacf</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_FORWARD_REF_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.forward_ref&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_SUSPENSE_TYPE</span> = hasSymbol</span><br><span class=\"line\">  ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.suspense&#x27;</span>)</span><br><span class=\"line\">  : <span class=\"number\">0xead1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_MEMO_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.memo&#x27;</span>) : <span class=\"number\">0xead3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_LAZY_TYPE</span> = hasSymbol ? <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&#x27;react.lazy&#x27;</span>) : <span class=\"number\">0xead4</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐藏属性\"><a href=\"#隐藏属性\" class=\"headerlink\" title=\"隐藏属性\"></a>隐藏属性</h3><p>这样做的好处是可以有效地避免命名冲突问题，一般在开发需要给第三方使用的公共库时会用到这个技巧。而且<code>symbol</code>类型的属性不会参与<code>for...in</code>、<code>for...of</code>等循环，但需要注意，可以通过<code>Object.getOwnPropertySymbols()</code>方法获取指定对象的所有 Symbol 属性名。</p>\n"},{"title":"初见 RxJS","date":"2022-05-06T07:10:16.000Z","updated":"2022-05-06T07:24:08.488Z","keywords":null,"description":null,"top_img":null,"cover":"/img/rxjs-first-sight.jpeg","toc":null,"toc_number":null,"toc_style_simple":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"# 初识 RxJS\n\n# 写在前面\n\n刚入职了新公司，负责维护一个原来使用`Angular`构建的项目，奈何自己一直使用的是`React`。不过既来之，则安之。顺便插一句，熟悉`Vue`的朋友应该会觉得很亲切，其中很多语法如`v-if`、`v-bind`，与`Angualr`中的`ngIf`、`ngFor`的用法都如出一辙。\n\n看了两周左右的`Angular`，说一下第一印象，`Angular`确实是一个非常齐全的框架，它不像`Vue`跟`React`需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在`Angular`中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。\n其中`RxJS`就是`Anuglar`提供的异步编程方案。\n\n`RxJS`官网描述自己是`Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）`，也可以把`RxJS`当做处理异步行为的`Lodash`库`（Think of RxJS as Lodash for events）`。`RxJS`是编程范式函数式编程(`Functional Programming`)与响应式编程(`Reactive Programming`)的结合，换句话说，`RxJS`是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了`J.H. Blog`的`30天精通RxJS`系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。\n\n\n# 什么是Observable\n## Observer Pattern\n\n观察者模式在程序设计中并不少见，如`DOM`操作中的通过给`DOM`元素绑定相应的事件去监听该`DOM`元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的`Redux`的实现，其都是以观察者模式的思想为核心。\n\n```jsx\n// redux 的简单实现\nexport const createStore = (reducer) => {\n  // 公共状态\n  let currentState = {};\n  // 监听者队列\n  let listeners = [];\n  // getter\n  function getState() {\n    return currentState;\n  }\n  // setter\n  function dispatch(action) {\n    currentState = reducer(currentState, action);\n\t\t// 当dispatch触发，即状态更新时通知listeners\n    listeners.forEach((fn) => fn());\n  }\n  // 添加监听事件\n  function subscribe(fn) {\n    listeners.push(fn);\n  }\n  // 初始化store数据\n  dispatch({ type: \"@@REDUX_INIT\" });\n  return { getState, dispatch, subscribe };\n};\n```\n\n## Iterator Pattern\n\n`iterator`（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如`Array`、`Map`、`Set`、`String`等JS中内置的数据结构都实现了该接口。实现`iterator`接口的方法是为其添加`Symbol.iterator`属性，其中包含`next`方法，该方法返回的迭代器对象包含两个属性：`value`和`done`。`done`指的是遍历是否结束，`value`为下一次迭代的值，`done`为`true`时`value`一般为`undefined`。\n\n```jsx\nconst iterableExample = {\n\t[Symbol.iterator]: function() {\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: 'Sunday'，\n\t\t\t\t\tdone: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst arr = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\nconst iterator = arr[Symbol.iterator]()\niterator.next() // {value: 'Monday', done: false}\niterator.next() // {value: 'Tuesday', done: false}\niterator.next() // {value: 'Wednesday', done: false}\n```\n\n迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了`iterator`与`iterable`的概念。\n\n## Observable\n\n`Observable`结合了`Observer`与`Iterator`的思想，像`Observe`与`Iterator`一样以流的形式包装数据，同时能够以`Observe`的方式通知更新，以`Iterator`的方式去处理数据。这样说起来可能有点抽象，但是结合`Observable`实例就能很好地理解。\n\n# 创建 Observable\n\n创建`Observable`实例的基本方法,使用`Observable`构造函数来创建一个`Observable`实例对象，其中可以传入一个回调函数,接收一个`subscriber`，用来指定该如何处理数据。需要注意的是，`Observable`作为被观察的对象，需要使用`subscribe`方法来通知`subscriber`去对`Observable`作出处理。\n\n```jsx\nimport { Observable } from 'rxjs';\n\nlet observalbe1 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  subscriber.next('Nana');\n});\n\n// 使用subscrible方法来订阅Observable\nobservalbe1.subscribe(console.log);\n// Suda\n// Nana\n\n// 处理非同步行为\nlet observalbe2 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  setTimeout(() => {\n    subscriber.next('Kasumi');\n  }, 1000);\n  subscriber.next('Nana');\n});\n\nobservalbe2.subscribe(console.log);\n// Suda\n// Nana\n// Kasumi\n\n```\n\n订阅`Observable`的被称为观察者，观察者具有三种行为（方法）来处理`Observable`的数据：\n\n- `next`：当Observable发送新的值，即调用其中的next方法时，观察者的`next`方法就会被调用。\n- `complete`：在`Observable`中完成遍历即调用其中的`complete`方法时，观察者的`complete`方法会被调用，在此之后的`next`方法不会执行。\n- `error`：在`Observable`中出现错误时，观察者的`error`方法会被调用。\n\n```jsx\nlet observable3 = new Observable((subscriber) => {\n  subscriber.next('Inuyasha');\n  subscriber.next('Kikyo');\n  subscriber.complete();\n  subscriber.next('Kagome');\n});\n\n// 与Promise类似的处理方法\nlet observer = {\n  next: function (value) {\n    console.log(value);\n  },\n  error: function (error) {\n    console.log(error);\n  },\n  complete: function () {\n    console.log('complete');\n  },\n};\n\nobservable3.subscribe(observer);\n// Inuyasha\n// Kikyo\n// complete\n```\n\n需要注意的是，只传入一个函数时会被默认指定为`next`的回调函数。\n\n# 创建 Observable 实例的常用方法\n\n## of\n\n> `of<T>(...args: (SchedulerLike | T)[]): Observable<T>`\n> \n\n需要注意其参数与方法`Function.prototype.call`类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。\n\n![of.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec79fa46-8b7d-4e5c-bc52-99c29733f5c6/of.png)\n\n```jsx\nimport { of } from 'rxjs';\n\nconst source = of(1, 2, 3);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## from\n\n> `from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>`\n> \n\n该方法弥补了`of`方法不能直接传入数组等数据结构等缺陷，参数为`Array`、`类数组对象`、`Promise`、`可迭代对象`或`类 Observable 对象`\n\n```jsx\nimport { from } from 'rxjs';\n\nconst source = from([1, 2, 3]);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## interval\n\n> `interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n这个方法能够实现JS中`setInterval`的功能，需要注意第一个参数是以`ms`为单位的时间间隔。\n\n![图片来自rxjs官网](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/88a059b6-b771-4e22-a36d-2e4406d08b10/interval.png)\n\n```jsx\nimport { interval } from 'rxjs';\n\nconst numbers = interval(2000);\n// 以2秒的间隔从0开始在控制台输出数字\nnumbers.subscribe((n) => console.log(n));\n```\n\n## Timer\n\n> `timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n该方法与`Interval`类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。\n\n```jsx\nimport { timer } from 'rxjs';\n\n// 只传一个参数表示指需要调用一次\nconst source1 = timer(1000);\nsource1.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 0\n// complete\n\n// 第一次调用后会每隔1秒调用1次\nconst source2 = timer(2000, 1000);\nsource2.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 2秒之后开始输出 0 1 2 3 4 ...\n\n```\n\n## EMPTY, NEVER\n\n这两个`Observable`常量分别用来替代在以前版本的`empty`方法与`never`方法，前者会直接`complete`，后者不会被执行。\n\n```jsx\nimport { EMPTY, NEVER } from 'rxjs';\n\nEMPTY.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// complete\n\n// 不会被执行\nNEVER.subscribe(() => console.log('never be called'));\n```\n\n## throwError\n\n> `throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never>`\n> \n\n该方法会直接抛出异常，与`Promise.reject`方法类似。\n\n```jsx\nimport { throwError } from 'rxjs';\n\nthrowError(() => console.log('Ops!')).subscribe();\n```\n\n## **Subscription**\n\n在对`Observable`进行`subscribe`之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟`setTimeout`、`setInterval`等方法一样，需要我们在使用完后手动进行释放。\n\n```jsx\nimport { interval } from 'rxjs';\n\nconst source = interval(1000);\nconst subscriptipn = source.subscribe();\n\n// 使用完后手动释放\nsubscriptipn.unsubscribe();\n```\n\n# 参考资料\n\n**30天精通RxJS**\n\n**RxJS官方文档**\n\n**ECMAScript 6 入门**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","source":"_posts/rxjs-first-sight.md","raw":"---\ntitle: 初见 RxJS\ndate: 2022-05-06 15:10:16\nupdated:\ntags: \n  - JavaScript \n  - RxJS\ncategories: 前端\nkeywords:\ndescription:\ntop_img:\ncover: /img/rxjs-first-sight.jpeg\ntoc:\ntoc_number:\ntoc_style_simple:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n\n---\n# 初识 RxJS\n\n# 写在前面\n\n刚入职了新公司，负责维护一个原来使用`Angular`构建的项目，奈何自己一直使用的是`React`。不过既来之，则安之。顺便插一句，熟悉`Vue`的朋友应该会觉得很亲切，其中很多语法如`v-if`、`v-bind`，与`Angualr`中的`ngIf`、`ngFor`的用法都如出一辙。\n\n看了两周左右的`Angular`，说一下第一印象，`Angular`确实是一个非常齐全的框架，它不像`Vue`跟`React`需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在`Angular`中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。\n其中`RxJS`就是`Anuglar`提供的异步编程方案。\n\n`RxJS`官网描述自己是`Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）`，也可以把`RxJS`当做处理异步行为的`Lodash`库`（Think of RxJS as Lodash for events）`。`RxJS`是编程范式函数式编程(`Functional Programming`)与响应式编程(`Reactive Programming`)的结合，换句话说，`RxJS`是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了`J.H. Blog`的`30天精通RxJS`系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。\n\n\n# 什么是Observable\n## Observer Pattern\n\n观察者模式在程序设计中并不少见，如`DOM`操作中的通过给`DOM`元素绑定相应的事件去监听该`DOM`元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的`Redux`的实现，其都是以观察者模式的思想为核心。\n\n```jsx\n// redux 的简单实现\nexport const createStore = (reducer) => {\n  // 公共状态\n  let currentState = {};\n  // 监听者队列\n  let listeners = [];\n  // getter\n  function getState() {\n    return currentState;\n  }\n  // setter\n  function dispatch(action) {\n    currentState = reducer(currentState, action);\n\t\t// 当dispatch触发，即状态更新时通知listeners\n    listeners.forEach((fn) => fn());\n  }\n  // 添加监听事件\n  function subscribe(fn) {\n    listeners.push(fn);\n  }\n  // 初始化store数据\n  dispatch({ type: \"@@REDUX_INIT\" });\n  return { getState, dispatch, subscribe };\n};\n```\n\n## Iterator Pattern\n\n`iterator`（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如`Array`、`Map`、`Set`、`String`等JS中内置的数据结构都实现了该接口。实现`iterator`接口的方法是为其添加`Symbol.iterator`属性，其中包含`next`方法，该方法返回的迭代器对象包含两个属性：`value`和`done`。`done`指的是遍历是否结束，`value`为下一次迭代的值，`done`为`true`时`value`一般为`undefined`。\n\n```jsx\nconst iterableExample = {\n\t[Symbol.iterator]: function() {\n\t\treturn {\n\t\t\tnext: function() {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: 'Sunday'，\n\t\t\t\t\tdone: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst arr = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\nconst iterator = arr[Symbol.iterator]()\niterator.next() // {value: 'Monday', done: false}\niterator.next() // {value: 'Tuesday', done: false}\niterator.next() // {value: 'Wednesday', done: false}\n```\n\n迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了`iterator`与`iterable`的概念。\n\n## Observable\n\n`Observable`结合了`Observer`与`Iterator`的思想，像`Observe`与`Iterator`一样以流的形式包装数据，同时能够以`Observe`的方式通知更新，以`Iterator`的方式去处理数据。这样说起来可能有点抽象，但是结合`Observable`实例就能很好地理解。\n\n# 创建 Observable\n\n创建`Observable`实例的基本方法,使用`Observable`构造函数来创建一个`Observable`实例对象，其中可以传入一个回调函数,接收一个`subscriber`，用来指定该如何处理数据。需要注意的是，`Observable`作为被观察的对象，需要使用`subscribe`方法来通知`subscriber`去对`Observable`作出处理。\n\n```jsx\nimport { Observable } from 'rxjs';\n\nlet observalbe1 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  subscriber.next('Nana');\n});\n\n// 使用subscrible方法来订阅Observable\nobservalbe1.subscribe(console.log);\n// Suda\n// Nana\n\n// 处理非同步行为\nlet observalbe2 = new Observable((subscriber) => {\n  subscriber.next('Suda');\n  setTimeout(() => {\n    subscriber.next('Kasumi');\n  }, 1000);\n  subscriber.next('Nana');\n});\n\nobservalbe2.subscribe(console.log);\n// Suda\n// Nana\n// Kasumi\n\n```\n\n订阅`Observable`的被称为观察者，观察者具有三种行为（方法）来处理`Observable`的数据：\n\n- `next`：当Observable发送新的值，即调用其中的next方法时，观察者的`next`方法就会被调用。\n- `complete`：在`Observable`中完成遍历即调用其中的`complete`方法时，观察者的`complete`方法会被调用，在此之后的`next`方法不会执行。\n- `error`：在`Observable`中出现错误时，观察者的`error`方法会被调用。\n\n```jsx\nlet observable3 = new Observable((subscriber) => {\n  subscriber.next('Inuyasha');\n  subscriber.next('Kikyo');\n  subscriber.complete();\n  subscriber.next('Kagome');\n});\n\n// 与Promise类似的处理方法\nlet observer = {\n  next: function (value) {\n    console.log(value);\n  },\n  error: function (error) {\n    console.log(error);\n  },\n  complete: function () {\n    console.log('complete');\n  },\n};\n\nobservable3.subscribe(observer);\n// Inuyasha\n// Kikyo\n// complete\n```\n\n需要注意的是，只传入一个函数时会被默认指定为`next`的回调函数。\n\n# 创建 Observable 实例的常用方法\n\n## of\n\n> `of<T>(...args: (SchedulerLike | T)[]): Observable<T>`\n> \n\n需要注意其参数与方法`Function.prototype.call`类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。\n\n![of.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec79fa46-8b7d-4e5c-bc52-99c29733f5c6/of.png)\n\n```jsx\nimport { of } from 'rxjs';\n\nconst source = of(1, 2, 3);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## from\n\n> `from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>`\n> \n\n该方法弥补了`of`方法不能直接传入数组等数据结构等缺陷，参数为`Array`、`类数组对象`、`Promise`、`可迭代对象`或`类 Observable 对象`\n\n```jsx\nimport { from } from 'rxjs';\n\nconst source = from([1, 2, 3]);\nsource.subscribe({\n  next: (value) => {\n    console.log(value);\n  },\n});\n```\n\n## interval\n\n> `interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n这个方法能够实现JS中`setInterval`的功能，需要注意第一个参数是以`ms`为单位的时间间隔。\n\n![图片来自rxjs官网](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/88a059b6-b771-4e22-a36d-2e4406d08b10/interval.png)\n\n```jsx\nimport { interval } from 'rxjs';\n\nconst numbers = interval(2000);\n// 以2秒的间隔从0开始在控制台输出数字\nnumbers.subscribe((n) => console.log(n));\n```\n\n## Timer\n\n> `timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable<number>`\n> \n\n该方法与`Interval`类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。\n\n```jsx\nimport { timer } from 'rxjs';\n\n// 只传一个参数表示指需要调用一次\nconst source1 = timer(1000);\nsource1.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 0\n// complete\n\n// 第一次调用后会每隔1秒调用1次\nconst source2 = timer(2000, 1000);\nsource2.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// 2秒之后开始输出 0 1 2 3 4 ...\n\n```\n\n## EMPTY, NEVER\n\n这两个`Observable`常量分别用来替代在以前版本的`empty`方法与`never`方法，前者会直接`complete`，后者不会被执行。\n\n```jsx\nimport { EMPTY, NEVER } from 'rxjs';\n\nEMPTY.subscribe({\n  next: (value) => console.log(value),\n  complete: () => console.log('complete'),\n  error: (error) => console.log(error),\n});\n// complete\n\n// 不会被执行\nNEVER.subscribe(() => console.log('never be called'));\n```\n\n## throwError\n\n> `throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never>`\n> \n\n该方法会直接抛出异常，与`Promise.reject`方法类似。\n\n```jsx\nimport { throwError } from 'rxjs';\n\nthrowError(() => console.log('Ops!')).subscribe();\n```\n\n## **Subscription**\n\n在对`Observable`进行`subscribe`之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟`setTimeout`、`setInterval`等方法一样，需要我们在使用完后手动进行释放。\n\n```jsx\nimport { interval } from 'rxjs';\n\nconst source = interval(1000);\nconst subscriptipn = source.subscribe();\n\n// 使用完后手动释放\nsubscriptipn.unsubscribe();\n```\n\n# 参考资料\n\n**30天精通RxJS**\n\n**RxJS官方文档**\n\n**ECMAScript 6 入门**\n\n**[MDN Web Docs](https://developer.mozilla.org/zh-CN/)**","slug":"rxjs-first-sight","published":1,"_id":"cl2u3l1gl0001nvo9hrsa3sp9","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"初识-RxJS\"><a href=\"#初识-RxJS\" class=\"headerlink\" title=\"初识 RxJS\"></a>初识 RxJS</h1><h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>刚入职了新公司，负责维护一个原来使用<code>Angular</code>构建的项目，奈何自己一直使用的是<code>React</code>。不过既来之，则安之。顺便插一句，熟悉<code>Vue</code>的朋友应该会觉得很亲切，其中很多语法如<code>v-if</code>、<code>v-bind</code>，与<code>Angualr</code>中的<code>ngIf</code>、<code>ngFor</code>的用法都如出一辙。</p>\n<p>看了两周左右的<code>Angular</code>，说一下第一印象，<code>Angular</code>确实是一个非常齐全的框架，它不像<code>Vue</code>跟<code>React</code>需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在<code>Angular</code>中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。<br>其中<code>RxJS</code>就是<code>Anuglar</code>提供的异步编程方案。</p>\n<p><code>RxJS</code>官网描述自己是<code>Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）</code>，也可以把<code>RxJS</code>当做处理异步行为的<code>Lodash</code>库<code>（Think of RxJS as Lodash for events）</code>。<code>RxJS</code>是编程范式函数式编程(<code>Functional Programming</code>)与响应式编程(<code>Reactive Programming</code>)的结合，换句话说，<code>RxJS</code>是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了<code>J.H. Blog</code>的<code>30天精通RxJS</code>系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。</p>\n<h1 id=\"什么是Observable\"><a href=\"#什么是Observable\" class=\"headerlink\" title=\"什么是Observable\"></a>什么是Observable</h1><h2 id=\"Observer-Pattern\"><a href=\"#Observer-Pattern\" class=\"headerlink\" title=\"Observer Pattern\"></a>Observer Pattern</h2><p>观察者模式在程序设计中并不少见，如<code>DOM</code>操作中的通过给<code>DOM</code>元素绑定相应的事件去监听该<code>DOM</code>元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的<code>Redux</code>的实现，其都是以观察者模式的思想为核心。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux 的简单实现</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createStore</span> = (<span class=\"params\">reducer</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 公共状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 监听者队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> listeners = [];</span><br><span class=\"line\">  <span class=\"comment\">// getter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">getState</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// setter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dispatch</span>(<span class=\"params\">action</span>) &#123;</span><br><span class=\"line\">    currentState = <span class=\"title function_\">reducer</span>(currentState, action);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当dispatch触发，即状态更新时通知listeners</span></span><br><span class=\"line\">    listeners.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> <span class=\"title function_\">fn</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加监听事件</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">subscribe</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    listeners.<span class=\"title function_\">push</span>(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化store数据</span></span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;@@REDUX_INIT&quot;</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Iterator-Pattern\"><a href=\"#Iterator-Pattern\" class=\"headerlink\" title=\"Iterator Pattern\"></a>Iterator Pattern</h2><p><code>iterator</code>（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>等JS中内置的数据结构都实现了该接口。实现<code>iterator</code>接口的方法是为其添加<code>Symbol.iterator</code>属性，其中包含<code>next</code>方法，该方法返回的迭代器对象包含两个属性：<code>value</code>和<code>done</code>。<code>done</code>指的是遍历是否结束，<code>value</code>为下一次迭代的值，<code>done</code>为<code>true</code>时<code>value</code>一般为<code>undefined</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iterableExample = &#123;</span><br><span class=\"line\">\t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">next</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">value</span>: <span class=\"string\">&#x27;Sunday&#x27;</span>，</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">done</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">&#x27;Monday&#x27;</span>, <span class=\"string\">&#x27;Tuesday&#x27;</span>, <span class=\"string\">&#x27;Wednesday&#x27;</span>, <span class=\"string\">&#x27;Thursday&#x27;</span>, <span class=\"string\">&#x27;Friday&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> iterator = arr[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]()</span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Monday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Tuesday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Wednesday&#x27;, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了<code>iterator</code>与<code>iterable</code>的概念。</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p><code>Observable</code>结合了<code>Observer</code>与<code>Iterator</code>的思想，像<code>Observe</code>与<code>Iterator</code>一样以流的形式包装数据，同时能够以<code>Observe</code>的方式通知更新，以<code>Iterator</code>的方式去处理数据。这样说起来可能有点抽象，但是结合<code>Observable</code>实例就能很好地理解。</p>\n<h1 id=\"创建-Observable\"><a href=\"#创建-Observable\" class=\"headerlink\" title=\"创建 Observable\"></a>创建 Observable</h1><p>创建<code>Observable</code>实例的基本方法,使用<code>Observable</code>构造函数来创建一个<code>Observable</code>实例对象，其中可以传入一个回调函数,接收一个<code>subscriber</code>，用来指定该如何处理数据。需要注意的是，<code>Observable</code>作为被观察的对象，需要使用<code>subscribe</code>方法来通知<code>subscriber</code>去对<code>Observable</code>作出处理。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用subscrible方法来订阅Observable</span></span><br><span class=\"line\">observalbe1.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理非同步行为</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kasumi&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observalbe2.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"><span class=\"comment\">// Kasumi</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>订阅<code>Observable</code>的被称为观察者，观察者具有三种行为（方法）来处理<code>Observable</code>的数据：</p>\n<ul>\n<li><code>next</code>：当Observable发送新的值，即调用其中的next方法时，观察者的<code>next</code>方法就会被调用。</li>\n<li><code>complete</code>：在<code>Observable</code>中完成遍历即调用其中的<code>complete</code>方法时，观察者的<code>complete</code>方法会被调用，在此之后的<code>next</code>方法不会执行。</li>\n<li><code>error</code>：在<code>Observable</code>中出现错误时，观察者的<code>error</code>方法会被调用。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> observable3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Inuyasha&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">complete</span>();</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kagome&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与Promise类似的处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = &#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">observable3.<span class=\"title function_\">subscribe</span>(observer);</span><br><span class=\"line\"><span class=\"comment\">// Inuyasha</span></span><br><span class=\"line\"><span class=\"comment\">// Kikyo</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，只传入一个函数时会被默认指定为<code>next</code>的回调函数。</p>\n<h1 id=\"创建-Observable-实例的常用方法\"><a href=\"#创建-Observable-实例的常用方法\" class=\"headerlink\" title=\"创建 Observable 实例的常用方法\"></a>创建 Observable 实例的常用方法</h1><h2 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h2><blockquote>\n<p><code>of&lt;T&gt;(...args: (SchedulerLike | T)[]): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>需要注意其参数与方法<code>Function.prototype.call</code>类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec79fa46-8b7d-4e5c-bc52-99c29733f5c6/of.png\" alt=\"of.png\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">of</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"from\"><a href=\"#from\" class=\"headerlink\" title=\"from\"></a>from</h2><blockquote>\n<p><code>from&lt;T&gt;(input: ObservableInput&lt;T&gt;, scheduler?: SchedulerLike): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>该方法弥补了<code>of</code>方法不能直接传入数组等数据结构等缺陷，参数为<code>Array</code>、<code>类数组对象</code>、<code>Promise</code>、<code>可迭代对象</code>或<code>类 Observable 对象</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">from</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"interval\"><a href=\"#interval\" class=\"headerlink\" title=\"interval\"></a>interval</h2><blockquote>\n<p><code>interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>这个方法能够实现JS中<code>setInterval</code>的功能，需要注意第一个参数是以<code>ms</code>为单位的时间间隔。</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/88a059b6-b771-4e22-a36d-2e4406d08b10/interval.png\" alt=\"图片来自rxjs官网\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = <span class=\"title function_\">interval</span>(<span class=\"number\">2000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 以2秒的间隔从0开始在控制台输出数字</span></span><br><span class=\"line\">numbers.<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h2><blockquote>\n<p><code>timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>该方法与<code>Interval</code>类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; timer &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只传一个参数表示指需要调用一次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = <span class=\"title function_\">timer</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">source1.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一次调用后会每隔1秒调用1次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = <span class=\"title function_\">timer</span>(<span class=\"number\">2000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">source2.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 2秒之后开始输出 0 1 2 3 4 ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EMPTY-NEVER\"><a href=\"#EMPTY-NEVER\" class=\"headerlink\" title=\"EMPTY, NEVER\"></a>EMPTY, NEVER</h2><p>这两个<code>Observable</code>常量分别用来替代在以前版本的<code>empty</code>方法与<code>never</code>方法，前者会直接<code>complete</code>，后者不会被执行。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"variable constant_\">EMPTY</span>, <span class=\"variable constant_\">NEVER</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">EMPTY</span>.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不会被执行</span></span><br><span class=\"line\"><span class=\"variable constant_\">NEVER</span>.<span class=\"title function_\">subscribe</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;never be called&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"throwError\"><a href=\"#throwError\" class=\"headerlink\" title=\"throwError\"></a>throwError</h2><blockquote>\n<p><code>throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable&lt;never&gt;</code></p>\n</blockquote>\n<p>该方法会直接抛出异常，与<code>Promise.reject</code>方法类似。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; throwError &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">throwError</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Ops!&#x27;</span>)).<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a><strong>Subscription</strong></h2><p>在对<code>Observable</code>进行<code>subscribe</code>之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟<code>setTimeout</code>、<code>setInterval</code>等方法一样，需要我们在使用完后手动进行释放。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">interval</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> subscriptipn = source.<span class=\"title function_\">subscribe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用完后手动释放</span></span><br><span class=\"line\">subscriptipn.<span class=\"title function_\">unsubscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>30天精通RxJS</strong></p>\n<p><strong>RxJS官方文档</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"初识-RxJS\"><a href=\"#初识-RxJS\" class=\"headerlink\" title=\"初识 RxJS\"></a>初识 RxJS</h1><h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>刚入职了新公司，负责维护一个原来使用<code>Angular</code>构建的项目，奈何自己一直使用的是<code>React</code>。不过既来之，则安之。顺便插一句，熟悉<code>Vue</code>的朋友应该会觉得很亲切，其中很多语法如<code>v-if</code>、<code>v-bind</code>，与<code>Angualr</code>中的<code>ngIf</code>、<code>ngFor</code>的用法都如出一辙。</p>\n<p>看了两周左右的<code>Angular</code>，说一下第一印象，<code>Angular</code>确实是一个非常齐全的框架，它不像<code>Vue</code>跟<code>React</code>需要自己去考虑其他东西，如状态管理方案、网路请求方案等，而在<code>Angular</code>中就不需要考虑这些，它已经替你做好了选择，开发者只需要学会它里面的那一套东西，然后专注于业务开发即可。<br>其中<code>RxJS</code>就是<code>Anuglar</code>提供的异步编程方案。</p>\n<p><code>RxJS</code>官网描述自己是<code>Reactive Extensions Library for JavaScript（为JS而打造的响应式可扩展编程）</code>，也可以把<code>RxJS</code>当做处理异步行为的<code>Lodash</code>库<code>（Think of RxJS as Lodash for events）</code>。<code>RxJS</code>是编程范式函数式编程(<code>Functional Programming</code>)与响应式编程(<code>Reactive Programming</code>)的结合，换句话说，<code>RxJS</code>是一种编程思想，使用它能够让编写的代码更优雅，可读性更高。或许正是这样，在国内知名度并不是很高，网上可参考的资料也不是很多，自己学习这部分时主要是参考了<code>J.H. Blog</code>的<code>30天精通RxJS</code>系列文章，该系列文章是2016年到2017年由作者洪名辰编写，虽然其中很多的API已经被官方废弃，但文章的编程思想仍未过时，学习时结合RxJS官方文档，便很快能够上手。</p>\n<h1 id=\"什么是Observable\"><a href=\"#什么是Observable\" class=\"headerlink\" title=\"什么是Observable\"></a>什么是Observable</h1><h2 id=\"Observer-Pattern\"><a href=\"#Observer-Pattern\" class=\"headerlink\" title=\"Observer Pattern\"></a>Observer Pattern</h2><p>观察者模式在程序设计中并不少见，如<code>DOM</code>操作中的通过给<code>DOM</code>元素绑定相应的事件去监听该<code>DOM</code>元素的相应行为（如鼠标点击、滑动等），并在该行为触发时执行对应的事件；或是大名鼎鼎的<code>Redux</code>的实现，其都是以观察者模式的思想为核心。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux 的简单实现</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">createStore</span> = (<span class=\"params\">reducer</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 公共状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 监听者队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> listeners = [];</span><br><span class=\"line\">  <span class=\"comment\">// getter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">getState</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// setter</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">dispatch</span>(<span class=\"params\">action</span>) &#123;</span><br><span class=\"line\">    currentState = <span class=\"title function_\">reducer</span>(currentState, action);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当dispatch触发，即状态更新时通知listeners</span></span><br><span class=\"line\">    listeners.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> <span class=\"title function_\">fn</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加监听事件</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">subscribe</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    listeners.<span class=\"title function_\">push</span>(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化store数据</span></span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;@@REDUX_INIT&quot;</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Iterator-Pattern\"><a href=\"#Iterator-Pattern\" class=\"headerlink\" title=\"Iterator Pattern\"></a>Iterator Pattern</h2><p><code>iterator</code>（迭代器）的概念实际上也并不陌生，ES6中也加入了原生的iterator接口，如<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>String</code>等JS中内置的数据结构都实现了该接口。实现<code>iterator</code>接口的方法是为其添加<code>Symbol.iterator</code>属性，其中包含<code>next</code>方法，该方法返回的迭代器对象包含两个属性：<code>value</code>和<code>done</code>。<code>done</code>指的是遍历是否结束，<code>value</code>为下一次迭代的值，<code>done</code>为<code>true</code>时<code>value</code>一般为<code>undefined</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iterableExample = &#123;</span><br><span class=\"line\">\t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">next</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">value</span>: <span class=\"string\">&#x27;Sunday&#x27;</span>，</span><br><span class=\"line\">\t\t\t\t\t<span class=\"attr\">done</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">&#x27;Monday&#x27;</span>, <span class=\"string\">&#x27;Tuesday&#x27;</span>, <span class=\"string\">&#x27;Wednesday&#x27;</span>, <span class=\"string\">&#x27;Thursday&#x27;</span>, <span class=\"string\">&#x27;Friday&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> iterator = arr[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]()</span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Monday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Tuesday&#x27;, done: false&#125;</span></span><br><span class=\"line\">iterator.<span class=\"title function_\">next</span>() <span class=\"comment\">// &#123;value: &#x27;Wednesday&#x27;, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这样就很好地分离了<code>iterator</code>与<code>iterable</code>的概念。</p>\n<h2 id=\"Observable\"><a href=\"#Observable\" class=\"headerlink\" title=\"Observable\"></a>Observable</h2><p><code>Observable</code>结合了<code>Observer</code>与<code>Iterator</code>的思想，像<code>Observe</code>与<code>Iterator</code>一样以流的形式包装数据，同时能够以<code>Observe</code>的方式通知更新，以<code>Iterator</code>的方式去处理数据。这样说起来可能有点抽象，但是结合<code>Observable</code>实例就能很好地理解。</p>\n<h1 id=\"创建-Observable\"><a href=\"#创建-Observable\" class=\"headerlink\" title=\"创建 Observable\"></a>创建 Observable</h1><p>创建<code>Observable</code>实例的基本方法,使用<code>Observable</code>构造函数来创建一个<code>Observable</code>实例对象，其中可以传入一个回调函数,接收一个<code>subscriber</code>，用来指定该如何处理数据。需要注意的是，<code>Observable</code>作为被观察的对象，需要使用<code>subscribe</code>方法来通知<code>subscriber</code>去对<code>Observable</code>作出处理。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用subscrible方法来订阅Observable</span></span><br><span class=\"line\">observalbe1.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理非同步行为</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observalbe2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Suda&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kasumi&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Nana&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observalbe2.<span class=\"title function_\">subscribe</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// Suda</span></span><br><span class=\"line\"><span class=\"comment\">// Nana</span></span><br><span class=\"line\"><span class=\"comment\">// Kasumi</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>订阅<code>Observable</code>的被称为观察者，观察者具有三种行为（方法）来处理<code>Observable</code>的数据：</p>\n<ul>\n<li><code>next</code>：当Observable发送新的值，即调用其中的next方法时，观察者的<code>next</code>方法就会被调用。</li>\n<li><code>complete</code>：在<code>Observable</code>中完成遍历即调用其中的<code>complete</code>方法时，观察者的<code>complete</code>方法会被调用，在此之后的<code>next</code>方法不会执行。</li>\n<li><code>error</code>：在<code>Observable</code>中出现错误时，观察者的<code>error</code>方法会被调用。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> observable3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Observable</span>(<span class=\"function\">(<span class=\"params\">subscriber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Inuyasha&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kikyo&#x27;</span>);</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">complete</span>();</span><br><span class=\"line\">  subscriber.<span class=\"title function_\">next</span>(<span class=\"string\">&#x27;Kagome&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与Promise类似的处理方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> observer = &#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">observable3.<span class=\"title function_\">subscribe</span>(observer);</span><br><span class=\"line\"><span class=\"comment\">// Inuyasha</span></span><br><span class=\"line\"><span class=\"comment\">// Kikyo</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，只传入一个函数时会被默认指定为<code>next</code>的回调函数。</p>\n<h1 id=\"创建-Observable-实例的常用方法\"><a href=\"#创建-Observable-实例的常用方法\" class=\"headerlink\" title=\"创建 Observable 实例的常用方法\"></a>创建 Observable 实例的常用方法</h1><h2 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h2><blockquote>\n<p><code>of&lt;T&gt;(...args: (SchedulerLike | T)[]): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>需要注意其参数与方法<code>Function.prototype.call</code>类似，需要为一连串的参数，而不直接是一个数组，处理的顺序为传入参数的顺序，下图来自rxjs官网。</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec79fa46-8b7d-4e5c-bc52-99c29733f5c6/of.png\" alt=\"of.png\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">of</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"from\"><a href=\"#from\" class=\"headerlink\" title=\"from\"></a>from</h2><blockquote>\n<p><code>from&lt;T&gt;(input: ObservableInput&lt;T&gt;, scheduler?: SchedulerLike): Observable&lt;T&gt;</code></p>\n</blockquote>\n<p>该方法弥补了<code>of</code>方法不能直接传入数组等数据结构等缺陷，参数为<code>Array</code>、<code>类数组对象</code>、<code>Promise</code>、<code>可迭代对象</code>或<code>类 Observable 对象</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">from</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">from</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">source.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"interval\"><a href=\"#interval\" class=\"headerlink\" title=\"interval\"></a>interval</h2><blockquote>\n<p><code>interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>这个方法能够实现JS中<code>setInterval</code>的功能，需要注意第一个参数是以<code>ms</code>为单位的时间间隔。</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/secure.notion-static.com/88a059b6-b771-4e22-a36d-2e4406d08b10/interval.png\" alt=\"图片来自rxjs官网\"></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = <span class=\"title function_\">interval</span>(<span class=\"number\">2000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 以2秒的间隔从0开始在控制台输出数字</span></span><br><span class=\"line\">numbers.<span class=\"title function_\">subscribe</span>(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h2><blockquote>\n<p><code>timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable&lt;number&gt;</code></p>\n</blockquote>\n<p>该方法与<code>Interval</code>类似，第一个参数指定间隔多少时间后调用，可以是数字，也可以是具体日期，第二个参数指定了第一次调用之后每次调用的时间间隔。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; timer &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只传一个参数表示指需要调用一次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = <span class=\"title function_\">timer</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">source1.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一次调用后会每隔1秒调用1次</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = <span class=\"title function_\">timer</span>(<span class=\"number\">2000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">source2.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 2秒之后开始输出 0 1 2 3 4 ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EMPTY-NEVER\"><a href=\"#EMPTY-NEVER\" class=\"headerlink\" title=\"EMPTY, NEVER\"></a>EMPTY, NEVER</h2><p>这两个<code>Observable</code>常量分别用来替代在以前版本的<code>empty</code>方法与<code>never</code>方法，前者会直接<code>complete</code>，后者不会被执行。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"variable constant_\">EMPTY</span>, <span class=\"variable constant_\">NEVER</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">EMPTY</span>.<span class=\"title function_\">subscribe</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">next</span>: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value),</span><br><span class=\"line\">  <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;complete&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error),</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// complete</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不会被执行</span></span><br><span class=\"line\"><span class=\"variable constant_\">NEVER</span>.<span class=\"title function_\">subscribe</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;never be called&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"throwError\"><a href=\"#throwError\" class=\"headerlink\" title=\"throwError\"></a>throwError</h2><blockquote>\n<p><code>throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable&lt;never&gt;</code></p>\n</blockquote>\n<p>该方法会直接抛出异常，与<code>Promise.reject</code>方法类似。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; throwError &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">throwError</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Ops!&#x27;</span>)).<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a><strong>Subscription</strong></h2><p>在对<code>Observable</code>进行<code>subscribe</code>之后，如果不进行释放，会一直占用资源，从而造成内存泄漏。为此，就跟<code>setTimeout</code>、<code>setInterval</code>等方法一样，需要我们在使用完后手动进行释放。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; interval &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source = <span class=\"title function_\">interval</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> subscriptipn = source.<span class=\"title function_\">subscribe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用完后手动释放</span></span><br><span class=\"line\">subscriptipn.<span class=\"title function_\">unsubscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><strong>30天精通RxJS</strong></p>\n<p><strong>RxJS官方文档</strong></p>\n<p><strong>ECMAScript 6 入门</strong></p>\n<p><strong><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a></strong></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl2swzk0q00007yo93udh23ar","category_id":"cl2sx0rny00047yo9f1ou0375","_id":"cl2sx0rnz00067yo99yja4ptz"},{"post_id":"cl2swzk0u00017yo9dckjg3zj","category_id":"cl2sx0rny00047yo9f1ou0375","_id":"cl2sx0wnc00077yo989xec4n8"},{"post_id":"cl2sx3i0200087yo92x8h0nl0","category_id":"cl2sx0rny00047yo9f1ou0375","_id":"cl2sx4hah000a7yo914pscnx0"},{"post_id":"cl2sxm33l0000e1o91ut83y7z","category_id":"cl2sx0rny00047yo9f1ou0375","_id":"cl2sxpais0002e1o9aha43kkh"},{"post_id":"cl2tt7ugm00006ro938oq9huk","category_id":"cl2sx0rny00047yo9f1ou0375","_id":"cl2tt8p3200026ro978zs42lv"},{"post_id":"cl2u3l1gl0001nvo9hrsa3sp9","category_id":"cl2sx0rny00047yo9f1ou0375","_id":"cl2u3q27b0001tio920h25xvw"}],"PostTag":[{"post_id":"cl2swzk0u00017yo9dckjg3zj","tag_id":"cl2sltkxw0000l2o9hgukeomt","_id":"cl2swzk0u00027yo97cqt54z7"},{"post_id":"cl2swzk0q00007yo93udh23ar","tag_id":"cl2sltkxw0000l2o9hgukeomt","_id":"cl2sx0rny00057yo91h1ggqwh"},{"post_id":"cl2sx3i0200087yo92x8h0nl0","tag_id":"cl2sltkxw0000l2o9hgukeomt","_id":"cl2sx4hah00097yo92vvbbxz6"},{"post_id":"cl2sxm33l0000e1o91ut83y7z","tag_id":"cl2sltkxw0000l2o9hgukeomt","_id":"cl2sxpais0001e1o9howk57l2"},{"post_id":"cl2tt7ugm00006ro938oq9huk","tag_id":"cl2sltkxw0000l2o9hgukeomt","_id":"cl2tt8p3200016ro923ht4teb"},{"post_id":"cl2u3l1gl0001nvo9hrsa3sp9","tag_id":"cl2sltkxw0000l2o9hgukeomt","_id":"cl2u3tfpf0004tio93w0mdmwo"},{"post_id":"cl2u3l1gl0001nvo9hrsa3sp9","tag_id":"cl2u3tfpe0003tio95alyhsdo","_id":"cl2u3tfpf0005tio94tx5ey00"}],"Tag":[{"name":"JavaScript","_id":"cl2sltkxw0000l2o9hgukeomt"},{"name":"JavaScript RxJS","_id":"cl2u3q27a0000tio9cer6b6ic"},{"name":"RxJS","_id":"cl2u3tfpe0003tio95alyhsdo"}]}}